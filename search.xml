<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[epoll的运行机制]]></title>
    <url>%2Fepoll%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[epoll原理epoll是Linux系统下一个高效的多路复用IO机制。Linux下，一切皆文件。epoll可对大部分IO操作，以下以socket为例，对epoll机制进行简单解释。用户进程所有的IO都由操作系统统一管理，所有的IO对象（socket，通道，文件等）在内核都对应一个文件描述符，用户只能操作文件描述符，由内核去和具体的IO设备打交道。 系统调用APIlinux有三个系统调用来操作epoll，分别是epoll_create，epoll_ctl，epoll_wait。 1int epoll_create(int size); 这个函数创建一个epoll文件，返回对应的文件描述符，入参没什么用，为了向后兼容，大于0就好。通过这个函数，会在内核中开辟一段高速缓存空间，保存需要监听的socket，以及一个就绪list。 123456789101112typedef union epoll_data &#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; __uint32_t events; epoll_data_t data;&#125;;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这个函数修改fd在epoll中的状态，将这个fd插入/删除/修改到红黑树中，并向内核中断处理程序注册一个回调，当这个fd有事件发生，就向list中插入这个fd。epfd为之前创建的epoll文件描述符，op为注册的操作，fd为需要监听的文件描述符，event为需要监听的事件。op有三个选择： EPOLL_CTL_ADD 添加fd为监听的文件 EPOLL_CTL_MOD 修改fd的监听事件 EPOLL_CTL_DEL 不在监听fd event-&gt;events有7种选择，可通过位或选择多个选项： EPOLLIN fd可读 EPOLLOUT fd可写 EPOLLPRI 有紧急数据可读 EPOLLERR fd发生错误 EPOLLHUP fd被挂断 EPOLLET 将EPOLL 设为ET模式 EPOLLONESHOT 这个fd只监听一次，一次之后将它从监听中删除 event-&gt;data 联合体。设置fd为要监听的对象或设置ptr为要写的数据，其他用法不清楚。 1int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout); 这个函数会启动epoll监听，线程会在这阻塞，直到有被监听的事件发生，函数会检查list中是否有元素，如有，就将所有元素copy到events,并清空list。epfd为epoll的fd, events为为存储返回的所有发生的事件，maxevents为events的大小，timeout为超时限制。返回值为返回的event的个数。timeout为-1表示永久等待，0表示立即返回。 一个服务端监听socket的例子1234567891011121314151617181920212223242526272829for( ; ; )&#123; nfds = epoll_wait(epfd,events,20,500); for(i=0;i&lt;nfds;++i)&#123; if(events[i].data.fd==listenfd)&#123; //如果是主socket的事件，则表示有新的连接 connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); //accept这个连接 ev.data.fd=connfd; ev.events=EPOLLIN|EPOLLET; epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); //将新的fd添加到epoll的监听队列中 &#125; else if( events[i].events&amp;EPOLLIN )&#123; //接收到数据，读socket if ( (sockfd = events[i].data.fd) &lt; 0) continue; n = read(sockfd, line, MAXLINE)) &lt; 0 //读 ev.data.ptr = md; //md为自定义类型，添加数据 ev.events=EPOLLOUT|EPOLLET; epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);//修改标识符，等待下一个循环时发送数据，异步处理的精髓 &#125; else if(events[i].events&amp;EPOLLOUT)&#123; //有数据待发送，写socket struct myepoll_data* md = (myepoll_data*)events[i].data.ptr; //取数据 sockfd = md-&gt;fd; send( sockfd, md-&gt;ptr, strlen((char*)md-&gt;ptr), 0 ); //发送数据 ev.data.fd=sockfd; ev.events=EPOLLIN|EPOLLET; epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); //修改标识符，等待下一个循环时接收数据 &#125; else&#123; //其他情况的处理 &#125; &#125;&#125; 一个监听管道的例子读管道端：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int fifo_fd1, fifo_fd2; int ep_fd; struct epoll_event event; struct epoll_event *ret_events = NULL; int cnt; int i; char c; mkfifo("./fifo1", 0666); mkfifo("./fifo2", 0666); fifo_fd1 = open("./fifo1", O_RDONLY); fifo_fd2 = open("./fifo2", O_RDONLY); /* 需要有进程以只写的方式打开fifo1、fifo2后才能执行于此 */ printf("监测fifo1和fifo2中...\n"); /* 创建epoll池 */ ep_fd = epoll_create1(0); /* 将检测事件加入epoll池中 */ event.events = EPOLLIN | EPOLLET; /* 监测fifo1可读，且以边沿方式触发 */ event.data.fd = fifo_fd1; epoll_ctl(ep_fd, EPOLL_CTL_ADD, fifo_fd1, &amp;event); event.events = EPOLLIN | EPOLLET; /* 监测fifo2可读，且以边沿方式触发 */ event.data.fd = fifo_fd2; epoll_ctl(ep_fd, EPOLL_CTL_ADD, fifo_fd2, &amp;event); /* ret_events用于存放被触发的事件 */ ret_events = malloc(sizeof(struct epoll_event) * 100); /* 阻塞等待监测事件触发 */ cnt = epoll_wait(ep_fd, ret_events, 100, -1); printf("cnt = %d\n", cnt); /* 判断监测事件 */ for (i = 0; i &lt; cnt; i++) &#123; if (ret_events[i].events &amp; EPOLLIN) &#123; read(ret_events[i].data.fd, &amp;c, 1); printf("fd = %d, recv data = %c\n", ret_events[i].data.fd, c); &#125; &#125; free(ret_events); close(ep_fd); /* 注意关闭epoll池的描述符 */ close(fifo_fd2); close(fifo_fd1); return 0;&#125; 写管道1：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int fd; char c; fd = open("./fifo1", O_WRONLY); printf("w1: pls input char: \n"); scanf("%c", &amp;c); write(fd, &amp;c, 1); close(fd); return 0;&#125; 写管道2：1234567891011121314int main(void)&#123; int fd; char c; fd = open("./fifo2", O_WRONLY); printf("w2: pls input char: \n"); scanf("%c", &amp;c); write(fd, &amp;c, 1); close(fd); return 0;&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊keystore文件解析]]></title>
    <url>%2F%E4%BB%A5%E5%A4%AA%E5%9D%8Akeystore%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[通过以太坊客户端（geth或mist）生成以太坊账户，会在“~/.ethereum/keystore下产生对应于账户的文件，该文件保存了账户相关的信息，如私钥和地址。” 参考https://medium.com/@julien.maffre/what-is-an-ethereum-keystore-file-86c8c5917b97 文件名文件名形式: UTC–&lt;created_date_time&gt;–&lt;地址&gt;如：UTC–2018-07-23T02-30-23.717223803Z–1062024529684b1890b2fa5964334d8db7da2512 文件结构{ &quot;address&quot;:&quot;1062024529684b1890b2fa5964334d8db7da2512&quot; &quot;crypto&quot; : { &quot;cipher&quot; : &quot;aes-128-ctr&quot;, &quot;cipherparams&quot; : { &quot;iv&quot; : &quot;83dbcc02d8ccb40e466191a123791e0e&quot; }, &quot;ciphertext&quot; : &quot;d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c&quot;, &quot;kdf&quot; : &quot;scrypt&quot;, &quot;kdfparams&quot; : { &quot;dklen&quot; : 32, &quot;n&quot; : 262144, &quot;r&quot; : 1, &quot;p&quot; : 8, &quot;salt&quot; : &quot;ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19&quot; }, &quot;mac&quot; : &quot;2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097&quot; }, &quot;id&quot; : &quot;3198bc9c-6672-5ab3-d995-4942343ae5b6&quot;, &quot;version&quot; : 3 } 由用户输入的通行证得到派生keyKey Derivation Function，用户输入的passphrase通过key derivation function得到decryption key, 密钥生成密钥是由客户端产生的，不受用户的控制，keystore中保存的”ciphertext”字段是密钥的密文，密文由密钥通过”cipher”指定的算法和decryption key生成，其中参数是”cipherparams”。 mac的作用以上说的是生成密钥密文的过程。当用户需要得到密钥的时候，通过同样步骤得到decryption key，然后取decryption的一部分和ciphertxt连接，再hash，将结果与mac对比，相同则代表用户输入的通行证是对的。之后再用decryption与ciphertext通过cipher算法解密出私钥明文（对称加密）。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式简单例子]]></title>
    <url>%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[最近在看《重构》，第一章的例子就用到了State模式来重构一段代码。State模式的结构还笔记好理解，所以就试着写一个简单的例子。 State模式的思想首先有一个抽象的基类State，在其中定义了一些接口。State的派生类实现了这些接口，每个派生类的操作各不同。另外，还有一个类Context，类中有一个成员State，通过这个成员来表示Context所处的状态。Context可以改变不同的状态，从而对外展示出不同的特性。（这里的类名随意取的） 代码State类：1234567891011121314#ifndef TSTATEMODE_STATE_H_#define TSTATEMODE_STATE_H_namespace tstatemode &#123;class State &#123;public: virtual ~State() &#123;&#125;; virtual void Handle() = 0;&#125;;&#125; // namespace tstatemode#endif // TSTATEMODE_STATE_H_ State类中就定义了一个Handle接口。 子类ConcreteState1头文件:12345678910111213141516#ifndef TSTATEMODE_CONCRETE_STATE1_H_#define TSTATEMODE_CONCRETE_STATE1_H_#include &quot;state.h&quot;namespace tstatemode &#123;class ConcreteState1: public State &#123;public: virtual ~ConcreteState1(); virtual void Handle();&#125;;&#125; // namespace tstatemode#endif // TSTATEMODE_CONCRETE_STATE1_H_ 子类ConcreteState1源文件:12345678910111213#include &quot;concrete_state1.h&quot;#include &lt;stdio.h&gt;namespace tstatemode &#123;ConcreteState1::~ConcreteState1() &#123; &#125;void ConcreteState1::Handle() &#123; printf(&quot;ConcreteState1 %s\n&quot;, __FUNCTION__);&#125;&#125; // namespace tstatemode 子类ConcreteState2头文件:12345678910111213141516#ifndef TSTATEMODE_CONCRETE_STATE2_H_#define TSTATEMODE_CONCRETE_STATE2_H_#include &quot;state.h&quot;namespace tstatemode &#123;class ConcreteState2: public State &#123;public: virtual ~ConcreteState2(); virtual void Handle();&#125;;&#125; // namespace tstatemode#endif // TSTATEMODE_CONCRETE_STATE2_H_ 子类ConcreteState2源文件:12345678910111213#include &quot;concrete_state2.h&quot;#include &lt;stdio.h&gt;namespace tstatemode &#123;ConcreteState2::~ConcreteState2() &#123; &#125;void ConcreteState2::Handle() &#123; printf(&quot;ConcreteState2 %s\n&quot;, __FUNCTION__);&#125;&#125; // namespace tstatemode Context类头文件：12345678910111213141516171819#ifndef TSTATEMODE_CONTEXT_H_#define TSTATEMODE_CONTEXT_H_#include &quot;state.h&quot;namespace tstatemode &#123;class Context &#123;public: Context(State* state): state_(state) &#123;&#125; bool ChangeState(State* state); void Display();private: State* state_;&#125;;&#125; // namespace tstatemode#endif // TSTATEMODE_CONTEXT_H_ Context类源文件：123456789101112131415#include &quot;context.h&quot;namespace tstatemode &#123;bool Context::ChangeState(State* state) &#123; if(nullptr != state) state_ = state; return true;&#125;void Context::Display() &#123; if(nullptr != state_) state_-&gt;Handle();&#125;&#125; // namespace tstatemode 主函数：12345678910111213141516171819202122232425#include &quot;context.h&quot;#include &quot;concrete_state1.h&quot;#include &quot;concrete_state2.h&quot;#include &quot;state.h&quot;int main() &#123; namespace tsm = tstatemode; tsm::State* state1 = new tsm::ConcreteState1(); tsm::State* state2 = new tsm::ConcreteState2(); tsm::Context context(state1); context.Display(); context.ChangeState(state2); context.Display(); context.ChangeState(state1); context.Display(); delete state1; delete state2; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称加密]]></title>
    <url>%2F%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[对称加密，就是对同一个文件进行加密和解密用的都是同一个密钥。 CA如何保证合法性非对称加密在网络信息传播中主要有两方面应用：信息加密和数字签名。信息加密的过程主要是： A生成公私钥对，将公钥公开。 B将要发送给A的信息用公钥加密。 A收到密文，用私钥进行解密。这过程中，因为只有A拥有对应的私钥，所以用A的公钥加密的信息，只有A能解密。 数字签名的过程可看成信息加密的逆过程，简单抽象如下： A生成自己的公私钥对，将公钥公开。 A要发送消息时，对消息进行哈希，用私钥对哈希加密，生成签名，将信息和签名一起发出。 收到A发送的信息和签名的接收方，用A的公钥对签名解密，验证信息的哈希和解密出来的哈希，即证明消息的发送方是否是A。 这里存在的问题是，如何保证收到者得到的A的公钥就是A发出来的。解决方法是通过CA（认证机构）来保证。 消息的发送方A将公钥交给CA。 CA生成自己的公私钥，用CA的私钥对A的公钥进行签名，将A的公钥和签名打包成证书。 消息接收方B如果要接受A的消息，就从CA获取A的证书，并用CA的公钥对证书验签，获得A的公钥。 A用私钥进行签名，B用CA证书中的公钥验签。这个过程又存在一个问题，怎么保证CA的公钥就是可信的。这里基于的假设就是CA一定是可信的，不然这会是一个无限递归的问题。 参考：http://www.cnblogs.com/songwenlong/p/6517165.html。文章中简明的概述了加密算法、哈希、数字签名、公钥证书在消息传输中的作用和解决的问题。 DES对称加密算法参考：https://www.cnblogs.com/songwenlong/p/5944139.html。比较详细的介绍。DES是分块加密的，每块数据大小64位，密码也是64位。 IP置换。将64位数据按照设计好的规则换位，再分位左右32位的两部分L0，R0. 密钥置换。密钥每字节取前7位，最后一位作为校验位，总共56位，这56位也按照设定的规则换位，再分成28位的两部分，按照设定的规则向左移位，之后再从这里选择48位。 R0做成4X8的矩阵，分别在两侧补相邻的8位，形成48位。 S盒替代。48位分别通过8个S盒进行坐标映射替换，得到32位。 P盒置换。对S盒输出的32位进行置换，按照预先设定的规则。 IP-1末置换。左右两部分合成，进行置换。 移位、置换、扩展、压缩、异或、迭代]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hyperchain开放入门]]></title>
    <url>%2Fhyperchain%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[hpc.properties配置基于Hyperchain的应用程序需要运行在至少4个节点上，hpc.properties主要用于配置节点信息。hpc.properties主要内容如下： 123456789101112131415161718192021222324252627282930313233343536373839#Hyperchain Nodes IP Ports#node = &#123;&quot;nodes&quot;:[&quot;ino2&quot;,&quot;ino2&quot;,&quot;ino2&quot;,&quot;ino2&quot;]&#125;#node = &#123;&quot;nodes&quot;:[&quot;123.206.232.138:8081&quot;,&quot;123.206.232.138:8082&quot;,&quot;123.206.232.138:8083&quot;,&quot;123.206.232.138:8084&quot;]&#125;#node = &#123;&quot;nodes&quot;:[&quot;122.152.218.100:8081&quot;,&quot;111.231.106.89:8081&quot;,&quot;111.231.118.14:8081&quot;,&quot;111.231.106.41:8081&quot;]&#125;node = &#123;&quot;nodes&quot;:[&quot;192.168.130.141&quot;,&quot;192.168.130.142&quot;,&quot;192.168.130.143&quot;,&quot;192.168.130.65&quot;]&#125;# JsonRpc connect port#jsonRpcPort = [9041, 9042, 9043, 9044]jsonRpcPort = [8047, 8047, 8047, 8047]# webSocket connect portwebSocketPort = [10001, 10001, 10001, 10001]#Namespacenamespace = global#重发次数resendTime = 10#第一次轮训时间间隔 unit /msfirstPollingInterval = 100#发送一次,第一次轮训的次数firstPollingTimes = 10#第二次轮训时间间隔 unit /mssecondPollingInterval = 1000#发送一次,第二次轮训的次数secondPollingTimes = 10#Send Tcert during the request or notSendTcert = false#if sendTcert is true , you should add follow path.#ecertPath = certs/sdkcert.cert#ecertPriPath = certs/sdkcert.priv#uniquePrivPath = certs/unique.priv#uniquePubPath = certs/unique.pub#发送重新连接请求间隔(/ms)reConnectTime = 10000&#125; 其中，主要注意node, jsonRpcPort, webSocketProt的配置，分别对应各个节点的IP和开放的端口。 日志的配置log4j.propertieshyperchain采用log4j作为日志输出，配置文件如下:12345678### 设置##### 如果设置为DEBUG将输出调用信息log4j.rootLogger=INFO,stdout### 输出信息到控制抬 ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n 合约编译hyperchain平台支持solidity和java两种语言的合约，由于solidity是Ehtereum推出的语言，相关支撑的工具更多。Solidity合约可以在remix中编辑、编译、调试，并能获取对应的abi，bin。可以在hyperchain应用代码中编译合约，但是更推荐通过别的工具编译好以后在代码中直接用。 合约代码一个简单的合约：12345678pragma solidity ^0.4.24;contract Echo &#123; function echo(uint32 a) public pure returns(uint32 _a) &#123; return a; &#125;&#125; 应用程序代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.qqq.test;import cn.hyperchain.sdk.rpc.HyperchainAPI;import cn.hyperchain.sdk.rpc.Transaction.Transaction;import cn.hyperchain.sdk.rpc.account.Account;import cn.hyperchain.sdk.rpc.base.VMType;import cn.hyperchain.sdk.rpc.function.FuncParamReal;import cn.hyperchain.sdk.rpc.function.FunctionDecode;import cn.hyperchain.sdk.rpc.function.FunctionEncode;import cn.hyperchain.sdk.rpc.returns.ReceiptReturn;import cn.hyperchain.sdk.rpc.utils.Utils;import java.math.BigInteger;public class Main &#123; private static String hpcPath = &quot;D:\\mycode\\java\\echo\\src\\resources\\hpc.properties&quot;; private static String accountJsonPath = &quot;D:\\mycode\\java\\echo\\info\\accountJson.txt&quot;; private static String contractAddressPath = &quot;D:\\mycode\\java\\echo\\info\\contractAddress.txt&quot;; private static String contractBinPath = &quot;D:\\mycode\\java\\echo\\src\\contract\\echo.bin&quot;; private static String contractAbiPath = &quot;D:\\mycode\\java\\echo\\src\\contract\\echo.abi&quot;; public static void main(String[] args) throws Exception&#123; System.out.println(&quot;qqq&quot;); //deployContract(); echo(); &#125; public static void deployContract() throws Exception&#123; HyperchainAPI hyperchain = new HyperchainAPI(hpcPath); String accountJson = hyperchain.newAccountSM2(&quot;123456&quot;); Utils.writeFile(accountJsonPath,accountJson); Account account = new Account(accountJson); /** * 在线编译合约 */ //String contractPath = &quot;D:\\mycode\\java\\echo\\src\\contract\\echo.sol&quot;; //String contract = Utils.readFile(contractPath); //CompileReturn compileReturn = hyperchain.compileContract(contract); //List&lt;String&gt; contractAbi = compileReturn.getAbi(); //List&lt;String&gt; contractBin = compileReturn.getBin(); //System.out.println(&quot;=== Abi Bin&quot;); //System.out.println(contractBin.get(0)); //System.out.println(contractAbi.get(0)); //System.out.println(&quot;===&quot;); String bin = Utils.readFile(contractBinPath); Transaction transaction = new Transaction(account.getAddress(), bin, true, VMType.EVM); transaction.signWithSM2(accountJson,&quot;123456&quot;); ReceiptReturn receiptReturn = hyperchain.deployContract(transaction); String txHash = receiptReturn.getTxHash(); int code = receiptReturn.getCode(); String contractAddress = receiptReturn.getContractAddress(); Utils.writeFile(contractAddressPath,contractAddress); System.out.println(txHash); System.out.println(code); System.out.println(contractAddress); &#125; public static void echo() throws Exception &#123; String accountJson = Utils.readFile(accountJsonPath); Account account = new Account(accountJson); HyperchainAPI hyperchain = new HyperchainAPI(hpcPath); FuncParamReal param1 = new FuncParamReal(&quot;uint32&quot;,new BigInteger(&quot;11111&quot;)); String contractAddress = Utils.readFile(contractAddressPath); String payload = FunctionEncode.encodeFunction(&quot;insert&quot;,param1); Transaction transaction = new Transaction(account.getAddress(),contractAddress, payload,false, VMType.EVM); transaction.signWithSM2(accountJson,&quot;123456&quot;); ReceiptReturn receipt = hyperchain.invokeContract(transaction); if(!receipt.isSuccess()) &#123; System.out.println(&quot;echo error!&quot;); &#125; String abi = Utils.readFile(contractAbiPath); int code = receipt.getCode(); String rawReturn = receipt.getRet(); String decodeRet = FunctionDecode.resultDecode(&quot;echo&quot;,abi,rawReturn); System.out.println(code); System.out.println(decodeRet); &#125;&#125; 合约部署参照程序代码，部署合约分成3步： 通过hpc.properties生成HyperchainAPI对象。这是调用hyperchain平台的主要类。 生成账户，可以将accountJson保存成文本，今后再使用同一账户时，可以直接read改文本，再生成Account。 编译合约。可以在线编译，更推荐将编译好的合约直接使用。直接read合约的bin文件。。 生成交易。部署合约对于区块链也是一笔交易。交易都需要使用账户信息进行签名。 解析交易的返回信息。 触发合约参照程序代码，分成3步： 读取accountJson，生成Account。 生成HyperchainAPI. 规范化调用参数，由于solidity与java直接有一个数据类型映射关系。 获取合约地址。 生成交易信息。 生成交易。 对交易进行签名，触发。 解析交易回执。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>hyperchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile笔记]]></title>
    <url>%2Fmakefile%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[make概述make的基本模型如下：12targets: objects commands 简单的说就是我们要有一个目标 target（也可以是多个），生成这个目标需要依赖于多个对象 object，生成这个目标的方法就是 command。这里的object也可以有自己的依赖，这样层层递归，直到最底层，make会根据这个递归关系层层查找，然后从最底层的目标开始生成，然后层层往上生成最上层的目标（终极目标）。make会检测这些目标所依赖的对象是否被改动过，如果被改动，就运行命令command重新生成target。make其他的操作都是在这样的模式下进行的。make不限于做代码编译，凡是符合上面的模式的工作都可以做。 Tips @: makefile中可以添加shell命名，如果在shell命令之前加上 @ ，会让make不输出这条命令，只输出命令执行的结果。 cut: shell 命令 cut，通过参数设置，能够显示文本的指定列/字符。显示文件 aaa.txt 的第二列，以空格为分隔符： 1cut -f2 -d' ' aaa.txt 参数的用法：-f-4表示显示1到4列；如果显示指定字符： 1cut -c2 aaa.txt 表示显示每行的第二个字符，-c参数的运用和-f一样。 wildcard: makefile中的命令，用于获取当前目录下所有文件的文件路径（包括文件名）。用法： 1SOURCES = $(wildcard *.c) notdir: makefile中的命令。用于删除路径，保留文件名。（也就是把最后一个/之前的内容删除）。用法： 1FILES =$(notdir $(SOURCES)) patsubst: makefile中的命令。用于替换操作。例如： 1OBJS = $(patsubst %.c，%.o，$(SOURCES)) 表示将SOURCES中所有文件名的 .c 换成 .o。还有另一种写法： 1OBJS = $($(SOURCES): %.c = %.o) g++ -MP: g++ 的编译选项 -MP。以下是 g++ 文档的说明：This option instructs CPP to add a phony target for each dependency other than the main file, causing each to depend on nothing. These dummy rules work around errors make gives if you remove header files without updating the Makefile to match. This is typical output: 12test.o: test.c test.h test.h: 这就是为了当删除了头文件 test.h 能够触发 test.o 重新编译。 g++ -MMD: g++ 的编译选项。 首先是 -MM, 它会在编译阶段打印出编译对象的依赖（除了系统文件）；-MMD, 将产生的依赖关系写入 *.d 文件。通过 g++ 的这种机制，能够自动发现文件之间的依赖关系，某个编译对象依赖的文件发生变化时，触发重新编译。 在makefile中，如果存在两个相同的目标，会将其合并，并选择较新的命令执行。 在make执行过程中，如果include的文件发生变化，会让make重新读取整个makefile。这也是make能够根据 g++ 生成的依赖自动编译的原因。 一些特殊变量$^所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。 $@表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合 $?所有比目标新的依赖目标的集合。以空格分隔。 $&lt;依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将是符合模式的一系列的文件集。注意，其是一个一个取出来的。 make中的赋值 ?= 变量如果没有被赋值过，就赋予右边的值 := 覆盖之前的值 = 最基本的赋值 += 添加等号后面的值 =和:=的区别：=是将makefile最终展开后才确定值，:=是立即能确定值 很好的解释了自动生成依赖的文章http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch22s04.html 一个makefile的例子本例是别人放在github上的一个项目，通过解释makefile文件了解其工作原理。假设我们有如下工作目录：+– inclue| +– qvector.h+– src| +– main.cpp| +– qvector.cpp+– makefile 其中makefile是这样写的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980################################################################## 这部分都是定义一些变量，便于后续的操作#################################################################CXX ?= g++ SRC_PATH = src BUILD_PATH = build BIN_PATH = $(BUILD_PATH)/bin BIN_NAME = runner SRC_EXT = cpp ################################################################## 进行一些路径准备# SOURCEs保存了当前目录下所有以 cpp 结尾的文件的路径# OBJECTS通过模式匹配生成了每个源文件对应的目标文件路径# DEPS是依赖文件的路径#################################################################SOURCES = $(shell find $(SRC_PATH) -name '*.$(SRC_EXT)' | sort -k 1nr | cut -f2-) OBJECTS = $(SOURCES:$(SRC_PATH)/%.$(SRC_EXT)=$(BUILD_PATH)/%.o) DEPS = $(OBJECTS:.o=.d) ################################################################## 编译选项的配置#################################################################COMPILE_FLAGS = -std=c++11 -Wall -Wextra -g # -Wall-&gt; display warning, -Wextra-&gt;display other warningINCLUDES = -I include/ -I /usr/local/include LIBS = ################################################################## 定义了几个伪目标# 这里的伪命令是层层递归调用的：# default_target -&gt; release -&gt; dirs -&gt; dirs -&gt; all -&gt; $(BIN_PATH)/$(BIN_NAME)# -&gt; (BUILD_PATH)/%.o################################################################## 在makefile中，如果make没有指定目标，第一个出现的目标就是终极目标，所以这里是default_target。# default_target依赖于release，然后去检测release.PHONY: default_target default_target: release # release依赖于dirs，当依赖执行完成后，会执行它的命令 make all.PHONY: releaserelease: export CXXFLAGS := $(CXXFLAGS) $(COMPILE_FLAGS)release: dirs @$(MAKE) all # dirs用于创建两个目录.PHONY: dirsdirs: @echo "Creating directories" @mkdir -p $(dir $(OBJECTS)) @mkdir -p $(BIN_PATH)# 用于清理文件的伪命令.PHONY: cleanclean: @echo "Deleting $(BIN_NAME) symlink" @$(RM) $(BIN_NAME) @echo "Deleting directories" @$(RM) -r $(BUILD_PATH) @$(RM) -r $(BIN_PATH)# all目标依赖于$(BIN_PATH)/$(BIN_NAME)，当依赖解决后，执行命令，产生一个软链接.PHONY: all all: $(BIN_PATH)/$(BIN_NAME) @echo "Making symlink: $(BIN_NAME) -&gt; $&lt;" @$(RM) $(BIN_NAME) @ln -s $(BIN_PATH)/$(BIN_NAME) $(BIN_NAME)# $(BIN_PATH)/$(BIN_NAME)依赖于$(OBJECTS)，当所有的对象都更新完成后，执行命令，链接生成# 可执行文件。$(BIN_PATH)/$(BIN_NAME): $(OBJECTS) @echo "Linking: $@" $(CXX) $(OBJECTS) -o $@# 加载依赖文件，第一次不存在。-include $(DEPS) # 每个目标对象对应一个源文件，且会生成对应的依赖文件，这里的规则会和include的规则进行合并$(BUILD_PATH)/%.o: $(SRC_PATH)/%.$(SRC_EXT) @echo "Compiling: $&lt; -&gt; $@" $(CXX) $(CXXFLAGS) $(INCLUDES) -MP -MMD -c $&lt; -o $@ 自己的通用模板1234567891011121314151617181920212223242526272829303132333435363738394041424344EXE_NAME:=mainSRC_PATH:=.BUILD_PATH:=./buildBIN_PATH:=$(BUILD_PATH)/binEXE:=$(BIN_PATH)/$(EXE_NAME)SOURCES:=$(shell find $(SRC_PATH) -name '*.cpp')OBJS:=$(addprefix $(BUILD_PATH)/,$(SOURCES:%.cpp=%.o))DEPS:=$(addprefix $(BUILD_PATH)/,$(SOURCES:%.cpp=%.d))OBJS_DIR:=$(addprefix $(BUILD_PATH)/,$(shell dirname $(SOURCES) | sort | uniq))LIBS:=CPPFLAGS+= -g -Wall -std=c++11 -I ./includeCC:=g++all:$(EXE)$(shell mkdir -p $(OBJS_DIR))$(shell mkdir -p $(BIN_PATH))-include $(DEPS)$(EXE): $(OBJS) $(CC) $(CPPFLAGS) -o $@ $^ $(LIBS)$(OBJS): $(BUILD_PATH)/%.o: $(SRC_PATH)/%.cpp $(CC) -o $@ $(CPPFLAGS) -c $&lt;$(DEPS): $(BUILD_PATH)/%.d: $(SRC_PATH)/%.cpp @set -e; rm -f $@; \ $(CC) -MM $(CPPFLAGS) $&lt; &gt; $@.$$$$; \ sed 's,.*\.o[ :]*,$(patsubst %.d,%.o,$@) $@ : ,g' &lt; $@.$$$$ &gt; $@; \ rm -f $@.$$$$.PHONY: cleanclean: rm -rf ./build.PHONY: testtest: @echo $(DEPS) @echo $(OBJS) @echo $(SOURCES) @echo $(SRC_PATH) @echo $(BUILD_PATH) @echo $(OBJS_DIR)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Googletest入门文档翻译]]></title>
    <url>%2FGoogletest%E5%85%A5%E9%97%A8%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[Googletest入门 介绍：为什么选googletest? googletest帮助你写出更好的C++测试程序 googletest是google的测试技术团队开发的一个测试框架，开发这个框架是出于google特定的需求和约束考虑。无论使用Linux，Windows，还是Mac，只要你写C++代码，googletest都能帮助你。并且它不仅支持单元测试，还支持其他类型的测试。那么，什么样的测试是好的测试，googletest又是怎么做的？我们认为： 不同测试之间应该是独立的且可重复的。如果一个测试的成功与否依赖于其他的测试结果，这将是一件痛苦的事。googletest将各个测试运行在不同的对象中，以此独立不同的测试。如果一个测试挂了，googletest能让你在孤立的环境中运行它，实现快速调试。 测试集应该组织良好，并且能反映被测代码的结构。googletest将相关的tests分组到test cases中，使之能够共享数据和子程序。这种普通的模式很清晰，也让tests容易维护。对于切换了项目和开始基于一段新代码工作的人，这样的一致性非常有帮助。 Tests应该具有可移植性和可重用性。Google有很多平台独立的代码，它们的测试也应该是平台独立的。googletest可以在不同的操作系统运行，这些系统有不同的编译器（gcc，icc，和MSVC），有的支持异常有的不支持，所以googletest能够轻松的在各种配置下工作。 一旦tests失败，测试框架应该尽可能多的提供错误信息。googletest不会在第一个test失败后停下来，而是仅仅终止当前的test，然后继续下一个test。你也可以设置tests报告非致命错误，以此让当前test继续执行。因此，你能在一个run-edit-compile周期里，检测并修复多个bug。 测试框架应该把程序员从繁杂的琐事中解放出来，让他们专注于test内容。googletest自动跟踪所有已定义的tests，不需要用户为了运行而去枚举它们。 Tests应该是快速的。使用googletest，你能够重用在tests中共享的资源，并且只需要调用一次set-up/taer-down，tests之间没有依赖关系。 googletest基于流行的xUint架构，所以如果你在此之前使用过JUnit或者PyUnit，你会感觉很熟悉。否则，你需要花10分钟学习这些基础，然后再开始应用。开始吧！ 命名法须知注意：由于对术语Test, Test Case和Test Suite的不同定义，可能会造成一些困惑，所以留意这些可能的误解。以往，googletest开始用术语Test Case表示具有相关性的tests，然而，当前公开的一些框架是用Test Suite，包括International Software Testing Qualifications Board (ISTQB)和various textbooks on Software Quality。在googletest中使用的术语Test，与ISTQB和其他框架使用的术语Test Case意义一样。术语Test通常具有足够广泛的意义，也包括ISTQB定义的Test Case，所以这没有太多问题。但是在Google Test中使用的术语Test Case有一定的矛盾性，所以会让人迷惑。googletest最近开始用术语Test Suite替换Test Case，更好的API是TestSuite。旧的TestCase API逐渐被弃用和重构。所以，请留意这两个术语的不同定义： 意义 googletest术语 ISTQB术语 使用特定的输入值检验特定的程序执行路径并验证结果 TEST() Test Case 基本概念 使用googletest从写assertions开始，这是用于检查条件是否为真的表达式。一个assertion的结果可以是success，nonfatal failure，或者fatal failure。如果一个fatal failure发生，当前的函数会被终止；否则程序会正常继续执行。Tests用assertions去验证被测代码的行为。如果一个test挂了或者得到一个失败的assertion，这个test就是失败的；否则就是成功。一个test case包含一个或多个tests。你应该将tests分组到不同的test cases中，以反映被测代码的结构。当一个test case中的多个tests要共享通用的对象和子程序时，你可以将它们放入test fixture类中。一个test program能包含多个test cases。我们现在解释如何写一个测试程序，从单个assertion级别开始，直到建立tests和test cases。 Assertions googletest assertions是类似于函数调用的宏。通过对类或函数的行为设置assertions，来进行测试。当assertion失败，googletes打印assertion的源文件和它所在的行号，以及错误信息。你也可以提供定制的错误信息，这会添加在googletest信息后面。测试同样的功能assertions有两个版本，在测试函数中它们会表现出不同的效果。当断言失败，==ASSERT_==版本会产生致命错误并终止当前函数。==EXPECT_==产生非致命错误，不会终止当前函数。==EXPEXCT_==总是被推荐的，因为它们允许多个错误在一个test里面被报告。然而，当断言处发生错误后继续执行程序没有意义，你就应该使用==ASSERT_==。一个失败的==ASSERT_*==会立即从当前函数返回，所以可能会跳过在这之后的清理代码，这是否值得修复依赖于泄露的特性，所以记住这一点，如果你在断言错误后得到一个堆检测错误。为了提供定制的失败信息，可以通过操作符==&lt;&lt;==简单的将信息输入宏，或者一系列这样的操作。一个例子：12345ASSERT_EQ(x.size(), y.size()) &lt;&lt; "Vectors x and y are of unequal length";for (int i = 0; i &lt; x.size(); ++i) &#123; EXPECT_EQ(x[i], y[i]) &lt;&lt; "Vectors x and y differ at index " &lt;&lt; i;&#125; 任何能输入==ostream==的对象都能被输入断言宏–特殊的，C字符串和==string==对象。如果宽字符串（Windows的==wchar_t==, ==TCHAR==in==UNICODE==模式，或者==std::wstring==）被输入断言宏，会在打印时转换程UTF-8。 基本的Assertions这些assertions进行基本的true/false条件测试：| Fatal assertion | Nonfatal assertion | Verifies || —————————| —————————–| ———————–|| ASSERT_TRUE(condition); | EXPECT_TRUE(condition); | condition is true || ASSERT_FALSE(condition); | EXPECT_FALSE(condition); | condition is false | 记住，如果条件为false，==ASSERT_ ==产生一个致命错误并从当前函数返回，而==EXPECT_ ==产生一个非致命错误，函数会继续执行。无论哪种情况，一个断言失败意味着它包含测试失败。 可用性：Linux, Windows, Mac。 二元比较 这部分描述比较两个值的断言。| Fatal assertion | Nonfatal assertion | Verifies || ———————- | ———————- | ————-|| ASSERT_EQ(val1, val2); | EXPECT_EQ(val1, val2); | val1 == val2 || ASSERT_NE(val1, val2); | EXPECT_NE(val1, val2); | val1 != val2 || ASSERT_LT(val1, val2); | EXPECT_LT(val1, val2); | val1 &lt; val2 || ASSERT_LE(val1, val2); | EXPECT_LE(val1, val2); | val1 &lt;= val2 || ASSERT_GT(val1, val2); | EXPECT_GT(val1, val2); | val1 &gt; val2 || ASSERT_GE(val1, val2); | EXPECT_GE(val1, val2); | val1 &gt;= val2 | Value参数必须是能通过断言比较操作符比较的，否则会得到一个编译错误。我们过去要求参数支持能输入到==ostream==的==&lt;&lt;==操作符，但是现在不是必要的。如果支持==&lt;&lt;==，一旦断言失败，它会被调用来输出参数；否则googletest会尽可能用最合理的方式来打印它。更多细节以及如何定制化打印参数，参考gMock recipe。断言能用户定义的类型也有效，但必须要定义相关的比较运算符（比如 == == ==, == &lt; ==，等）。Google C++风格指南不鼓励运算符重载，所以你可能要使用== ASSERT_TRUE() == 或者 == EXPECT_TRUE() == 去断言自定义的两个对象是否相等。然而，如果可能，==ASSERT_EQ(actual, expected)==要优于==ASSERT_TRUE(actual == expected)==，因为前者会在失败时报告==actual==和==expected==的值。参数总是精确的计算一次。因此，参数产生的副作用是正常的。但是，就像任何正常的C/C++函数一样，参数的计算顺序是未定义的（即这个顺序是编译器相关的），并且你的代码不应该有任何特殊的参数计算顺序依赖。==ASSERT_EQ==进行指针的相等判断。如果在两个C字符串上使用，这会测试它们是否有相同的内存位置，而不是是否有一样的值。因此，如果你要比较C字符串（比如==const char==)的值就用==ASSERT_STREQ()==，稍后会有介绍。特殊的，断言一个C字符串是==NULL==，使用==ASSERT_STREQ(c_string, NULL)==。如果支持C++11，考虑用ASSERT_EQ(c_string, nullptr)。用==ASSERT_EQ==比较两个==string==对象。做指针比较时，用==_EQ(ptr, nullptr)==和==NE(ptr, nullptr)==代替==_EQ(ptr, NULL)==和==_NE(ptr, NULL)==。因为==nullptr是类型而==NULL==不是。如果你处理浮点数，你需要使用这些宏针对浮点的变化形式，以避免取整导致的问题。这节的宏支持宽字符对象和窄字符对象（==string==和==wstring==）。可用性：Linux, Windows, Mac。历史改动：2016年二月以前，==_EQ==有一个调用惯例==ASSERT_EQ(expected, actual)==，很多现有代码就使用这种顺序。现在==*_EQ==以相同的方式对待两个参数。 字符串比较 这部分的断言比较两个C字符串。如果要比较两个==string==对象，使用==EXPECT_EQ==，==EXPECT_NE==，和其他代替。| Fatal assertion | Nonfatal assertion | Verifies || — | — | — || ASSERT_STREQ(str1, str2); | EXPECT_STREQ(str1, str2); | the two C strings have the same content || ASSERT_STRNE(str1, str2); | EXPECT_STRNE(str1, str2); | the two C strings have different contents || ASSERT_STRCASEEQ(str1, str2); | EXPECT_STRCASEEQ(str1, str2); | the two C strings have the same content, ignoring case || ASSERT_STRCASENE(str1, str2); | EXPECT_STRCASENE(str1, str2); | the two C strings have different contents, ignoring case | 注意断言名字种的“CASE”意味着忽略了case，==NULL==指针和一个空的字符串是不同的。== STREQ ==和== STRNE ==也接收宽的C字符串（== wchar_t* ==）。如果两个宽字符串比较失败，它们的值会被UTF-8的字符串替换打印。可用性：Linux, Windows, Mac。其他：更多的字符串比较技巧（例如，子串，前缀，后缀和正则匹配），参考高级googletest指南的这部分。 简单的测试 建立一个测试： 用==TEST()==宏定义并命名一个测试函数，这就是通常的没有返回值的C++函数。 在这个函数种，可以包含你想要的各种有效的C++表达式，并用各种googletest断言去验证这些值。 测试的结果决定于这些断言；测试中的任何的断言失败（无论是致命的还是非致命的），或者测试挂了，整个测试都是失败的，否则，测试成功。123TEST(TestSuiteName, TestName) &#123; ... test body ...&#125; ==TEST()==参数从一般到具体。第一个参数是test case的名字，第二个参数是这个test case 中 test 的名字。两个名字都必须是有效的C++命名符，并且不能包含下划线（==_==）。一个测试的全名由它的test case和test名字组成。不同的test case中的test可以由相同的test名字。例如，我们写一个简单的整型函数：1int Factorial(int n); // Returns the factorial of n 这个函数的test case可能会是这样：123456789101112// Tests factorial of 0.Test(FactorialTest, HandlesZeroInput) &#123; EXPECT_EQ(Factorial(0), 1);&#125;// Tests factorial of positive numbers.TEST(FactorialTest, HandlesPositiveInput) &#123; EXPECT_EQ(Factorial(1), 1); EXPECT_EQ(Factorial(2), 2); EXPECT_EQ(Factorial(3), 6); EXPECT_EQ(Factorial(8), 40320);&#125; googletest以test cases为单位对测试结果分组，所以逻辑相关的tests应该被放在一个test case里；换言之，==TEST()==的第一个参数应该一样。在上面的例子中，由两个tests，==HandlesZeroInput==和==HandlesPositiveInput==，它们都属于==FactorialTest==。命名test cases 和 tests时，应该遵循与函数命名和类命名同样的惯例。可用性：Linux, Windows, Mac。 测试装置：多个测试使用相同的数据配置 如果你发现你写的两个或多个tests操作相似的数据，你可以使用 test fixture。它能让你在不同的tests中重用相同的对象配置。建立一个配置： 继承==::testing::Test==。从==protected:==开始写内容，也就是你想要从子类访问的配置成员。 在类中申明任意你想要使用的对象。 如果必要，写一个默认的构造函数或者==SetUp()==函数，用来给每个测试初始化对象。一个常见的错误是将==SetUp()==拼写成==Setup()==，小写了==u==，可以在C++11中使用==override==确保拼写正确。 如果必要，写一个析构函数或者==TearDown()==函数去释放在==SetUp()==中分配的资源。阅读这里的FAQ，学习什么时候用构造和析构，什么时候用==SetUp()/TearDown()==。 如果需要，给你的tests定义共享的子程序。 当使用fixture，用==TEST_F()==代替==TEST()==，前者能让你访问这个test fixture中的对象和子程序：123TEST_F(TestSuiteName, TestName) &#123; ... test body ...&#125; 如同==TEST()==，第一个参数是test case的名字，但是对于==TEST_F()，必须是这个test fixture类的类名。你可能已经猜到：==_F==代表fixture。遗憾的是，C++宏不允许我们创建一个宏来处理两种类型的测试。使用错误的宏会导致编译器错误。你必须在==TEST_F()==使用test fixture之前定义它，否则会得到编译错误“virtual outside class declaration”。对于每个用==TEST_F()==定义的test，googletest会在运行时创造一个新的test fixture，通过==SetUp()==立即初始化，运行test，通过==TearDown()==进行清理，然后删除test fixture。注意：同一个test case 中的不同tests拥有不同的test fixture对象，并且googletest总是在创造下一个test fixture之前删除上一个。googletest不会对多个tests用相同test fixture。任何一个test对test fixture的改变不会影响到其他的。 作为一个例子，我们写一个tests，用于测试命名==Queue==的FIFO队列，接口如下：123456789template &lt;typename E&gt; // E is the element type.class Queue &#123; public: Queue(); void Enqueue(const E&amp; element); E* Dequeue(); // Returns NULL if the queue is empty. size_t size() const; ...&#125;; 首先，定义一个fixture类。按照惯例，对于名为==Foo==的被测类型，它的test fixture名应该是==FooTest==。1234567891011121314class QueueTest : public ::testing::Test &#123; protected: void SetUp() override &#123; q1_.Enqueue(1); q2_.Enqueue(2); q2_.Enqueue(3); &#125; // void TearDown() override &#123;&#125; Queue&lt;int&gt; q0_; Queue&lt;int&gt; q1_; Queue&lt;int&gt; q2_;&#125;; 本例中，不需要==TearDown()==，因为不必在每个test后进行清理，析构函数已经做了这些工作。现在，用==TEST_F()==写tests以及fixture。1234567891011121314151617181920TEST_F(QueueTest, IsEmptyInitially) &#123; EXPECT_EQ(q0_.size(), 0);&#125;TEST_F(QueueTest, DequeueWorks) &#123; int* n = q0_.Dequeue(); EXPECT_EQ(n, nullptr); n = q1_.Dequeue(); ASSERT_NE(n, nullptr); EXPECT_EQ(*n, 1); EXPECT_EQ(q1_.size(), 0); delete n; n = q2_.Dequeue(); ASSERT_NE(n, nullptr); EXPECT_EQ(*n, 2); EXPECT_EQ(q2_.size(), 1); delete n;&#125; 上面的程序用了==ASSERT_==和==EXPECT_==断言。使用的原则是：如果你想在断言失败后继续收到错误信息，就用==EXPECT_==；如果断言失败后继续执行已经没有意义，就用==ASSERT_==。例如，==Dequeue== test中的第二个断言是 =ASSERT_NE(nullptr, n)=, 我们之后应该废弃这个指针 ==n==，因为 ==n== 是 ==NULL== 会导致段错误。当这些tests运行，以下的事情会发生： googletest构造一个 ==QueueTest== 对象（我们叫它 ==t1== ）。 ==t1.SetUp()== 初始化 ==t1==。 第一个test（ ==IsEmptyInitially== ）在 ==t1== 上运行。 test结束后 ==t1.TearDown()== 清理垃圾。 ==t1== 析构。 在另外一个 ==QueueTest== 对象上重复以上过程，这次运行 ==DequeueWorks== test。 可用性：Linux, Windows, Mac。 触发Tests ==TEST()==和==TEST_F()==通过googletest隐式的注册它们的tests。所以，与很多其他的c++测试框架不同，你不必为了运行tests而去再列明这些已定义的tests。tests定义后，你可以通过 ==RUN_ALL_TESTS()== 运行它们，所有的tests都成功会返回 ==0==，否则是 ==1== 。注意 ==RUN_ALL_TESTS()== 运行所有在你的链接单元中的tests–它们可以来自不同的test cases，甚至不同的源文件。 一旦被触发， ==RUN_ALL_TESTS()== 宏： 保存所有googletest flags 的状态。 为第一个test创造一个test fixture。 通过 ==SetUp()== 初始化。 在fixture对象上运行test。 通过 ==TearDown()== 清理fixture。 删除fixture。 重新保存googletest flags的状态。 为下一个test重复以上过程，直到所有tests运行完。 如果致命失败发生，后续的步骤将被跳过。 重要：你不能忽略 ==RUN_ALL_TEST()== 的返回值，否则会得到一个编译错误。这样涉及的原则是：自动化测试服务决定一个test是否通过是基于它的退出码，而不是他的 stdout/stderr 输出；因此， ==main()== 函数必须返回 ==RUN_ALL_TESTS()== 的值。同时，你只能调用 ==RUN_ALL_TESTS()== 一次。多此调用会引发一个高级的googletest特性冲突（例如，线程安全death tests），所以这是不支持的。 可用性：Linux, Windows, Mac。 写主函数 写你的main()函数，它应该返回 ==RUN_ALL_TESTS()== 的值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include "this/package/foo.h"#include "gtest/gtest.h"namespace &#123;// The fixture for testing class Foo.class FooTest : public ::testing::Test &#123; protected: // You can remove any or all of the following functions if its body // is empty. FooTest() &#123; // You can do set-up work for each test here. &#125; ~FooTest() override &#123; // You can do clean-up work that doesn't throw exceptions here. &#125; // If the constructor and destructor are not enough for setting up // and cleaning up each test, you can define the following methods: void SetUp() override &#123; // Code here will be called immediately after the constructor (right // before each test). &#125; void TearDown() override &#123; // Code here will be called immediately after each test (right // before the destructor). &#125; // Objects declared here can be used by all tests in the test case for Foo.&#125;;// Tests that the Foo::Bar() method does Abc.TEST_F(FooTest, MethodBarDoesAbc) &#123; const std::string input_filepath = "this/package/testdata/myinputfile.dat"; const std::string output_filepath = "this/package/testdata/myoutputfile.dat"; Foo f; EXPECT_EQ(f.Bar(input_filepath, output_filepath), 0);&#125;// Tests that Foo does Xyz.TEST_F(FooTest, DoesXyz) &#123; // Exercises the Xyz feature of Foo.&#125;&#125; // namespaceint main(int argc, char **argv) &#123; ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS();&#125; ==::testing::InitGoogleTest()== 函数为googletest flags解析命令行参数，并且移除所有可识别的flags。这能让用户通过各种flags来控制test程序的行为，在AdvancedGuide中有详细介绍。调用 ==RUN_ALL_TESTS()== 之前必须调用它，否则flags不会被正确初始化。在Windows上， ==InitGoogleTest()== 也支持宽字符串，所以它也能在 ==UNICODE==模式下编译。也许你觉得编写所有这些主函数工作量太大了？我们完全同意，那也是为什么googletest提供了一个基本的main()实现。如果这符合你的需求，把你的test和gtest_main链接，你很适合这样去做。注意：==ParseGUnitFlags()== 已被弃用，更推荐用 ==InitGoogleTest()==。 需要知道的限制 Google Test被设计成线程安全的。在 ==pthreads==库可用的系统上，实现是线程安全的。当前在其他系统（比如 Windows）上在两个线程中并发使用Google Test断言是线程不安全的。在大部分tests中这不是问题，因为assertions总是在主线程中执行。如果你需要帮助，你可以针对你的平台，在 ==gtest-port.h== 中自愿实现这些必要的同步原语。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ 测试框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim常用命令]]></title>
    <url>%2FVim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vim的命令有很多，而且各种插件还有自己的命令，要都记下来显然不现实，也没有这个必要。但是记住一些常用的命令，可以极大的提高编辑的效率。这篇文章介绍一些常用命令，不涉及其他的插件。文中的内容参考了一些其他博客的内容，这里主要做下整理归类。 移动光标在Normal模式下，可以通过多种快捷键快速的移动光标。下面是四个最基本的移动命令： h，向左移动一个字符； l，向右移动一个字符； k，向上移动一个字符； j，向下移动一个字符； 以上四个命令可以配合数字使用，比如 5j 就是向下移动5行，5h 就是向左移动 5 个字符；（vim中很多命令都可以配合数字使用） 以下是一些快速的定位方式： H，跳转到当前可见区域的顶部第一个非空字符； M，跳转到当前可见区域的中间第一个非空字符； L，跳转到当前可见区域的最后第一个非空字符； w，向后移动一个单词(光标停在单词首部)，如果已在行尾，则转至下一行行首； e，向后移动一个单词(光标停在单词尾部)，如果已在行尾，则转至下一行行首； b，向前移动一个单词(光标停在单词首部)； ge，同b，光标停在单词尾部； number + gg，快速跳转到number行的开头； gg，跳转到文档的开头； G，跳转到文档的最后一行的开头； $，跳转到行尾；3$，跳转到下面3行的行尾； 0，跳转到行首(跳转到一行开始的第一个非空字符)； ^，跳转到一行的最开始，包括前面的空格； :number，跳转至第number行； %，按括号匹配移动光标。 以下是一些滚动页的命令： zz，让当前行居屏幕中间显示； zt，让当前行居屏幕顶部显示； zb，让当前行居屏幕低部显示； ctrl+e, 向下滚动一行 crtl+y, 向上滚动一行 ctrl+d, 向下滚动半屏 ctrl+u, 向上滚动半屏 ctrl+f, 向下滚动一屏 ctrl+b, 向上滚动一屏 插入从Normal 模式进入Insert 模式的几个命令： i，在当前位置前插入； I，在当前行首插入； a，在当前位置后插入； A，在当前行尾插入； o，在当前行之后插入一行； O，在当前行之前插入一行； 这些命令也可以和数字配合，如 2i 然后输入 aa ，再按 esc 回到Normal 模式，就能在当前位置插入4个 a。 查找在Normal模式下进行查找。 /text，查找text，按n向下查找下一个，按N向上查找上一个； ?text，查找text，反向查找，按n向下查找下一个，按N向上查找上一个； 也可以将光标定位到某个词上，然后按 # ，*** 进行查找。另外，vim也支持正则表达式的查找。 以下是一些关于显示结果的设置，可以在配置文件中默认配置，也可以在命令模式下临时配置。 :set ignorecase，忽略大小写的查找； :set noignorecase，不忽略大小写的查找； :set hlsearch，高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配； :set nohlsearch，关闭高亮搜索显示； :nohlsearch，关闭当前的高亮显示，如果再次搜索或按下 n 或 N 键，则会再次高亮； :set incsearch，逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成； :set wrapscan，重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启； 替换替换命令，同样在命令模式下进行。 r，用新输入的一个字符替换当前一个字符； R，从当前字符开始往后一个一个字符替换为新输入的字符； ddp, 交换光标所在行和其下紧邻的一行 :s/old/new/，在当前行中用 old 替换 new，替换第一个匹配到的；没提示 :s/old/new/c，在当前行中用 old 替换 new，替换第一个匹配到的；有提示 :s/old/new/g，在当前行中用 old 替换 new，替换当前行的所有匹配；没提示 :s/old/new/gc，在当前行中用 old 替换 new，替换当前行的所有匹配；有提示 :%s/old/new/g，全文将 old 替换为 new，不提示； :%s/old/new/c，全文将 old 替换为 new，提示是否替换； 删除删除主要用字母 x 和 c，配合光标移动和数字能组合出很多快捷的操作。 x，向后删除光标所在的一个字符； X，向前删除光标所在的一个字符； cc，删除当前一整行，并进入编辑模式； C，删除至行尾，并进入编辑模式； c0，删除至行首，回到一行的第一个字符，包括最前面的空白字符； c^，删除至行首，不会删除行首的空白字符； 拷贝、剪切与粘贴剪贴对应的字母 d ，拷贝对应字母 y，粘贴对应字母 p。这里的剪贴是把内容移动到了vim的缓存中，所以可以通过粘贴 p 对应的命令把它复制出来。 dd，剪贴当前行；5dd，删除当前行开始向下的5行； dj，剪贴当前行和下一行； dk，剪贴当前行和上一行； number + dd，向下剪贴number行； D，剪贴至行尾；等同于d$； d0，剪贴至行首；等同于d^； dw，剪贴光标所在处一个单词的后部分； dG，剪贴光标之后至文档结束； dgg，剪贴光标之前至文档开头； yy，拷贝当前行；nyy，拷贝当前后开始的n行；等同于Y； y^，复制到行首，不包括当前位置； y$，复制到行尾，包括当前位置； yG，复制到文档尾；ygg，复制到文档头； p，在当前光标后粘贴； P，在当前光标前粘贴；等同于shift + p； :n1,n2 co n3，将n1至n2行拷贝并粘贴到n3行之后； :1,$ co $，将整个文档拷贝一份并添加至文档尾部； 另外，在命令模式下，可以按下 v （逐字），V（逐行）以及 ctrl+v（块）进入不同的可视模式，然后用移动光标的命令选择区域，再进行复制。 其他 注释 ctrl + v 进入 visual block 模式； 接着按 j 或 k 选中要注释的行； 然后按 I， 输入注释符 (//)； 最后再按 esc 就会把刚才选中的行都注释掉了；去掉注释也是一样的，只是把输入变成删除就行了。 undo和redo分别是 u 和 r。 退出:w，保存；:wq, 保存并退出ZZ, 保存并退出:q!, 强制退出并忽略所有更改:e!, 放弃所有修改，并打开原来文件 缩进>&gt;，当前行增加缩进一个TAB；n&gt;&gt;，当前行开始的n行增加缩进一个TAB&lt;&lt;，当前行减少一个TAB；n&lt;&lt;，当前行开始的n行减少一个TAB]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法]]></title>
    <url>%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序在算法中的地位不言而喻，而且也是在面试中经常被问到的点。本文主要分析和比较几种常见的基于比较的排序算法。通常，分析排序算法会从比较次数、交换次数、时间负责度、空间复杂度、最坏情况下的复杂度以及适用场景几个方面去考虑，所以本文也基于这样分析，并用Java进行了简单的实现，且仅考虑了升序的情况，代码只测试了几个简单的用例，如有不对的地方，还请指正。 选择排序很直观的一种排序，扫描一次数组，确定一个最小值，让它与未排序部分的第一个值交换，然后从刚才交换的值的下一个位置扫描。当扫描了N次以后数组也就有序了。 由于想法和实现都很简单，它的性能也只能是N^2的： 比较次数：N^2/2 交换次数：N 时间复杂度：N*N 空间复杂度：原地的，不需额外空间 最坏情况下时间复杂度：和输入无关 稳定性：不稳定 选择排序每次确定了一个元素的位置，但是每次循环得到的比较结果都没有被下一次利用，所以效率比较低，在实际中应该应用不多。 1234567891011121314public static void selectionSort(Comparable[] arr) &#123; for(int i=0;i&lt;arr.length;i++) &#123; int min=i; for(int j=i;j&lt;arr.length;j++) &#123; if(arr[j].compareTo(arr[min])&lt;0) &#123; min=j; &#125; &#125; Comparable tmp=arr[i]; arr[i]=arr[min]; arr[min]=tmp; &#125; return;&#125; 插入排序插入排序的想法也很简单，假设当前元素之前的所有元素都已经有序（一个元素的时候就是有序的），那么用当前元素去和之前的元素一一比较，当当前元素比前一个元素小，就交换它们的位置。 插入排序理论上的复杂度和选择排序是一样的，但是它与输入是有关系的，当输入是部分有序的时候，它能达到线性级别的效率。它的性能： 比较次数：平均 N×N/4，最坏 N×N/2，最好 N-1 交换次数：平均 N×N/4，最坏 N×N/2，最好 0 时间复杂度：N*N 空间复杂度：原地的，不需额外空间 最坏情况下时间复杂度：N*N 稳定性：稳定 插入排序在应对小数组和部分有序的数组时，能得到很好的性能，优于其他的算法，所以它适用于非随机的小数组，并且很多高级的排序算法在递归到小数组时通常用它来替换，能有效提高算法性能。 123456789101112public static void insertionSort(Comparable[] arr) &#123; for(int i=1;i&lt;arr.length;i++) &#123; Comparable key=arr[i]; int j=i-1; while(j&gt;=0 &amp;&amp; arr[j].compareTo(key)&gt;0) &#123; arr[j+1]=arr[j]; j--; &#125; arr[j+1]=key; &#125; return;&#125; 希尔排序希尔排序是对插入排序的优化，考虑到插入排序在部分有序和小数组情况下的优秀性能，将数组分成H组，每组的元素都是数组中间隔为H的元素，分别对每组元素进行插入排序，然后再将H减小，再进行插入排序，直到H等于1。 希尔排序的复杂度没有具体的证明，在平方级与线性对数级之间。希尔排序简单高效，一个小小的改动让算法脱离了平方级别，效率远高于插入排序，而且数组越大优势越大。算法的效率与选择的H递增序列有关。性能： 比较次数： 交换次数： 时间复杂度：N e(3/2) 空间复杂度：原地的，不需额外空间 最坏情况下时间复杂度： 稳定性：不稳定 希尔排序在应对中等大小的数值时很有效。 123456789101112131415public static void shellSort(Comparable[] arr) &#123; int len=arr.length; for(int h=len/2;h&gt;=1;h/=2) &#123; for(int i=h;i&lt;len;i++) &#123; Comparable key=arr[i]; int j=i-h; while(j&gt;=0 &amp;&amp; arr[j].compareTo(key)&gt;0) &#123; arr[j+h]=arr[j]; j-=h; &#125; arr[j+h]=key; &#125; &#125; return;&#125; 归并排序归并排序是分治思想的体现，将数组划分成两部分，分别排序，然后再合并两个有序数组（当一个元素时，自然是有序的），递归的进行，就能然整个数组有序。归并排序能让算法的复杂度稳定在 NlgN。 归并排序通过二分的方式，能在算法时间复杂度达到 NlgN，而且它与输入没有关系，但是归并需要利用额外的空间，所以空间复杂度是 N。 比较次数：1/2NlgN ~ NlgN 交换次数： 时间复杂度：NlgN 空间复杂度：N 最坏情况下时间复杂度： 稳定性：稳定 在空间不紧张，而且要求稳定的情况下，归并排序是一个好的选择。 归并排序通常的写法是递归的，但是也可以用非递归的方式来写。 12345678910111213141516171819202122232425262728293031public static void mergeSort(Comparable[] arr) &#123; mergeSortHelper(arr, 0, arr.length);&#125;private static void merge(Comparable[] arr, int l, int mid, int r) &#123; Comparable[] tmp = new Comparable[arr.length]; for(int k=l;k=r;k++) &#123; tmp[k]=arr[k]; &#125; int i=l,j=mid+1; for(int k=l;k&lt;=r;k++) &#123; if(i&gt;mid) arr[k]=tmp[j++]; else if(j&gt;r) arr[k]=tmp[i++]; else if(tmp[i].compareTo(tmp[j])&lt;0) arr[k]=tmp[i++]; else arr[k]=tmp[j++]; &#125;&#125;private static void mergeSortHelper(Comparable[] arr, int l, int r) &#123; if(l==r) return; int mid=(l+r)/2; mergeSortHelper(arr, l, mid); mergeSortHelper(arr, mid+1, r); merge(arr, l, mid, r);&#125;public static void mergeSort2(Comparable[] arr) &#123; int len=arr.length; for(int sz=1;sz&lt;len;sz*=2) &#123; for(int j=0;j&lt;len-sz;j+=sz*2) &#123; merge(arr, j, j+sz-1,Math.min(j+sz+sz-1, len-1)); &#125; &#125;&#125; 快速排序快速排序每次递归选择一个元素作为key，然后将数组中小于key的元素放左边，大于key的元素放右边。以key为分界点将数组分成两部分，再分别对两个子数组进行同样的操作。 快速排序在大多数应用下是最快的排序算法，它的负责度是NlgN，但是常数因子比别的同级别的算法小，因为他的内循环很简单，只是访问一遍数组，而且是顺序的访问数组，能有效利用缓存。但是在最坏的情况下，也就是每次的Key选择都是最大或最小的元素，快排就会变成冒泡排序，每次只能确定一个值。性能： 比较次数： 交换次数： 时间复杂度：NlgN 空间复杂度：lgN 最坏情况下时间复杂度：N^2 稳定性：不稳定 快排的应用很广泛，由于它在大多数情况下都比别的算法快，内循环简单，比较次数少。快排的性能取决于切分元素的选择，最好的情况是每次都把数组均分成两半，最坏情况是每次都选到了最大或最小的元素，此时退化成冒泡排序，每次只能确定一个值的位置。快拍的时间复杂度是 nlgn 且常数比其他同级别的算法小，空间复杂度 lgn （调用函数栈的开销），最坏情况下也就是冒泡排序的复杂度，分别是 n^2, n。通常会在排序前打乱所有数据，使待排序数据随机分布。 1234567891011121314151617private static void quickSort(Comparable[] arr, int start, int end) &#123; if(start&gt;=end) return; int i=start,j=end+1; Comparable key=arr[i]; while(true) &#123; while(j&gt;i &amp;&amp; arr[--j].compareTo(key)&gt;=0); if(i&gt;=j) break; arr[i]=arr[j]; while(i&lt;j &amp;&amp; arr[++i].compareTo(key)&lt;0); if(i&gt;=j) break; arr[j]=arr[i]; &#125; arr[i]=key; quickSort(arr, start, i-1); quickSort(arr, i+1, end);&#125; 当数组中有大量重复元素时，可以对快排进行优化，避免对相同元素的排序，从而将时间复杂度降到线性级别，该算法称为三向切分快速排序。 123456789101112131415161718192021222324public static void quickSort_3way(Comparable[] arr, int left, int right) &#123; if(left&gt;=right) return; int l=left, r=right, i=left+1; Comparable key=arr[left]; while(i&lt;r) &#123; int com=arr[i].compareTo(key); if(com&lt;0) &#123; Comparable tmp=arr[l]; arr[l]=arr[i]; arr[i]=tmp; i++; l++; &#125; else if(com&gt;0) &#123; Comparable tmp=arr[r]; arr[r]=arr[i]; arr[i]=tmp; r--; &#125; else &#123; i++; &#125; &#125; quickSort_3way(arr, left, l-1); quickSort_3way(arr, r+1, right);&#125; 堆排序堆通常指二叉堆，有大堆和小堆。用数组表示，数组元素之间的关系可以按照顺序排成一棵完全二叉树。在大堆中，以任意节点为根节点的子树，它的根节点是最大的节点；小堆相反。若索引从0开始表示，那么 k 的两个子节点分别是 2×k+1 和 2×k+2 ，k 的父节点是 (k-1)/2。大堆的最大元素在堆顶，用堆顶元素与最末元素交换，前移一位最末元素的指针，同时使堆重新有序，直到末元素指针指到堆顶。注意建堆的时候是从第一个非叶节点开始对节点下沉。 利用了堆的性质，使算法的复杂度达到了 NlgN ，同时空间复杂度是 1。 比较次数：少于（2NlgN+2N） 交换次数：NlgN+N 时间复杂度：NlgN 空间复杂度：1 最坏情况下时间复杂度：2NlgN 稳定性：不稳定 堆排序不能利用缓存，速度也不如快排，所以很少使用。但是在对内存要求很高的环境，如嵌入式系统中，堆排序是一个好的选择。虽然堆排序的应用不多，但是用堆实现的优先队列很重要，它能在对数级别实现插入和删除。 1234567891011121314151617181920212223242526272829303132public static void heapSort(Comparable[] arr) &#123; heap_build(arr); int k=arr.length-1; while(k&gt;0) &#123; Comparable tmp=arr[k]; arr[k]=arr[0]; arr[0]=tmp; k--; heap_sink(arr, 0, k); &#125;&#125;private static void heap_build(Comparable[] arr) &#123; int k = arr.length-1; for(int i=(k-1)/2;i&gt;=0;i--) &#123; if(arr[i].compareTo(arr[2*i+1]) &gt; 0 || (2*i+1&lt;=k &amp;&amp; arr[i].compareTo(arr[2*i+2])&gt;0)) heap_sink(arr, i, arr.length-1); &#125;&#125;private static void heap_sink(Comparable[] arr, int k, int len) &#123; if(k&gt;len/2-1 || k&lt;0) return ; while(k&lt;=len/2-1) &#123; int c=2*k+1; if(c+1 &lt; len &amp;&amp; arr[c].compareTo(arr[c+1])&lt;0) c++; if(arr[c].compareTo(arr[k])&gt;0) &#123; Comparable tmp=arr[c]; arr[c]=arr[k]; arr[k]=tmp; k=c; &#125; else &#123; break; &#125; &#125;&#125; 总结几种常见的排序算法都介绍完了，这里简单的总结一下： 在所有排序算法中，应用最广泛的是快速排序。 快排，归并、堆排都是 NlgN 级别的，但是快排的内循环最简单，只是顺序的访问数组，且比较次数和交换次数都少。在大部分应用场景下，快排都是最快的，但是他的性能和选择的分隔元素有关。归并排序和输入无关，总能保证nlgn的效率，但是它的空间复杂度是 O（N），同时，它是稳定的排序。堆排序应用的不多，除非是在对内存要求很高的环境下，因为它的空间复杂度是1。 在数组比较小的情况下，优先选择插入排序或选择排序。因为算法简单，不需要递归调用，在小数组时比nlng的算法快。插入排序和输入有关，在小数组，部分有序的情况下，能达到线性级别，所以很多大数组排序的优化都是递归到小数组以后用插入排序。 希尔排序是插入排序的改进。通过将数组分成k组，每组的元素间间隔是k，对k组元素分别进行插入排序，然后减小间隔直到1。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些优秀的博客链接]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E4%BC%98%E7%A7%80%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[说明这篇文章主要是放一些自己觉得写得比较好的博客链接，整理在这里，方便自己需要或是有空的时候来阅读。文中的内容会不断更新。 链接CoolShell CoolShell 作者是一位行业大牛，博客的内容没有过多关注具体的某方面技术或是一些技术细节，更多的是从比较高的层次写一些行业内的动态和发展以及新技术，内容涉及的面很广。 罗道文的私房菜 罗道文的私房菜 看得出博主的技术也很强，关注的方向主要是后端开发、存储系统，主要使用的语言是C++，而且博主的内容更新得很快。 始终 始终 博主的文章有技术方向的，也有一些英语学习的。 Jey Zhang Jey Zhang 博主的文章主要是机器学习方向 ZeeCoder ZeeCoder 博主的文章主要是计算机方面的基础比较多。 Jark’s Blog Jark’s Blog 博主的文章关注于分布式系统以及一些计算机基础。 文中对各个博客简单的描述只是为了方便整理和阅读，如有说得不对的地方，还请海涵。]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[站点的搭建过程用两天时间完成了这个blog的搭建，现在勉强能看得过去了，当然还有一些问题，以后有时间再慢慢丰富完善。在用Hexo搭建自己的blog的过程中，参考了许多别人写的教程和博客，主要有博客（博主的文章也很不错），Next的文档，Hexo的文档。其实文档官方的文档写得挺好的，照着文档的步骤基本上就能把blog搭起来，问题主要在应用一些第三方插件来丰富站点比较麻烦。网上已经有很多利用Hexo搭建blog的教程了，没必要过多重复赘述，这里主要叙述一下我遇到的问题。完成blog的基本功能后，在本地测试通过，然后在github上建立一个对应的仓库存放站点。在阿里云上买了一个域名，将其解析到自己的github下的blog，这里主要是要做一个实名验证，并且要把域名和对应的ip绑定，可以通过ping自己的github站点看到ip。添加搜索功能。官方文档推荐用swiftype，但是我在注册的时候出现了一些问题，就选择了最简单的local search，感觉也还不错。添加评论区。这个我选择了disqus，按照文档和别人博客的步骤设置。看到disqus网页上的内容还是很多的，有时间可以研究一下。统计访问量。阅读次数统计使用的是LeanCloud，这个好像是给web应用和app提供服务的，功能很多，这里只用到了统计访问量。提供搜索引擎检索。按照文档中的步骤添加了百度和谷歌的检索，但是好像没有奏效，目前不知道问题出在哪，过段时间好好看一下。 初识Markdown博客的书写建议采用markdown，在此之前在下也没有接触过markdown，算是一个小白。markdonw的语法还有比较简单的，看这文档和一些入门教程多写几次应该就可以应付一般的博客排版了。这里有一些还错的资源： 文档：http://wowubuntu.com/markdown/ 博客：http://www.jianshu.com/p/1e402922ee32/ 博客：http://www.jianshu.com/p/q81RER 有道云笔记文档：http://note.youdao.com/iyoudao/?p=2411 写博客的动机很久以前就想过要写博客，因为平时自己也会看一些技术博客。但由于自己水平很差，同时看到很多博客页面让我感觉不是很好，就一直没写。直到发现了用Hexo来搭建博客，被页面简洁清爽无广告的视觉体验吸引，而且站点可以放在github上，拥有自己的域名，不依赖于其他的平台，就想用它来搭建自己的博客。由于自己平时也看一些大牛的博客，而且遇到问题经常google到一些很好的博客，受益很大，所以也决定开始写博客。一方面能总结自己在学习过程中遇到的问题与收获，作为一个记录;另一方面，自己踩过的坑和笔记若能对需要的人有一些帮助，那也算一份功德。而且写博客的过程中，也能促进自己去思考和总结，何乐而不为。博主非计算机专业，但对这方面比较感兴趣，可惜水平不高。博客的内容可能大都是与技术相关，可能也会也其他的一些。写博客也是为了督促自己不断学习和进步，同时提高自己的书面表达能力。曾经有老师对我说过：一样东西，你能把别人讲懂了，你自己才是真的懂了。所以博主会力求认真写好每一篇博客，为了让自己懂，也为别人懂。 这是在下的第一个博客站点，也是第一篇博客，所以有些激动，以后还要多多学习，写出好的博客，也希望看到的朋友不吝指点。]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
</search>
