<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[epoll的运行机制]]></title>
    <url>%2Fepoll%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[epoll原理epoll是Linux系统下一个高效的多路复用IO机制。Linux下，一切皆文件。epoll可对大部分IO操作，以下以socket为例，对epoll机制进行简单解释。用户进程所有的IO都由操作系统统一管理，所有的IO对象（socket，通道，文件等）在内核都对应一个文件描述符，用户只能操作文件描述符，由内核去和具体的IO设备打交道。linux有三个系统调用来操作epoll1int epoll_create(int size); 这个函数创建一个epoll文件，返回对应的文件描述符，入参没什么用，为了向后兼容，大于0就好。通过这个函数，会在内核中开辟有段高速缓存空间，保存需要监听的socket，以及一个就绪list。123456789101112typedef union epoll_data &#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; __uint32_t events; epoll_data_t data;&#125;;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这个函数修改fd在epoll中的状态，将这个fd插入/删除/修改到红黑树中，并向内核中断处理程序注册一个回调，当这个fd有事件发生，就向list中插入这个fd。epfd为之前创建的epoll文件描述符，op为注册的操作，fd为需要监听的文件描述符，event为需要监听的事件。op有三个选择： EPOLL_CTL_ADD 添加fd为监听的文件 EPOLL_CTL_MOD 修改fd的监听事件 EPOLL_CTL_DEL 不在监听fd event-&gt;events有7中选择，可通过位或选择多个选项： EPOLLIN fd可读 EPOLLOUT fd可写 EPOLLPRI 有紧急数据可读 EPOLLERR fd发生错误 EPOLLHUP fd被挂断 EPOLLET 将EPOLL 设为ET模式 EPOLLONESHOT 这个fd只监听一次，一次之后将它从监听中删除 event-&gt;data 联合体。设置fd为要监听的对象或设置ptr为要写的数据，其他用法不清楚。 1int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout); 这个函数会启动epoll监听，线程会在这阻塞，直到有被监听的事件发生，函数会检查list中是否有元素，如有，就将所有元素copy到events,并清空list。epfd为epoll的fd, events为为存储返回的所有发生的事件，maxevents为events的大小，timeout为超时限制。返回值为返回的event的个数。timeout为-1表示永久等待，0表示立即返回。 一个服务端监听socket的例子1234567891011121314151617181920212223242526272829for( ; ; )&#123; nfds = epoll_wait(epfd,events,20,500); for(i=0;i&lt;nfds;++i)&#123; if(events[i].data.fd==listenfd)&#123; //如果是主socket的事件，则表示有新的连接 connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); //accept这个连接 ev.data.fd=connfd; ev.events=EPOLLIN|EPOLLET; epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); //将新的fd添加到epoll的监听队列中 &#125; else if( events[i].events&amp;EPOLLIN )&#123; //接收到数据，读socket if ( (sockfd = events[i].data.fd) &lt; 0) continue; n = read(sockfd, line, MAXLINE)) &lt; 0 //读 ev.data.ptr = md; //md为自定义类型，添加数据 ev.events=EPOLLOUT|EPOLLET; epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);//修改标识符，等待下一个循环时发送数据，异步处理的精髓 &#125; else if(events[i].events&amp;EPOLLOUT)&#123; //有数据待发送，写socket struct myepoll_data* md = (myepoll_data*)events[i].data.ptr; //取数据 sockfd = md-&gt;fd; send( sockfd, md-&gt;ptr, strlen((char*)md-&gt;ptr), 0 ); //发送数据 ev.data.fd=sockfd; ev.events=EPOLLIN|EPOLLET; epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); //修改标识符，等待下一个循环时接收数据 &#125; else&#123; //其他情况的处理 &#125; &#125;&#125; 一个监听管道的例子读管道端：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int fifo_fd1, fifo_fd2; int ep_fd; struct epoll_event event; struct epoll_event *ret_events = NULL; int cnt; int i; char c; mkfifo(&quot;./fifo1&quot;, 0666); mkfifo(&quot;./fifo2&quot;, 0666); fifo_fd1 = open(&quot;./fifo1&quot;, O_RDONLY); fifo_fd2 = open(&quot;./fifo2&quot;, O_RDONLY); /* 需要有进程以只写的方式打开fifo1、fifo2后才能执行于此 */ printf(&quot;监测fifo1和fifo2中...\n&quot;); /* 创建epoll池 */ ep_fd = epoll_create1(0); /* 将检测事件加入epoll池中 */ event.events = EPOLLIN | EPOLLET; /* 监测fifo1可读，且以边沿方式触发 */ event.data.fd = fifo_fd1; epoll_ctl(ep_fd, EPOLL_CTL_ADD, fifo_fd1, &amp;event); event.events = EPOLLIN | EPOLLET; /* 监测fifo2可读，且以边沿方式触发 */ event.data.fd = fifo_fd2; epoll_ctl(ep_fd, EPOLL_CTL_ADD, fifo_fd2, &amp;event); /* ret_events用于存放被触发的事件 */ ret_events = malloc(sizeof(struct epoll_event) * 100); /* 阻塞等待监测事件触发 */ cnt = epoll_wait(ep_fd, ret_events, 100, -1); printf(&quot;cnt = %d\n&quot;, cnt); /* 判断监测事件 */ for (i = 0; i &lt; cnt; i++) &#123; if (ret_events[i].events &amp; EPOLLIN) &#123; read(ret_events[i].data.fd, &amp;c, 1); printf(&quot;fd = %d, recv data = %c\n&quot;, ret_events[i].data.fd, c); &#125; &#125; free(ret_events); close(ep_fd); /* 注意关闭epoll池的描述符 */ close(fifo_fd2); close(fifo_fd1); return 0;&#125; 写管道1：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int fd; char c; fd = open(&quot;./fifo1&quot;, O_WRONLY); printf(&quot;w1: pls input char: \n&quot;); scanf(&quot;%c&quot;, &amp;c); write(fd, &amp;c, 1); close(fd); return 0;&#125; 写管道2：1234567891011121314int main(void)&#123; int fd; char c; fd = open(&quot;./fifo2&quot;, O_WRONLY); printf(&quot;w2: pls input char: \n&quot;); scanf(&quot;%c&quot;, &amp;c); write(fd, &amp;c, 1); close(fd); return 0;&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊keystore文件解析]]></title>
    <url>%2F%E4%BB%A5%E5%A4%AA%E5%9D%8Akeystore%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[通过以太坊客户端（geth或mist）生成以太坊账户，会在“~/.ethereum/keystore下产生对应于账户的文件，该文件保存了账户相关的信息，如私钥和地址。” 参考https://medium.com/@julien.maffre/what-is-an-ethereum-keystore-file-86c8c5917b97 文件名文件名形式: UTC–&lt;created_date_time&gt;–&lt;地址&gt;如：UTC–2018-07-23T02-30-23.717223803Z–1062024529684b1890b2fa5964334d8db7da2512 文件结构{ &quot;address&quot;:&quot;1062024529684b1890b2fa5964334d8db7da2512&quot; &quot;crypto&quot; : { &quot;cipher&quot; : &quot;aes-128-ctr&quot;, &quot;cipherparams&quot; : { &quot;iv&quot; : &quot;83dbcc02d8ccb40e466191a123791e0e&quot; }, &quot;ciphertext&quot; : &quot;d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c&quot;, &quot;kdf&quot; : &quot;scrypt&quot;, &quot;kdfparams&quot; : { &quot;dklen&quot; : 32, &quot;n&quot; : 262144, &quot;r&quot; : 1, &quot;p&quot; : 8, &quot;salt&quot; : &quot;ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19&quot; }, &quot;mac&quot; : &quot;2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097&quot; }, &quot;id&quot; : &quot;3198bc9c-6672-5ab3-d995-4942343ae5b6&quot;, &quot;version&quot; : 3 } 由用户输入的通行证得到派生keyKey Derivation Function，用户输入的passphrase通过key derivation function得到decryption key, 密钥生成密钥是由客户端产生的，不受用户的控制，keystore中保存的”ciphertext”字段是密钥的密文，密文由密钥通过”cipher”指定的算法和decryption key生成，其中参数是”cipherparams”。 mac的作用以上说的是生成密钥密文的过程。当用户需要得到密钥的时候，通过同样步骤得到decryption key，然后取decryption的一部分和ciphertxt连接，再hash，将结果与mac对比，相同则代表用户输入的通行证是对的。之后再用decryption与ciphertext通过cipher算法解密出私钥明文（对称加密）。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim常用命令]]></title>
    <url>%2FVim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vim的命令有很多，而且各种插件还有自己的命令，要都记下来显然不现实，也没有这个必要。但是记住一些常用的命令，可以极大的提高编辑的效率。这篇文章介绍一些常用命令，不涉及其他的插件。文中的内容参考了一些其他博客的内容，这里主要做下整理归类。 移动光标在Normal模式下，可以通过多种快捷键快速的移动光标。下面是四个最基本的移动命令： h，向左移动一个字符； l，向右移动一个字符； k，向上移动一个字符； j，向下移动一个字符； 以上四个命令可以配合数字使用，比如 5j 就是向下移动5行，5h 就是向左移动 5 个字符；（vim中很多命令都可以配合数字使用） 以下是一些快速的定位方式： H，跳转到当前可见区域的顶部第一个非空字符； M，跳转到当前可见区域的中间第一个非空字符； L，跳转到当前可见区域的最后第一个非空字符； w，向后移动一个单词(光标停在单词首部)，如果已在行尾，则转至下一行行首； e，向后移动一个单词(光标停在单词尾部)，如果已在行尾，则转至下一行行首； b，向前移动一个单词(光标停在单词首部)； ge，同b，光标停在单词尾部； number + gg，快速跳转到number行的开头； gg，跳转到文档的开头； G，跳转到文档的最后一行的开头； $，跳转到行尾；3$，跳转到下面3行的行尾； 0，跳转到行首(跳转到一行开始的第一个非空字符)； ^，跳转到一行的最开始，包括前面的空格； :number，跳转至第number行； %，按括号匹配移动光标。 以下是一些滚动页的命令： zz，让当前行居屏幕中间显示； zt，让当前行居屏幕顶部显示； zb，让当前行居屏幕低部显示； ctrl+e, 向下滚动一行 crtl+y, 向上滚动一行 ctrl+d, 向下滚动半屏 ctrl+u, 向上滚动半屏 ctrl+f, 向下滚动一屏 ctrl+b, 向上滚动一屏 插入从Normal 模式进入Insert 模式的几个命令： i，在当前位置前插入； I，在当前行首插入； a，在当前位置后插入； A，在当前行尾插入； o，在当前行之后插入一行； O，在当前行之前插入一行； 这些命令也可以和数字配合，如 2i 然后输入 aa ，再按 esc 回到Normal 模式，就能在当前位置插入4个 a。 查找在Normal模式下进行查找。 /text，查找text，按n向下查找下一个，按N向上查找上一个； ?text，查找text，反向查找，按n向下查找下一个，按N向上查找上一个； 也可以将光标定位到某个词上，然后按 # ，*** 进行查找。另外，vim也支持正则表达式的查找。 以下是一些关于显示结果的设置，可以在配置文件中默认配置，也可以在命令模式下临时配置。 :set ignorecase，忽略大小写的查找； :set noignorecase，不忽略大小写的查找； :set hlsearch，高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配； :set nohlsearch，关闭高亮搜索显示； :nohlsearch，关闭当前的高亮显示，如果再次搜索或按下 n 或 N 键，则会再次高亮； :set incsearch，逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成； :set wrapscan，重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启； 替换替换命令，同样在命令模式下进行。 r，用新输入的一个字符替换当前一个字符； R，从当前字符开始往后一个一个字符替换为新输入的字符； ddp, 交换光标所在行和其下紧邻的一行 :s/old/new/，在当前行中用 old 替换 new，替换第一个匹配到的；没提示 :s/old/new/c，在当前行中用 old 替换 new，替换第一个匹配到的；有提示 :s/old/new/g，在当前行中用 old 替换 new，替换当前行的所有匹配；没提示 :s/old/new/gc，在当前行中用 old 替换 new，替换当前行的所有匹配；有提示 :%s/old/new/g，全文将 old 替换为 new，不提示； :%s/old/new/c，全文将 old 替换为 new，提示是否替换； 删除删除主要用字母 x 和 c，配合光标移动和数字能组合出很多快捷的操作。 x，向后删除光标所在的一个字符； X，向前删除光标所在的一个字符； cc，删除当前一整行，并进入编辑模式； C，删除至行尾，并进入编辑模式； c0，删除至行首，回到一行的第一个字符，包括最前面的空白字符； c^，删除至行首，不会删除行首的空白字符； 拷贝、剪切与粘贴剪贴对应的字母 d ，拷贝对应字母 y，粘贴对应字母 p。这里的剪贴是把内容移动到了vim的缓存中，所以可以通过粘贴 p 对应的命令把它复制出来。 dd，剪贴当前行；5dd，删除当前行开始向下的5行； dj，剪贴当前行和下一行； dk，剪贴当前行和上一行； number + dd，向下剪贴number行； D，剪贴至行尾；等同于d$； d0，剪贴至行首；等同于d^； dw，剪贴光标所在处一个单词的后部分； dG，剪贴光标之后至文档结束； dgg，剪贴光标之前至文档开头； yy，拷贝当前行；nyy，拷贝当前后开始的n行；等同于Y； y^，复制到行首，不包括当前位置； y$，复制到行尾，包括当前位置； yG，复制到文档尾；ygg，复制到文档头； p，在当前光标后粘贴； P，在当前光标前粘贴；等同于shift + p； :n1,n2 co n3，将n1至n2行拷贝并粘贴到n3行之后； :1,$ co $，将整个文档拷贝一份并添加至文档尾部； 另外，在命令模式下，可以按下 v （逐字），V（逐行）以及 ctrl+v（块）进入不同的可视模式，然后用移动光标的命令选择区域，再进行复制。 其他 注释 ctrl + v 进入 visual block 模式； 接着按 j 或 k 选中要注释的行； 然后按 I， 输入注释符 (//)； 最后再按 esc 就会把刚才选中的行都注释掉了；去掉注释也是一样的，只是把输入变成删除就行了。 undo和redo分别是 u 和 r。 退出:w，保存；:wq, 保存并退出ZZ, 保存并退出:q!, 强制退出并忽略所有更改:e!, 放弃所有修改，并打开原来文件 缩进>&gt;，当前行增加缩进一个TAB；n&gt;&gt;，当前行开始的n行增加缩进一个TAB&lt;&lt;，当前行减少一个TAB；n&lt;&lt;，当前行开始的n行减少一个TAB]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法]]></title>
    <url>%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序在算法中的地位不言而喻，而且也是在面试中经常被问到的点。本文主要分析和比较几种常见的基于比较的排序算法。通常，分析排序算法会从比较次数、交换次数、时间负责度、空间复杂度、最坏情况下的复杂度以及适用场景几个方面去考虑，所以本文也基于这样分析，并用Java进行了简单的实现，且仅考虑了升序的情况，代码只测试了几个简单的用例，如有不对的地方，还请指正。 选择排序很直观的一种排序，扫描一次数组，确定一个最小值，让它与未排序部分的第一个值交换，然后从刚才交换的值的下一个位置扫描。当扫描了N次以后数组也就有序了。 由于想法和实现都很简单，它的性能也只能是N^2的： 比较次数：N^2/2 交换次数：N 时间复杂度：N*N 空间复杂度：原地的，不需额外空间 最坏情况下时间复杂度：和输入无关 稳定性：不稳定 选择排序每次确定了一个元素的位置，但是每次循环得到的比较结果都没有被下一次利用，所以效率比较低，在实际中应该应用不多。 1234567891011121314public static void selectionSort(Comparable[] arr) &#123; for(int i=0;i&lt;arr.length;i++) &#123; int min=i; for(int j=i;j&lt;arr.length;j++) &#123; if(arr[j].compareTo(arr[min])&lt;0) &#123; min=j; &#125; &#125; Comparable tmp=arr[i]; arr[i]=arr[min]; arr[min]=tmp; &#125; return;&#125; 插入排序插入排序的想法也很简单，假设当前元素之前的所有元素都已经有序（一个元素的时候就是有序的），那么用当前元素去和之前的元素一一比较，当当前元素比前一个元素小，就交换它们的位置。 插入排序理论上的复杂度和选择排序是一样的，但是它与输入是有关系的，当输入是部分有序的时候，它能达到线性级别的效率。它的性能： 比较次数：平均 N×N/4，最坏 N×N/2，最好 N-1 交换次数：平均 N×N/4，最坏 N×N/2，最好 0 时间复杂度：N*N 空间复杂度：原地的，不需额外空间 最坏情况下时间复杂度：N*N 稳定性：稳定 插入排序在应对小数组和部分有序的数组时，能得到很好的性能，优于其他的算法，所以它适用于非随机的小数组，并且很多高级的排序算法在递归到小数组时通常用它来替换，能有效提高算法性能。 123456789101112public static void insertionSort(Comparable[] arr) &#123; for(int i=1;i&lt;arr.length;i++) &#123; Comparable key=arr[i]; int j=i-1; while(j&gt;=0 &amp;&amp; arr[j].compareTo(key)&gt;0) &#123; arr[j+1]=arr[j]; j--; &#125; arr[j+1]=key; &#125; return;&#125; 希尔排序希尔排序是对插入排序的优化，考虑到插入排序在部分有序和小数组情况下的优秀性能，将数组分成H组，每组的元素都是数组中间隔为H的元素，分别对每组元素进行插入排序，然后再将H减小，再进行插入排序，直到H等于1。 希尔排序的复杂度没有具体的证明，在平方级与线性对数级之间。希尔排序简单高效，一个小小的改动让算法脱离了平方级别，效率远高于插入排序，而且数组越大优势越大。算法的效率与选择的H递增序列有关。性能： 比较次数： 交换次数： 时间复杂度：N e(3/2) 空间复杂度：原地的，不需额外空间 最坏情况下时间复杂度： 稳定性：不稳定 希尔排序在应对中等大小的数值时很有效。 123456789101112131415public static void shellSort(Comparable[] arr) &#123; int len=arr.length; for(int h=len/2;h&gt;=1;h/=2) &#123; for(int i=h;i&lt;len;i++) &#123; Comparable key=arr[i]; int j=i-h; while(j&gt;=0 &amp;&amp; arr[j].compareTo(key)&gt;0) &#123; arr[j+h]=arr[j]; j-=h; &#125; arr[j+h]=key; &#125; &#125; return;&#125; 归并排序归并排序是分治思想的体现，将数组划分成两部分，分别排序，然后再合并两个有序数组（当一个元素时，自然是有序的），递归的进行，就能然整个数组有序。归并排序能让算法的复杂度稳定在 NlgN。 归并排序通过二分的方式，能在算法时间复杂度达到 NlgN，而且它与输入没有关系，但是归并需要利用额外的空间，所以空间复杂度是 N。 比较次数：1/2NlgN ~ NlgN 交换次数： 时间复杂度：NlgN 空间复杂度：N 最坏情况下时间复杂度： 稳定性：稳定 在空间不紧张，而且要求稳定的情况下，归并排序是一个好的选择。 归并排序通常的写法是递归的，但是也可以用非递归的方式来写。 12345678910111213141516171819202122232425262728293031public static void mergeSort(Comparable[] arr) &#123; mergeSortHelper(arr, 0, arr.length);&#125;private static void merge(Comparable[] arr, int l, int mid, int r) &#123; Comparable[] tmp = new Comparable[arr.length]; for(int k=l;k=r;k++) &#123; tmp[k]=arr[k]; &#125; int i=l,j=mid+1; for(int k=l;k&lt;=r;k++) &#123; if(i&gt;mid) arr[k]=tmp[j++]; else if(j&gt;r) arr[k]=tmp[i++]; else if(tmp[i].compareTo(tmp[j])&lt;0) arr[k]=tmp[i++]; else arr[k]=tmp[j++]; &#125;&#125;private static void mergeSortHelper(Comparable[] arr, int l, int r) &#123; if(l==r) return; int mid=(l+r)/2; mergeSortHelper(arr, l, mid); mergeSortHelper(arr, mid+1, r); merge(arr, l, mid, r);&#125;public static void mergeSort2(Comparable[] arr) &#123; int len=arr.length; for(int sz=1;sz&lt;len;sz*=2) &#123; for(int j=0;j&lt;len-sz;j+=sz*2) &#123; merge(arr, j, j+sz-1,Math.min(j+sz+sz-1, len-1)); &#125; &#125;&#125; 快速排序快速排序每次递归选择一个元素作为key，然后将数组中小于key的元素放左边，大于key的元素放右边。以key为分界点将数组分成两部分，再分别对两个子数组进行同样的操作。 快速排序在大多数应用下是最快的排序算法，它的负责度是NlgN，但是常数因子比别的同级别的算法小，因为他的内循环很简单，只是访问一遍数组，而且是顺序的访问数组，能有效利用缓存。但是在最坏的情况下，也就是每次的Key选择都是最大或最小的元素，快排就会变成冒泡排序，每次只能确定一个值。性能： 比较次数： 交换次数： 时间复杂度：NlgN 空间复杂度：lgN 最坏情况下时间复杂度：N^2 稳定性：不稳定 快排的应用很广泛，由于它在大多数情况下都比别的算法快，内循环简单，比较次数少。快排的性能取决于切分元素的选择，最好的情况是每次都把数组均分成两半，最坏情况是每次都选到了最大或最小的元素，此时退化成冒泡排序，每次只能确定一个值的位置。快拍的时间复杂度是 nlgn 且常数比其他同级别的算法小，空间复杂度 lgn （调用函数栈的开销），最坏情况下也就是冒泡排序的复杂度，分别是 n^2, n。通常会在排序前打乱所有数据，使待排序数据随机分布。 1234567891011121314151617private static void quickSort(Comparable[] arr, int start, int end) &#123; if(start&gt;=end) return; int i=start,j=end+1; Comparable key=arr[i]; while(true) &#123; while(j&gt;i &amp;&amp; arr[--j].compareTo(key)&gt;=0); if(i&gt;=j) break; arr[i]=arr[j]; while(i&lt;j &amp;&amp; arr[++i].compareTo(key)&lt;0); if(i&gt;=j) break; arr[j]=arr[i]; &#125; arr[i]=key; quickSort(arr, start, i-1); quickSort(arr, i+1, end);&#125; 当数组中有大量重复元素时，可以对快排进行优化，避免对相同元素的排序，从而将时间复杂度降到线性级别，该算法称为三向切分快速排序。 123456789101112131415161718192021222324public static void quickSort_3way(Comparable[] arr, int left, int right) &#123; if(left&gt;=right) return; int l=left, r=right, i=left+1; Comparable key=arr[left]; while(i&lt;r) &#123; int com=arr[i].compareTo(key); if(com&lt;0) &#123; Comparable tmp=arr[l]; arr[l]=arr[i]; arr[i]=tmp; i++; l++; &#125; else if(com&gt;0) &#123; Comparable tmp=arr[r]; arr[r]=arr[i]; arr[i]=tmp; r--; &#125; else &#123; i++; &#125; &#125; quickSort_3way(arr, left, l-1); quickSort_3way(arr, r+1, right);&#125; 堆排序堆通常指二叉堆，有大堆和小堆。用数组表示，数组元素之间的关系可以按照顺序排成一棵完全二叉树。在大堆中，以任意节点为根节点的子树，它的根节点是最大的节点；小堆相反。若索引从0开始表示，那么 k 的两个子节点分别是 2×k+1 和 2×k+2 ，k 的父节点是 (k-1)/2。大堆的最大元素在堆顶，用堆顶元素与最末元素交换，前移一位最末元素的指针，同时使堆重新有序，直到末元素指针指到堆顶。注意建堆的时候是从第一个非叶节点开始对节点下沉。 利用了堆的性质，使算法的复杂度达到了 NlgN ，同时空间复杂度是 1。 比较次数：少于（2NlgN+2N） 交换次数：NlgN+N 时间复杂度：NlgN 空间复杂度：1 最坏情况下时间复杂度：2NlgN 稳定性：不稳定 堆排序不能利用缓存，速度也不如快排，所以很少使用。但是在对内存要求很高的环境，如嵌入式系统中，堆排序是一个好的选择。虽然堆排序的应用不多，但是用堆实现的优先队列很重要，它能在对数级别实现插入和删除。 1234567891011121314151617181920212223242526272829303132public static void heapSort(Comparable[] arr) &#123; heap_build(arr); int k=arr.length-1; while(k&gt;0) &#123; Comparable tmp=arr[k]; arr[k]=arr[0]; arr[0]=tmp; k--; heap_sink(arr, 0, k); &#125;&#125;private static void heap_build(Comparable[] arr) &#123; int k = arr.length-1; for(int i=(k-1)/2;i&gt;=0;i--) &#123; if(arr[i].compareTo(arr[2*i+1]) &gt; 0 || (2*i+1&lt;=k &amp;&amp; arr[i].compareTo(arr[2*i+2])&gt;0)) heap_sink(arr, i, arr.length-1); &#125;&#125;private static void heap_sink(Comparable[] arr, int k, int len) &#123; if(k&gt;len/2-1 || k&lt;0) return ; while(k&lt;=len/2-1) &#123; int c=2*k+1; if(c+1 &lt; len &amp;&amp; arr[c].compareTo(arr[c+1])&lt;0) c++; if(arr[c].compareTo(arr[k])&gt;0) &#123; Comparable tmp=arr[c]; arr[c]=arr[k]; arr[k]=tmp; k=c; &#125; else &#123; break; &#125; &#125;&#125; 总结几种常见的排序算法都介绍完了，这里简单的总结一下： 在所有排序算法中，应用最广泛的是快速排序。 快排，归并、堆排都是 NlgN 级别的，但是快排的内循环最简单，只是顺序的访问数组，且比较次数和交换次数都少。在大部分应用场景下，快排都是最快的，但是他的性能和选择的分隔元素有关。归并排序和输入无关，总能保证nlgn的效率，但是它的空间复杂度是 O（N），同时，它是稳定的排序。堆排序应用的不多，除非是在对内存要求很高的环境下，因为它的空间复杂度是1。 在数组比较小的情况下，优先选择插入排序或选择排序。因为算法简单，不需要递归调用，在小数组时比nlng的算法快。插入排序和输入有关，在小数组，部分有序的情况下，能达到线性级别，所以很多大数组排序的优化都是递归到小数组以后用插入排序。 希尔排序是插入排序的改进。通过将数组分成k组，每组的元素间间隔是k，对k组元素分别进行插入排序，然后减小间隔直到1。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些优秀的博客链接]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E4%BC%98%E7%A7%80%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[说明这篇文章主要是放一些自己觉得写得比较好的博客链接，整理在这里，方便自己需要或是有空的时候来阅读。文中的内容会不断更新。 链接CoolShell CoolShell 作者是一位行业大牛，博客的内容没有过多关注具体的某方面技术或是一些技术细节，更多的是从比较高的层次写一些行业内的动态和发展以及新技术，内容涉及的面很广。 罗道文的私房菜 罗道文的私房菜 看得出博主的技术也很强，关注的方向主要是后端开发、存储系统，主要使用的语言是C++，而且博主的内容更新得很快。 始终 始终 博主的文章有技术方向的，也有一些英语学习的。 Jey Zhang Jey Zhang 博主的文章主要是机器学习方向 ZeeCoder ZeeCoder 博主的文章主要是计算机方面的基础比较多。 Jark’s Blog Jark’s Blog 博主的文章关注于分布式系统以及一些计算机基础。 文中对各个博客简单的描述只是为了方便整理和阅读，如有说得不对的地方，还请海涵。]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[站点的搭建过程用两天时间完成了这个blog的搭建，现在勉强能看得过去了，当然还有一些问题，以后有时间再慢慢丰富完善。在用Hexo搭建自己的blog的过程中，参考了许多别人写的教程和博客，主要有博客（博主的文章也很不错），Next的文档，Hexo的文档。其实文档官方的文档写得挺好的，照着文档的步骤基本上就能把blog搭起来，问题主要在应用一些第三方插件来丰富站点比较麻烦。网上已经有很多利用Hexo搭建blog的教程了，没必要过多重复赘述，这里主要叙述一下我遇到的问题。完成blog的基本功能后，在本地测试通过，然后在github上建立一个对应的仓库存放站点。在阿里云上买了一个域名，将其解析到自己的github下的blog，这里主要是要做一个实名验证，并且要把域名和对应的ip绑定，可以通过ping自己的github站点看到ip。添加搜索功能。官方文档推荐用swiftype，但是我在注册的时候出现了一些问题，就选择了最简单的local search，感觉也还不错。添加评论区。这个我选择了disqus，按照文档和别人博客的步骤设置。看到disqus网页上的内容还是很多的，有时间可以研究一下。统计访问量。阅读次数统计使用的是LeanCloud，这个好像是给web应用和app提供服务的，功能很多，这里只用到了统计访问量。提供搜索引擎检索。按照文档中的步骤添加了百度和谷歌的检索，但是好像没有奏效，目前不知道问题出在哪，过段时间好好看一下。 初识Markdown博客的书写建议采用markdown，在此之前在下也没有接触过markdown，算是一个小白。markdonw的语法还有比较简单的，看这文档和一些入门教程多写几次应该就可以应付一般的博客排版了。这里有一些还错的资源： 文档：http://wowubuntu.com/markdown/ 博客：http://www.jianshu.com/p/1e402922ee32/ 博客：http://www.jianshu.com/p/q81RER 有道云笔记文档：http://note.youdao.com/iyoudao/?p=2411 写博客的动机很久以前就想过要写博客，因为平时自己也会看一些技术博客。但由于自己水平很差，同时看到很多博客页面让我感觉不是很好，就一直没写。直到发现了用Hexo来搭建博客，被页面简洁清爽无广告的视觉体验吸引，而且站点可以放在github上，拥有自己的域名，不依赖于其他的平台，就想用它来搭建自己的博客。由于自己平时也看一些大牛的博客，而且遇到问题经常google到一些很好的博客，受益很大，所以也决定开始写博客。一方面能总结自己在学习过程中遇到的问题与收获，作为一个记录;另一方面，自己踩过的坑和笔记若能对需要的人有一些帮助，那也算一份功德。而且写博客的过程中，也能促进自己去思考和总结，何乐而不为。博主非计算机专业，但对这方面比较感兴趣，可惜水平不高。博客的内容可能大都是与技术相关，可能也会也其他的一些。写博客也是为了督促自己不断学习和进步，同时提高自己的书面表达能力。曾经有老师对我说过：一样东西，你能把别人讲懂了，你自己才是真的懂了。所以博主会力求认真写好每一篇博客，为了让自己懂，也为别人懂。 这是在下的第一个博客站点，也是第一篇博客，所以有些激动，以后还要多多学习，写出好的博客，也希望看到的朋友不吝指点。]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
</search>
