<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[C++11引入了Lambda表达式，也称作匿名函数，本文讨论下lambda表达式的用法和原理。 什么是Lambda表达式先看一个最简单的lambda表达式： 12auto f = []()&#123; std::cout &lt;&lt; "hello lambda\n"; &#125;;f(); 以上代码定义了一个lambda表达式f，它是一个可调用对象，可简单理解为一个函数，没有入参，没有返回值，唯一的功能就是打印 hello lambda，紧接着就像调用函数一样调用它，打印信息。 我们看到，定义一个lambda表达式就是定义一个可调用对象，就像仿函数或者函数指针一样，但是它的类型是不确定的，通常就用auto来表示，而且一般也不需要明确知道它的类型，当然，如果要明确写出，也可以像函数指针的类型或者std::function的定义类型那样写出来。 那么，lambda表达式有什么用呢，对写代码有什么提升呢？假设这样的场景，我们写一段逻辑时，临时需要写一个函数，这个函数功能很简单，就两三行，而且就只在当前环境使用。以前的做法是定义一个函数，然后在当前环境调用它。那有了lambda表达式，就不需要这样做了，因为lambda表达式自身就是一个表达式，我们可以在代码的任意地方像定义一个整型变量一样定义它，所以可以直接在需要使用的地方把定义出这个匿名函数。这可能在我们平常的代码中优势不是很明显，但是在标准库的使用上却提供了极大的便利性。因为标准库大量使用了仿函数，比如标准库的排序算法，如果我们要排序的对象没有默认的比较大小的实现，就需要调用者自己实现一个比较大小的仿函数。有了lambda表达式，我们就可以将lambda表达式作为参数传递给标准库的算法。 基本语法lambda表达式的完整形式如下： [capture list] (params list) mutable exception -&gt; return type { function body } 其中： parmas list 是函数的形参列表； exception 是函数抛出的异常； return type 是函数返回值； function body 是函数的具体内容； capture list 和 mutable 后面的内容再描述。 其中 mutable exception 和 return type都是可以省略的，当者三者都省略时，params list 也可以省略。 原理分析这里说原理分析可能也不太准确，因为我也没有看过具体的实现，只能给出它的等效实现。 假如我们有如下代码： 123int x = 5;auto f = [x](int y) mutable -&gt; bool &#123; bool result = x == y; cout &lt;&lt; x++; return result; &#125;;bool result = f(4); 以上代码没什么实际意义，存粹突然瞎写的。 这里lambda表达式中的[] 中的x表示捕获，捕获有值捕获和引用捕获两种形式，如果捕获的内容写为&amp;x就是按引用捕获，没有&amp;就是按值捕获。mutable就是针对值捕获的，如果写了这个关键字，就表示值捕获的内容在函数体里面是可以修改的，否则就不能修改。上面的代码，如果没写mutable就会编译报错，原因就是在函数体内对x进行了自增操作。如果是按引用捕获，默认就是可以修改的，不需要写mutable。上面的代码返回值类型也可以不写，编译器自己会推导出return语句的值就是返回值类型。 通过一个等效的实现可能更好理解一些。上面代码的lambda表达式等效于： 1234567891011class LambdaFunc &#123;public: LambdaFunc(int xx) : x(xx) &#123;&#125; bool operator()(int y) &#123; bool result = x == y; cout &lt;&lt; x++; return result; &#125;private: int x;&#125; 如果lambda表达式没有写mutable，就相当于LambdaFunc的成员变量声明为const。 对于以下语句： 1auto f = [x](int y) mutable -&gt; bool &#123; bool result = x == y; cout &lt;&lt; x++; return result; &#125;; 相当于编译器创建了一个LambdaFunc临时对象，并且赋值给变量f。 如果我们把这个表达式稍微改动一下，变成这样： 1auto f = [&amp;x](int y) -&gt; bool &#123; bool result = x == y; cout &lt;&lt; x++; return result; &#125;; 相当于： 1234567891011class LambdaFunc &#123;public: LambdaFunc(int&amp; xx) : x(xx) &#123;&#125; bool operator()(int y) &#123; bool result = x == y; cout &lt;&lt; x++; return result; &#125;private: int&amp; x;&#125; 关于捕获，还有以下几种形式： [=] 表示捕获lambda表达式作用域范围内的所有变量，且都是值捕获； [&amp;] 表示捕获lambda表达式作用域范围内的所有变量，且都是引用捕获； [=,&amp;x] 表示捕获lambda表达式作用域范围内的所有变量，只有x是引用捕获，其余都是值捕获； [&amp;,=x] 表示捕获lambda表达式作用域范围内的所有变量，只有x是值捕获，其余都是引用捕获。 应用于标准库假设有如下代码： 12auto cmp = [](int x, int y)&#123;return x &lt; y; &#125;;std::set&lt;int, decltype(cmp)&gt; myset; 这段代码会报出编译错误，错误信息显示lambda表达式是没有默认构造函数的。因为myset在构造时会构造一个类型为decltype(cmp)的比较器，而它时没有默认构造函数的。同时lambda表达式也没有赋值运算符，意味着不能将一个类型为lambda表达式的变量赋值给另一个变量。 以上代码正确的写法应该是： 12auto cmp = [](int x, int y)&#123;return x &lt; y; &#125;;std::set&lt;int, decltype(cmp)&gt; myset(cpm);]]></content>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式定义了一种一对多的依赖关系，多个对象订阅同一个对象。当被订阅者的状态发生改变时，所有订阅者都能收到消息，并做出各自具体的响应。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Listener &#123;public: virtual void OnReceived(std::string msg) = 0;&#125;;class Subject &#123;public: void RigistryListener(Listener* listener) &#123; listeners_.push_back(listener); &#125; void RemoveListener(Listener* list) &#123; listeners_.remove_if([list](Listener* l) &#123; return l == list; &#125;); &#125; void Notify() &#123; std::for_each(listeners_.begin(), listeners_.end(), [this](Listener* l) &#123; l-&gt;OnReceived(status_); &#125;); &#125; void SetStatus(std::string s) &#123; status_ = s; Notify(); &#125;private: std::list&lt;Listener*&gt; listeners_; std::string status_;&#125;;class ListenerA : public Listener &#123;public: virtual void OnReceived(std::string msg) override &#123; printf("ListenerA Subject status changed: %s\n", msg.c_str()); &#125;&#125;;class ListenerB : public Listener &#123;public: virtual void OnReceived(std::string msg) override &#123; printf("ListenerB Subject status changed: %s\n", msg.c_str()); &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++11可变参数模板]]></title>
    <url>%2FC%2B%2B11%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[C++11在C++98的基础上增加了很多新特性，可变参数模板（Variadic Templates）就是其中之一，而且是非常重要的一个特性。用可变参数模板可以实现很多骚操作，很大程度增加了语言的灵活性。C++11提供的新容器tuple就是基于可变参数模板实现。 所谓可变参数模板，就是我们在写模板类或者模板函数时，申明的模板参数的个数是不确定的。在C++11之前，已经能够实现可变参数的函数，比如常用的格式化输出函数printf等，但是模板却一定是固定的个数。我们知道可变参数的函数能给函数带来很大的灵活性，而可变参数的模板更是为开发者开辟了新世界。 由于模板参数的数量未知，在模板函数或者类的实现中就不能按常规的方式一个个获取各个类型参数。那如何才能提取出所有的模板参数？这时候，递归又派上用场了。 以下以几个示例来说明如何使用可变参数模板，内容都是参考侯捷老师介绍C++11新特性的课程。 实现可变参数的打印函数12345678template&lt;typename T&gt;void Print(const T&amp; last) &#123; std::cout &lt;&lt; last &lt;&lt; std::endl; &#125;template&lt;typename T, typename... Types&gt;void Print(const T&amp; first, const Types&amp;... args) &#123; std::cout &lt;&lt; first &lt;&lt; std::endl; Print(args...);&#125; 以上代码就是实现了可变参数的打印函数，每次调用Print时，将一包参数的第一个打印出来，然后再调用Print，将其余的参数作为入参传入。 在模板参数申明的地方，typename… 表示一包模板参数，在函数定义的地方，Types…表示一包类型，在函数体内，args…表示一包参数变量。最开始看的时候可能不太习惯这种写法，多看几次代码就熟悉这种写法了。 实现哈希函数12345678910111213141516171819202122template&lt;typename T&gt;inline void MyHashInner(size_t&amp; seed, const T&amp; val) &#123; seed ^= std::hash&lt;T&gt;()(val) + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);&#125;template&lt;typename T&gt;inline void MyHash(size_t&amp; seed, const T&amp; val) &#123; MyHashInner(seed, val);&#125;template&lt;typename T, typename... Types&gt;inline void MyHash(size_t&amp; seed, const T&amp; val, const Types&amp;... args) &#123; MyHashInner(seed, val); MyHash(seed, args...);&#125;template&lt;typename... Types&gt;inline size_t MyHash(const Types&amp;... args) &#123; size_t seed = 0; MyHash(seed, args...); return seed;&#125; 以上代码实现了一个hash函数，能够传入多个参数，算出一个hash值。 这里有两个需要注意的问题： 特化的版本一定要放在泛化的版本的前面。由于编译时编译器会选择最符合当前调用的版本，所以如果在当前位置之前没有特化的版本，就只能用泛化的版本。比如上面的代码，如果将最后一个MyHash放在最开始的位置，那么编译时会找不到其他的特化版本，每次递归调用MyHash时，都是调用自己，因为这个版本的参数可以接收任意参数，而且每次调用自己，都会在参数包里面增加一个size_t类型的数据，导致无限递归下去且参数无限长。其实这和我们平时写代码时，一定要将函数声明写到调用之前是一个道理。 std::hash无法应用于原生的字符串，比如“abcd”这样字面的常量，如果是字符串，只能应用于std::string这样的类型，因为std::hash无法提供类似char[N]这样的类型的特化版本。 Tuple实现 。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++11新特性列表]]></title>
    <url>%2FC%2B%2B11%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[C++11修改了对C头文件的引用方式，和引用C++头文件一样不带后缀。例如原来的 #include &lt;stdio.h&gt; 改为 #include 。原来的引用方式在C++11代码中也能使用。 Variadic Templates – 可变参数模板]]></content>
  </entry>
  <entry>
    <title><![CDATA[IDEA给项目打jar包]]></title>
    <url>%2FIDEA%E7%BB%99%E9%A1%B9%E7%9B%AE%E6%89%93jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[将Java项目打成jar应该是Java开发中常见的需求，像gradle、maven这些工具都有打包的功能，这里记录下如何用IDEA来打jar包，不借助项目管理工具。 首先，这是一个简单的Java项目，没有框架。 点击 File-&gt;Project Structure，选中Artifacts。 点击 + ，选中Jar -&gt; from modules with dependencies。 如果有Main Class 就选中，然后OK。 选中 Include in project build，然后选中 Apply OK。 经过以上步骤，配置就完成了。 最后在工具栏点击 Build，就会在工程目录下生成jar]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java调用C++共享库]]></title>
    <url>%2FJava%E8%B0%83%E7%94%A8C%2B%2B%E5%85%B1%E4%BA%AB%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在实际项目开发中，有时会遇到需要在Java中去调用C++实现的功能的场景。本文介绍一种实现方式。 总体思路Java调用C++有多种方式，其中之一是利用Java的jna包去调用C++的共享库。实现需要以下几步： 将C++暴露的接口编译为共享库，并将*.so文件置于系统能找到的地址 在Java项目中引入jna jar包，地址为https://mvnrepository.com/artifact/net.java.dev.jna/jna/ 在Java项目中load共享库，并定义和C++相同的接口。 一个示例以下通过一个简单的例子描述实现的过程。 首先，用C++实现两个简单的函数： 12345678910#include &lt;iostream&gt;extern "C" &#123; int add(int a, int b) &#123; return a + b; &#125; void print(char* str) &#123; std::cout &lt;&lt; str &lt;&lt; std::endl; &#125;&#125; 此处，C++代码最好采用C的规则编译，用C++的规则会导致符号表发生一些变化，导致Java无法调用。当然，解决的办法也有，但是比较麻烦，还是不推荐使用。 通过g++将刚才写的源代码编译为共享库 libjnatest.so： 1g++ -fPIC -shared -o libjnatest.so jnatest.cpp 至此，C++这一侧的工作就完成了，接下来是Java。 在Java代码中要引入jna包，并且定义出和C++中暴露的接口一致的接口，关于数据类型的映射关系在后文中给出： 123456789101112import com.sun.jna.Library;import com.sun.jna.Native;public interface JnaTest extends Library &#123; public static final String JNA_ImgProcess = "jnatest"; public static final JnaTest instance = (JnaTest)Native.loadLibrary(JnaTest.JNA_ImgProcess,JnaTest.class); int add(int a, int b); void print(String str);&#125; 最后，在Java中使用以上的接口： 12345678public class Main &#123; public static void main(String[] args) &#123; JnaTest instance = JnaTest.instance; int result = instance.add(3,6); instance.print("abcd"); System.out.println(result); &#125;&#125; 运行的时候需要将共享库jnatest.so置于系统的环境变量下，让系统能够搜索到这个库。 Java与C++的数据类型映射关系 Native Type Size Java Type char 8-bit integer byte short 16-bit integer short wchar_t 16/32-bit character char int 32-bit integer int bool boolean value boolean long 32/64-bit integer NativeLong long long 64-bit integer long float 32-bit FP float double 64-bit FP double char* C string String void* pointer Pointer 参考https://www.cnblogs.com/bigben0123/articles/11084523.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++自定义类型的转换函数]]></title>
    <url>%2FC%2B%2B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[operator关键字C++中的关键字operator有两种用法，其中用于运算符重载应该是最为大家所熟知的，另一种用法就是用作类的转换函数，这篇文件就记录一下第二种用法。 通常我们在编程的时候会做一些类型转换，就像下面这样：12double a = 2.22;int b = int(a); 其实除了内置的类型能够进行转换，自己定义的类也能实现类型转换。 operator作类的转换函数直接看一个例子：1234567891011121314151617181920212223class A &#123;public: A(int i) &#123; i_ = i; &#125; operator int() const &#123; std::cout &lt;&lt; "HHH" &lt;&lt; std::endl; return i_; &#125; private: int i_;&#125;;int main(int argc, char** argv) &#123; A a(5); int aa = int(a); std::cout &lt;&lt; a &lt;&lt; std::endl; system("pause"); return 0;&#125; 上面的例子就定义了一个类，类中再定义了它自己的一个转换函数，转换成int 类型，用法很简单，看代码应该就很明白。 关键点用operator作转换函数需要注意几点： 转换函数必须是类方法； 转换函数没有返回值； 转换函数没有参数。 当然转换函数并不是能转换成任意类型，这些类型必须都是内置的类型。 在某些情况下，C++会出现隐式的转换，比如说对于上面的类，有如下代码：12A a(10);std::cout &lt;&lt; a &lt;&lt; std::endl; 我们没有重载&lt;&lt;，编译器就会隐式将a转换成int类型，然后输出。如果不希望出现隐式转换，可以在转换函数前加上explicit：1234explicit operator int() const &#123; std::cout &lt;&lt; "HHH" &lt;&lt; std::endl; return i_;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++自定义命令行参数]]></title>
    <url>%2FC%2B%2B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[经常在Linux环境下开发，通常都是通过命令行和系统交互。Linux提供了很多命令行工具，大部分工具都有很多选项，比如常用的ls，查看help就会看到很多选项。那这些选项是如何实现的？其实我们自己开发的程序也可以提供这样的选项。在Linux中，系统提供了一些函数，可以使用getopt、getopt_long、getopt_long_only来实现程序参数解析的功能。 以下这篇文章写得挺详细的：https://blog.csdn.net/cashey1991/article/details/7942809。 感觉自己写，也最多就是照着抄一遍了，所以就mark在这，自己需要用的时候可以随时找到。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux共享库的输出符号表]]></title>
    <url>%2FLinux%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E8%BE%93%E5%87%BA%E7%AC%A6%E5%8F%B7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[我们在看很多第三方库的源码时，会发现这些库的实现代码，都会在对外暴露的接口前面加上一个宏，类似这种形式：123Q_EXPORT class A &#123; ... &#125;; 这就是在指定class A是暴露出来的接口。接下来介绍具体如何定义。 通过gcc编译共享库时，默认所有的类和函数是全局可见的，也就是代码种所有的类和函数都会生成符号表，别人再用的时候能链接到所有的类和函数。 gcc有一个编译选项 -fvisibility=hidden，他的作用是隐藏所有的类和函数，配合着宏定义使用，能实现暴露指定的接口。 通常的用法是这样： 在代码中进行如下定义，定义了一个宏Q_EXPORT： 123#if !defined(Q_EXPORT)#define Q_EXPORT __attribute__((visibility("default")))#endif 在需要暴露的接口前面加上这个宏： 123Q_EXPORT class A &#123; ... &#125;; 在编译选项中再加入 -fvisibility=hidden 通过以上三步，代码中有Q_EXPORT宏的地方就是对外暴露的（default就是public），其余地方就被隐藏。其原理就是通过编译选项-fvisibility=hidden指定所有接口都隐藏，但是代码中有attribute((visibility(“default”)))的地方单独暴露出来。 以上是Linux下的处理方式，Windows平台的宏定义是另外一种方式，所有通常跨平台的代码要先判断平台，再根据不同平台定义Q_EXPORT. 有一个工具 nm 可以查看共享库暴露的符号表。 参考：https://blog.csdn.net/ld11690/article/details/81227480]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux动态库编译及使用]]></title>
    <url>%2FLinux%E5%8A%A8%E6%80%81%E5%BA%93%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[生成动态库生成动态库的命令和和生成可执行文件大致相同，区别在于加两个编译选项： -fPIC 作用于编译阶段，告诉编译器生成位置无关代码；产生的代码中没有绝对地址，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置。 -shared 生成动态链接库的选项此外，指定输出共享库名称的方式：-o lib{name}.so。 假如有三个源文件 a.cpp b.cpp c.cpp，需要生成一个动态库mylib。 可通过以下命令生成动态库：1gcc a.cpp b.cpp c.cpp -fPIC -shared -o libmylib.so 其他的一些编译选项需要额外指定。 库路径linux默认一般有两个库路径：/lib 和 /usr/lib 若要添加第三方的库路径，有两种方法： 将库复制到以上两个路径 修改 /etc/ld.so.conf 文件，将第三方库路径添加进去，然后运行ldconfig命令，把路径添加进 /etc/ld.so.cache 文件 编译时指定库路径如果是第三方库，且没有将其添加进 ld.so.conf 文件，可在编译时采取临时办法，在编译选项中添加路径。 示例：1gcc main.cpp -L. -lmylib 其中 -L 指定链接库路径， -l指定链接库名称。编译是默认优先选择动态库，若要链接静态库，添加 -static 编译选项。 运行时指定路径如果是第三方库，且没有将其添加进 ld.so.conf 文件，在运行时，可将其临时添加进环境变量。1export LD_LIBRARY_PATH = &#123;your_lib_path&#125;:$LD_LIBRARY_PATH 两个有用的命令file 查看文件类型ldd 打印目标程序所链接的所有动态库信息 pkg-config的使用假如自己开发了一个库mylib，那么会提供给别人头文件和库文件，用户使用的时候会在编译选项中将mylib的头文件和库添加进去。若只有一个库文件还好，若有多个库文件，写起来特别麻烦。 pkg-config就是为解决这个问题而生的一个工具。当我们提供给用户库和头文件时，同时提供一个mylib.pc文件，这个文件中记录了库的所有编译相关信息。用户只需要运行 pkg-config mylib -libs -cflags 就可以将相关的编译信息打印出来。 通常情况下，安装一个第三方库都会有一个安装脚本，直接将库文件和头文件以及 .pc文件安装到系统路径中，.pc文件中保存的路径信息就是安装时的信息。 pkg-cofnig 命令会到 /usr/lib路径下去查找所有 *.pc文件，或者到PKG_CONFIG_PATH环境变量指定的路径下查找。 参考：https://www.cnblogs.com/rainsoul/p/10567390.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[C-C++常用函数]]></title>
    <url>%2FC-C%2B%2B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[比较两个字符串12#include &lt;cstring&gt;extern int strcmp(const char *s1,const char *s2); strcmp函数是string compare(字符串比较)的缩写，用于比较两个字符串并根据比较结果返回整数。基本形式为strcmp(str1,str2)，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。比较方式：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇’\0’为止。 比较两个字符串的前n个字符12#include &lt;cstring&gt;int strncmp(const char *str1, const char *str2, size_t n) strncmp函数为字符串比较函数，字符串大小的比较是以ASCII 码表上的顺序来决定，此顺序亦为字符的值。其函数声明为int strncmp ( const char str1, const char str2, size_t n );功能是把 str1 和 str2 进行比较，最多比较前 n 个字节，若str1与str2的前n个字符相同，则返回0；若s1大于s2，则返回大于0的值；若s1 小于s2，则返回小于0的值。 查找字符串中的字符12#include &lt;string.h&gt;char *strchr(const char *str, int c) strchr函数功能为在一个串中查找给定字符的第一个匹配之处。函数原型为：char strchr(const char str, int c)，即在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。strchr函数包含在C 标准库 &lt;string.h&gt;中。]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++ Json库对比]]></title>
    <url>%2FC%2B%2BJson%E5%BA%93%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[最近在开发一个程序时遇到性能瓶颈，经过排查后发现整个程序耗时最多的一段处理逻辑是对Json对象的序列化。我在代码中使用了Jsoncpp库，通过网上资料看了关于Jsoncpp的介绍，其特点是接口设计得比较好，应用比较多，但是性能方面并不突出。为了解决问题，我决定换一个性能高的库，所以对比分析了几个常见的开源库。 C++ Json库测评github有一个关于C++ Json库的测评 – https://github.com/miloyip/nativejson-benchmark，该项目比较了40多个库的性能。 rapidjson这个库的设计目标就是追求性能极致，性能确实相较其他库高很多，但是缺点是接口设计不友好。rapidjson为了追求高性能，在设计上尽量减少内存复制，大量使用指针和浅复制，所以很多接口的用法都不太符合常规。实际使用种可以自己再封装一层接口，用起来会更顺手。 https://github.com/Tencent/rapidjson/ nlohmann-json这个库好像就叫json for modern c++，使用c++11实现。官方文档已经说明，它不是为了追求性能而设计的，其目的是使得在c++里面操作json尽可能的自然，就像在python等语言里面操作json一样。它的接口易用，只要会用std::vector和std::map就能用这个库。 https://github.com/nlohmann/json jsoncpp这个库的接口比较好用，如果在程序只是用于处理配置文件等对性能没要求的场景，可以考虑使用这个库。 cjson一个用c实现的json库，效率也比较高，但是使用起来要用c的那一套方法，最好的方式也是自己再封装一下。 总结在开发过程中，如果对处理json的性能要求不高，或者使用不频繁，不是程序的瓶颈所在，比如配置文件解析这类场景，可以使用接口是设计较为友好的库，比如jsoncpp、nlohmann-json等；如果对性能要求很高，就可以考虑rapidjson这类库了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux下统计代码行数]]></title>
    <url>%2Flinux%E4%B8%8B%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[wc工具wc是Linux的一个统计工具，可以统计文件的行数、词数和字节数。 1234567Usage: wc [OPTION]... [FILE]... -c, --bytes, --chars print the byte counts -l, --lines print the newline counts -L, --max-line-length print the length of the longest line -w, --words print the word counts --help display this help and exit --version output version information and exit 代码行数统计当前目录下的c++文件数量 1find . -name "*.cpp" -o -name "*.h" | wc -l 当前目录下的c++代码行数 1find . -name "*.cpp" -o -name "*.h" | xargs cat | wc -l 当前目录下的c++代码行数，除去空白行和注释行 1find . -name "*.cpp" -o -name "*.h" | xargs cat | grep -Ev "^\s+$" | grep -Ev "^\s*//" | wc -l 正则元字符备注 ^ 匹配头 $ 匹配尾 \s 所有的空白符，包括空格、制表符、回车换行 + 匹配前面的子表达式一次或多次 * 匹配前面的子表达式零次或多次 . 匹配任意单个字符]]></content>
  </entry>
  <entry>
    <title><![CDATA[一种接口定义方法]]></title>
    <url>%2F%E4%B8%80%E7%A7%8D%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前段时间开发项目用到了librdkafka库，学习了其中的部分源码。感觉代码中的接口设计方式挺好的，简单做个笔记，加深印象，以后可以模仿使用。 接口部分：12345678class A &#123;public: static A* Create() &#123; return new AImpl; &#125; virtual void Function1() = 0; virtual void Function2() = 0;&#125; 实现部分12345678class AImpl : public A &#123; virtual void Function1() &#123; ; &#125; virtual void Function2() &#123; ; &#125;&#125; 这样写可以将具体的实现部分隐藏起来，仅向用户暴露接口。这好像也是工厂模式，在Create中传入不同参数，获取不同的实现对象。]]></content>
  </entry>
  <entry>
    <title><![CDATA[leveldb cmakelist注解]]></title>
    <url>%2Fleveldb_cmakelist%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近学习使用CMake，看了一些文章感觉还是不会，索性就拿一个开源代码的CMakeList.txt来看，直接学习其写法。 CMakeList.txt示例以下是leveldb的CMakeList.txt，其中##部分是我加入的注释，这个CMakeList.txt基本涵盖了CMake的基本功能，看懂以后在自己的项目中也基本会用 了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531# Copyright 2017 The LevelDB Authors. All rights reserved.# Use of this source code is governed by a BSD-style license that can be# found in the LICENSE file. See the AUTHORS file for names of contributors.cmake_minimum_required(VERSION 3.9)# Keep the version below in sync with the one in db.hproject(leveldb VERSION 1.21.0 LANGUAGES C CXX)# This project can use C11, but will gracefully decay down to C89.## Similar to CXX_STANDARDset(CMAKE_C_STANDARD 11)set(CMAKE_C_STANDARD_REQUIRED OFF)set(CMAKE_C_EXTENSIONS OFF)# This project requires C++11.## The C++ standard whose features are requested to build this target.## ## This property specifies the C++ standard whose features are requested to build this target. For## some compilers, this results in adding a flag such as -std=gnu++11 to the compile line. For ## compilers that have no notion of a standard level, such as Microsoft Visual C++ before 2015## Update 3, this has no effect.## ## Supported values are 98, 11, 14, 17, and 20.set(CMAKE_CXX_STANDARD 11)## Boolean describing whether the value of CXX_STANDARD is a requirement.## ## If this property is set to ON, then the value of the CXX_STANDARD target property is treated ## as a requirement. If this property is OFF or unset, the CXX_STANDARD target property is treated ## as optional and may “decay” to a previous standard if the requested is not available. For ## compilers that have no notion of a standard level, such as MSVC, this has no effect.set(CMAKE_CXX_STANDARD_REQUIRED ON)## Boolean specifying whether compiler specific extensions are requested.## ## This property specifies whether compiler specific extensions should be used. For some compilers, ## this results in adding a flag such as -std=gnu++11 instead of -std=c++11 to the compile line. ## This property is ON by default. The basic C++ standard level is controlled by the CXX_STANDARD## target property.set(CMAKE_CXX_EXTENSIONS OFF)## WIN32为运行cmake时指定的宏if (WIN32) set(LEVELDB_PLATFORM_NAME LEVELDB_PLATFORM_WINDOWS) # TODO(cmumford): Make UNICODE configurable for Windows. ## Add -D define flags to the compilation of source files. ## ## add_definitions(-DFOO -DBAR ...) ## Adds definitions to the compiler command line for targets in the current directory and below ## (whether added before or after this command is invoked). This command can be used to add any ## flags, but it is intended to add preprocessor definitions. add_definitions(-D_UNICODE -DUNICODE)else (WIN32) set(LEVELDB_PLATFORM_NAME LEVELDB_PLATFORM_POSIX)endif (WIN32)## Provide an option that the user can optionally select.## ## option(&lt;variable&gt; "&lt;help_text&gt;" [value])## Provides an option for the user to select as ON or OFF. If no initial &lt;value&gt; is provided, OFF ## is used. If &lt;variable&gt; is already set as a normal variable then the command does nothing.## 可通过命令行运行时更改默认值## 比如 -DLEVELDB_BUILD_TESTS=OFFoption(LEVELDB_BUILD_TESTS "Build LevelDB's unit tests" ON)option(LEVELDB_BUILD_BENCHMARKS "Build LevelDB's benchmarks" ON)option(LEVELDB_INSTALL "Install LevelDB's header and library" ON)## Load and run CMake code from a file or module.## ## include(&lt;file|module&gt; [OPTIONAL] [RESULT_VARIABLE &lt;var&gt;]## [NO_POLICY_SCOPE])## Loads and runs CMake code from the file given. Variable reads and writes access the scope of the ## caller (dynamic scoping). If OPTIONAL is present, then no error is raised if the file does not ## exist. If RESULT_VARIABLE is given the variable &lt;var&gt; will be set to the full filename which has ## been included or NOTFOUND if it failed.## ## If a module is specified instead of a file, the file with name &lt;modulename&gt;.cmake is searched ## first in CMAKE_MODULE_PATH, then in the CMake module directory. There is one exception to this:## if the file which calls include() is located itself in the CMake builtin module directory, then ## first the CMake builtin module directory is searched and CMAKE_MODULE_PATH afterwards. See also## policy CMP0017.## 引入TestBigEndian模块（cmake内部模块）include(TestBigEndian)## 判断系统是大端还是小端，结果存在 LEVELDB_IS_BIG_ENDIAN 宏test_big_endian(LEVELDB_IS_BIG_ENDIAN)include(CheckIncludeFile)## 判断头文件是否存在，结果存在 HAVE_UNISTD_Hcheck_include_file("unistd.h" HAVE_UNISTD_H)## 同上面的原理include(CheckLibraryExists)check_library_exists(crc32c crc32c_value "" HAVE_CRC32C)check_library_exists(snappy snappy_compress "" HAVE_SNAPPY)check_library_exists(tcmalloc malloc "" HAVE_TCMALLOC)include(CheckCXXSymbolExists)# Using check_cxx_symbol_exists() instead of check_c_symbol_exists() because# we're including the header from C++, and feature detection should use the same# compiler language that the project will use later. Principles aside, some# versions of do not expose fdatasync() in &lt;unistd.h&gt; in standard C mode# (-std=c11), but do expose the function in standard C++ mode (-std=c++11).check_cxx_symbol_exists(fdatasync "unistd.h" HAVE_FDATASYNC)check_cxx_symbol_exists(F_FULLFSYNC "fcntl.h" HAVE_FULLFSYNC)include(CheckCXXSourceCompiles)# Test whether -Wthread-safety is available. See# https://clang.llvm.org/docs/ThreadSafetyAnalysis.html# -Werror is necessary because unknown attributes only generate warnings.set(OLD_CMAKE_REQUIRED_FLAGS $&#123;CMAKE_REQUIRED_FLAGS&#125;)## 把后两个编译选项添加到CMAKE_REQUIRED_FLAGSlist(APPEND CMAKE_REQUIRED_FLAGS -Werror -Wthread-safety)## 判断第一个参数的代码是否能编译链接成可行性文件check_cxx_source_compiles("struct __attribute__((lockable)) Lock &#123; void Acquire() __attribute__((exclusive_lock_function())); void Release() __attribute__((unlock_function()));&#125;;struct ThreadSafeType &#123; Lock lock_; int data_ __attribute__((guarded_by(lock_)));&#125;;int main() &#123; return 0; &#125;" HAVE_CLANG_THREAD_SAFETY)set(CMAKE_REQUIRED_FLAGS $&#123;OLD_CMAKE_REQUIRED_FLAGS&#125;)# Test whether C++17 __has_include is available.check_cxx_source_compiles("#if defined(__has_include) &amp;&amp; __has_include(&lt;string&gt;)#include &lt;string&gt;#endifint main() &#123; std::string str; return 0; &#125;" HAVE_CXX17_HAS_INCLUDE)set(LEVELDB_PUBLIC_INCLUDE_DIR "include/leveldb")set(LEVELDB_PORT_CONFIG_DIR "include/port")## 复制源文件到目的地址，并替换其中的宏定义configure_file( "$&#123;PROJECT_SOURCE_DIR&#125;/port/port_config.h.in" "$&#123;PROJECT_BINARY_DIR&#125;/$&#123;LEVELDB_PORT_CONFIG_DIR&#125;/port_config.h")## Add the given directories to those the compiler uses to search for include files. Relative ## paths are interpreted as relative to the current source directory.include_directories( "$&#123;PROJECT_BINARY_DIR&#125;/include" "$&#123;PROJECT_SOURCE_DIR&#125;")## 编译动态库，需要再命令行运行时指定宏## 默认是静态？if(BUILD_SHARED_LIBS) # Only export LEVELDB_EXPORT symbols from the shared library. ## 编译时全部隐藏接口，只有在代码中显示暴露的才暴露 add_compile_options(-fvisibility=hidden)endif(BUILD_SHARED_LIBS)## 指定要生成的库为leveldbadd_library(leveldb "")## 指定生成leveldb需要的源文件## PRIVATE 表明生成leveldb的编译选项不传递（引用了leveldb的target，不确定就写private），可选值有private\public\interfacetarget_sources(leveldb PRIVATE ## PROJECT_BINARY_DIR -- cmake构建时的根目录（通常就是build路径） ## PROJECT_SOURCE_DIR -- 源码目录，即cmake构建时指定的cmakelist.txt所在路径（通常是src目录） "$&#123;PROJECT_BINARY_DIR&#125;/$&#123;LEVELDB_PORT_CONFIG_DIR&#125;/port_config.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/builder.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/builder.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/c.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/db_impl.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/db_impl.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/db_iter.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/db_iter.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/dbformat.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/dbformat.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/dumpfile.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/filename.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/filename.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/log_format.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/log_reader.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/log_reader.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/log_writer.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/log_writer.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/memtable.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/memtable.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/repair.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/skiplist.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/snapshot.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/table_cache.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/table_cache.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/version_edit.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/version_edit.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/version_set.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/db/version_set.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/write_batch_internal.h" "$&#123;PROJECT_SOURCE_DIR&#125;/db/write_batch.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/port/port_stdcxx.h" "$&#123;PROJECT_SOURCE_DIR&#125;/port/port.h" "$&#123;PROJECT_SOURCE_DIR&#125;/port/thread_annotations.h" "$&#123;PROJECT_SOURCE_DIR&#125;/table/block_builder.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/table/block_builder.h" "$&#123;PROJECT_SOURCE_DIR&#125;/table/block.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/table/block.h" "$&#123;PROJECT_SOURCE_DIR&#125;/table/filter_block.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/table/filter_block.h" "$&#123;PROJECT_SOURCE_DIR&#125;/table/format.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/table/format.h" "$&#123;PROJECT_SOURCE_DIR&#125;/table/iterator_wrapper.h" "$&#123;PROJECT_SOURCE_DIR&#125;/table/iterator.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/table/merger.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/table/merger.h" "$&#123;PROJECT_SOURCE_DIR&#125;/table/table_builder.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/table/table.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/table/two_level_iterator.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/table/two_level_iterator.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/arena.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/arena.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/bloom.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/cache.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/coding.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/coding.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/comparator.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/crc32c.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/crc32c.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/env.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/filter_policy.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/hash.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/hash.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/logging.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/logging.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/mutexlock.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/no_destructor.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/options.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/random.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/status.cc" # Only CMake 3.3+ supports PUBLIC sources in targets exported by "install". ## 看不懂 $&lt;$&lt;VERSION_GREATER:CMAKE_VERSION,3.2&gt;:PUBLIC&gt; "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/c.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/cache.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/comparator.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/db.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/dumpfile.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/env.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/export.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/filter_policy.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/iterator.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/options.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/slice.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/status.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/table_builder.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/table.h" "$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/write_batch.h")if (WIN32) target_sources(leveldb PRIVATE "$&#123;PROJECT_SOURCE_DIR&#125;/util/env_windows.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/windows_logger.h" )else (WIN32) target_sources(leveldb PRIVATE "$&#123;PROJECT_SOURCE_DIR&#125;/util/env_posix.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/posix_logger.h" )endif (WIN32)# MemEnv is not part of the interface and could be pulled to a separate library.target_sources(leveldb PRIVATE "$&#123;PROJECT_SOURCE_DIR&#125;/helpers/memenv/memenv.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/helpers/memenv/memenv.h")## build和install时候的包含路径是不同的## 不同的情形下运用不同的变量## CMAKE_INSTALL_INCLUDEDIR的默认值是 includetarget_include_directories(leveldb PUBLIC $&lt;BUILD_INTERFACE:$&#123;PROJECT_SOURCE_DIR&#125;/include&gt; $&lt;INSTALL_INTERFACE:$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&gt;)target_compile_definitions(leveldb PRIVATE # Used by include/export.h when building shared libraries. LEVELDB_COMPILE_LIBRARY # Used by port/port.h. $&#123;LEVELDB_PLATFORM_NAME&#125;=1)if (NOT HAVE_CXX17_HAS_INCLUDE) target_compile_definitions(leveldb PRIVATE LEVELDB_HAS_PORT_CONFIG_H=1 )endif(NOT HAVE_CXX17_HAS_INCLUDE)if(BUILD_SHARED_LIBS) target_compile_definitions(leveldb PUBLIC # Used by include/export.h. LEVELDB_SHARED_LIBRARY )endif(BUILD_SHARED_LIBS)if(HAVE_CLANG_THREAD_SAFETY) target_compile_options(leveldb PUBLIC -Werror -Wthread-safety)endif(HAVE_CLANG_THREAD_SAFETY)if(HAVE_CRC32C) target_link_libraries(leveldb crc32c)endif(HAVE_CRC32C)if(HAVE_SNAPPY) target_link_libraries(leveldb snappy)endif(HAVE_SNAPPY)if(HAVE_TCMALLOC) target_link_libraries(leveldb tcmalloc)endif(HAVE_TCMALLOC)# Needed by port_stdcxx.h## 查找相关的库的依赖find_package(Threads REQUIRED)target_link_libraries(leveldb Threads::Threads)add_executable(leveldbutil "$&#123;PROJECT_SOURCE_DIR&#125;/db/leveldbutil.cc")target_link_libraries(leveldbutil leveldb)if(LEVELDB_BUILD_TESTS) ## test必须要有这个 enable_testing() function(leveldb_test test_file) ## 提取 test_file 中的文件名，把目录和后缀都去掉 ## 例如：your_path/my_test.cc -&gt; my_test ## 结果存在 test_target_name 中 get_filename_component(test_target_name "$&#123;test_file&#125;" NAME_WE) add_executable("$&#123;test_target_name&#125;" "") target_sources("$&#123;test_target_name&#125;" PRIVATE "$&#123;PROJECT_BINARY_DIR&#125;/$&#123;LEVELDB_PORT_CONFIG_DIR&#125;/port_config.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/testharness.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/testharness.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/testutil.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/testutil.h" "$&#123;test_file&#125;" ) target_link_libraries("$&#123;test_target_name&#125;" leveldb) target_compile_definitions("$&#123;test_target_name&#125;" PRIVATE $&#123;LEVELDB_PLATFORM_NAME&#125;=1 ) if (NOT HAVE_CXX17_HAS_INCLUDE) target_compile_definitions("$&#123;test_target_name&#125;" PRIVATE LEVELDB_HAS_PORT_CONFIG_H=1 ) endif(NOT HAVE_CXX17_HAS_INCLUDE) ## 向项目添加一个测试，让ctest能够运行 ## 测试名称NAME--test_target_name，测试启动命令COMMAND--test_target_name add_test(NAME "$&#123;test_target_name&#125;" COMMAND "$&#123;test_target_name&#125;") endfunction(leveldb_test) leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/c_test.c") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/fault_injection_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/issues/issue178_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/issues/issue200_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/env_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/status_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/no_destructor_test.cc") if(NOT BUILD_SHARED_LIBS) leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/autocompact_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/corruption_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/db_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/dbformat_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/filename_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/log_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/recovery_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/skiplist_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/version_edit_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/version_set_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/db/write_batch_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/helpers/memenv/memenv_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/table/filter_block_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/table/table_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/arena_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/bloom_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/cache_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/coding_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/crc32c_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/hash_test.cc") leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/logging_test.cc") # TODO(costan): This test also uses # "$&#123;PROJECT_SOURCE_DIR&#125;/util/env_&#123;posix|windows&#125;_test_helper.h" if (WIN32) leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/env_windows_test.cc") else (WIN32) leveldb_test("$&#123;PROJECT_SOURCE_DIR&#125;/util/env_posix_test.cc") endif (WIN32) endif(NOT BUILD_SHARED_LIBS)endif(LEVELDB_BUILD_TESTS)## 与test部分类似if(LEVELDB_BUILD_BENCHMARKS) function(leveldb_benchmark bench_file) get_filename_component(bench_target_name "$&#123;bench_file&#125;" NAME_WE) add_executable("$&#123;bench_target_name&#125;" "") target_sources("$&#123;bench_target_name&#125;" PRIVATE "$&#123;PROJECT_BINARY_DIR&#125;/$&#123;LEVELDB_PORT_CONFIG_DIR&#125;/port_config.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/histogram.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/histogram.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/testharness.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/testharness.h" "$&#123;PROJECT_SOURCE_DIR&#125;/util/testutil.cc" "$&#123;PROJECT_SOURCE_DIR&#125;/util/testutil.h" "$&#123;bench_file&#125;" ) target_link_libraries("$&#123;bench_target_name&#125;" leveldb) target_compile_definitions("$&#123;bench_target_name&#125;" PRIVATE $&#123;LEVELDB_PLATFORM_NAME&#125;=1 ) if (NOT HAVE_CXX17_HAS_INCLUDE) target_compile_definitions("$&#123;bench_target_name&#125;" PRIVATE LEVELDB_HAS_PORT_CONFIG_H=1 ) endif(NOT HAVE_CXX17_HAS_INCLUDE) endfunction(leveldb_benchmark) if(NOT BUILD_SHARED_LIBS) leveldb_benchmark("$&#123;PROJECT_SOURCE_DIR&#125;/db/db_bench.cc") endif(NOT BUILD_SHARED_LIBS) check_library_exists(sqlite3 sqlite3_open "" HAVE_SQLITE3) if(HAVE_SQLITE3) leveldb_benchmark("$&#123;PROJECT_SOURCE_DIR&#125;/doc/bench/db_bench_sqlite3.cc") target_link_libraries(db_bench_sqlite3 sqlite3) endif(HAVE_SQLITE3) # check_library_exists is insufficient here because the library names have # different manglings when compiled with clang or gcc, at least when installed # with Homebrew on Mac. set(OLD_CMAKE_REQURED_LIBRARIES $&#123;CMAKE_REQUIRED_LIBRARIES&#125;) list(APPEND CMAKE_REQUIRED_LIBRARIES kyotocabinet) check_cxx_source_compiles("#include &lt;kcpolydb.h&gt;int main() &#123; kyotocabinet::TreeDB* db = new kyotocabinet::TreeDB(); delete db; return 0;&#125; " HAVE_KYOTOCABINET) ## 临时替换一个变量 set(CMAKE_REQUIRED_LIBRARIES $&#123;OLD_CMAKE_REQURED_LIBRARIES&#125;) if(HAVE_KYOTOCABINET) leveldb_benchmark("$&#123;PROJECT_SOURCE_DIR&#125;/doc/bench/db_bench_tree_db.cc") target_link_libraries(db_bench_tree_db kyotocabinet) endif(HAVE_KYOTOCABINET)endif(LEVELDB_BUILD_BENCHMARKS)## 安装这部分没看懂if(LEVELDB_INSTALL) ## 引入安装模块 include(GNUInstallDirs) ## TARGETS -- 指定安装的模块名称 install(TARGETS leveldb ## EXPORT -- This option associates the installed target files with an ## export called &lt;export-name&gt;. ## It must appear before any target options. EXPORT leveldbTargets RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125; LIBRARY DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125; ARCHIVE DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125; ) install( FILES "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/c.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/cache.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/comparator.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/db.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/dumpfile.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/env.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/export.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/filter_policy.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/iterator.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/options.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/slice.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/status.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/table_builder.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/table.h" "$&#123;PROJECT_SOURCE_DIR&#125;/$&#123;LEVELDB_PUBLIC_INCLUDE_DIR&#125;/write_batch.h" DESTINATION $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;/leveldb ) include(CMakePackageConfigHelpers) write_basic_package_version_file( "$&#123;PROJECT_BINARY_DIR&#125;/leveldbConfigVersion.cmake" COMPATIBILITY SameMajorVersion ) install( EXPORT leveldbTargets NAMESPACE leveldb:: DESTINATION "$&#123;CMAKE_INSTALL_LIBDIR&#125;/cmake/leveldb" ) install( FILES "$&#123;PROJECT_SOURCE_DIR&#125;/cmake/leveldbConfig.cmake" "$&#123;PROJECT_BINARY_DIR&#125;/leveldbConfigVersion.cmake" DESTINATION "$&#123;CMAKE_INSTALL_LIBDIR&#125;/cmake/leveldb" )endif(LEVELDB_INSTALL) cmake命令构建cmake {your_source_path} cmake 会去your_source_path找CMakeList.txt，根据这个文件生成相应的文件（主要是平台相关的makefile）。生成文件的目录就是当前目录。 编译make 或者 cmake –build 后面也可以指定生成路径。 测试make test 生成的 makefile 中有 test target，这里用的是ctest测试框架。 安装安装还没测过，不过应该同理，在makefile里面生成 install target。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SwitchCase的另一种选择]]></title>
    <url>%2FSwitchCase%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[开发过程中，经常会遇到这样一种情况：我们会收到带有枚举属性的数据，然后根据不同的枚举值进行不同的处理。 SwitchCase这种情况，可用switch case语句处理，大概会是这样： 12345678910111213141516171819202122class Data &#123;public: enum class DataType &#123; T1, T2 &#125;; Data(DataType type) : type_(type) &#123; &#125; DataType Type() &#123; return type_; &#125;private: DataType type_;&#125;;int main() &#123; Data data = Data(Data::DataType::T1); switch (data.Type()) &#123; case Data::DataType::T1: // todo case Data::DataType::T2: // todo default: break; &#125; return 0;&#125; 通过多态的方式处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// data.hclass Data &#123;public: enum class DataType &#123; T1, T2 &#125;; Data(DataType type) : type_(type) &#123; &#125; DataType Type() &#123; return type_; &#125;private: DataType type_;&#125;;class DataHandler &#123;public: static DataHandler * Create(Data::DataType type); virtual void Handle(const Data&amp; data) = 0; virtual ~DataHandler() = default;&#125;;class DataHandlerT1 : public DataHandler &#123;public: virtual void Handle(const Data&amp; data) override;&#125;;class DataHandlerT2 : public DataHandler &#123;public: virtual void Handle(const Data&amp; data) override;&#125;;// data.cpp#include "data.h"DataHandler * DataHandler::Create(Data::DataType type) &#123; DataHandler* handler = nullptr; switch (type) &#123; case Data::DataType::T1: handler = new DataHandlerT1(); case Data::DataType::T2: handler = new DataHandlerT2(); default: break; &#125; return handler;&#125;void DataHandlerT1::Handle(const Data&amp; data) &#123; return;&#125;void DataHandlerT2::Handle(const Data&amp; data) &#123; return;&#125;// main.cppint main() &#123; Data data = Data(Data::DataType::T1); DataHandler* handler = DataHandler::Create(data.Type()); handler-&gt;Handle(data); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++单例模式]]></title>
    <url>%2FC%2B%2B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在开发过程中，经常会用到单例，简单梳理一下几种单例的写法。 写法One最开始，我写单例大概是这样的： 123456789101112class SingletonA &#123;public: static SingletonA&amp; Instance() &#123; if (!instance) &#123; instance = new SingletonA; &#125; return *instance; &#125;private: SingletonA() &#123; &#125; static SingletonA* instance;&#125;; 貌似线程不安全这样写。 写法Two之后，好像是这样写的： 123456789class SingletonB &#123;public: static SingletonB&amp; Instance() &#123; static SingletonB* instance = new SingletonB; return *instance; &#125;private: SingletonB() &#123; &#125;&#125;; 写法Three现在，就是这样写： 12345678template&lt;class T&gt;class SingletonC &#123;public: static T&amp; Instance() &#123; static T* instance = new T; return *instance; &#125;&#125;; 总结第三种写法利用了模板，看上去会灵活很多，特别是需要多个单例实例的时候，不用重复写部分代码。 通常封装的时候，为了提高可读性，可以这样写： 12class Type &#123;&#125;;using SingletonType = SingletonC&lt;Type&gt;; 在定义一些全局常量时，还可以将返回的实例定义为常引用： 12345678910111213141516class ConstValues &#123;public: const std::string A = "A"; const std::string B = "B";&#125;;template&lt;class T&gt;class SingletonC &#123;public: static const T&amp; Instance() &#123; static T* instance = new T; return *instance; &#125;&#125;;using SingletonConstValues = SingletonC&lt;ConstValues&gt;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++不定参数函数]]></title>
    <url>%2FC%2B%2B%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[用到的ApiC语言里面提供了三个宏用于实现不定参数函数：123va_start(ap,v)va_arg(ap,t)va_end(ap) 具体的Api意义和用法可查看官方文档，这里写一段示例代码。这样的代码都是固定结构，看代码会更直接一点。 不定参数函数示例实现一个不定参数的加法函数：123456789101112int AddAll(int number, ...) &#123; int result = 0; if (number &lt;= 0) return result; va_list arg_ptr; va_start(arg_ptr, number); for (; number &gt; 0; --number) &#123; int ele = va_arg(arg_ptr, int); result += ele; &#125; va_end(arg_ptr); return result;&#125; 自定义格式化输出bitcoin源码中的错误输出：12345678910111213141516bool error(const char* format, ...)&#123; char buffer[50000]; int limit = sizeof(buffer); va_list arg_ptr; va_start(arg_ptr, format); int ret = _vsnprintf(buffer, limit, format, arg_ptr); va_end(arg_ptr); if (ret &lt; 0 || ret &gt;= limit) &#123; ret = limit - 1; buffer[limit-1] = 0; &#125; printf("ERROR: %s\n", buffer); return false;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Libra分析]]></title>
    <url>%2FLibra%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[何为LibraFacebook在Libra白皮书中明确提到：Libra的使命是建立一套简单的、无国界的货币和为数十亿人服务的金融基础设施。这样的定位不可谓不宏大。互联网的发展提高了信息传输的效率，降低了信息交互的成本。Facebook希望通过区块链技术，实现全球各个国家之间低成本高效率的交易支付，进一步提供普惠金融服务。 为什么做加密货币Facebook从2016年开始研究区块链，组建区块链团队，收购区块链初创公司，招聘区块链人才等动作不断。区块链技术今年来逐渐引起互联网科技公司的重视，但像Facebook这样大公司如此大动作的并不多。Facebook为何如此投入去研究区块链及加密货币，可能存在以下几点原因： Facebook的主要盈利模式是通过广告收入，需要寻求新的增长点。近年来Facebook不断爆出用户隐私泄露丑闻，同时自欧洲颁布GDPR以来，各个国家对用户隐私保护程度不断提高，Facebook以往通过分析用户数据，精准投放广告的模式必然会受到影响，所以Facebook需要业务转型，发现新的盈利模式。 Facebook全球范围拥有27亿用户，覆盖大部分国家，而交易支付是一个拥有很大盈利空间的业务场景。基于Facebook广泛的用户群体，如果能实现用户之间的交易支付，将给Facebook带来巨大的营收。 Libra项目区块链技术具有去中心化、不可篡改、可追溯等特点，且比特币等加密货币让人们看到了基于区块链技术的加密货币的可能性。Facebook在借鉴现有加密货币的基础上，从头设计并实现全新的区块链系统。在系统中，针对加密货币安全设计了新的智能合约语言“Move”，该语言与C++的move语义有相似之处。在语言层面，控制资产只能有唯一的拥有者，每份资产只能够花费一次，并且会对交易的逻辑进行检验。Libra的定位是稳定币，与比特币等加密货币有本质不同。每一份Libra币都有真实的资产作为其储备，每生成一个Libra币就会有对应价值的资产进入储备池，如果资产被从储备池中提取出来，对应的Libra币也被销毁。市场上也有一些稳定币，如JMP Coin，USDT等，但是Libra的不同点在于其并不与某种特定的资产或法币挂钩，而是对应一篮子法币和波动性较小的短期债券，以此能保证Libra不会因为单一资产的价值波动而产生震荡。Facebook还牵头联合多家不同行业背景的公司和机构（最初28家）成立了Libra协会，注册在瑞士，负责Libra的日常运营和储备资产管理，同时成为协会会员的机构能够获取储备资产的利息分红。LIbra的愿景是实现一条公有链，凡是具备一定技术条件的节点都可以接入区块链系统中。但是当前阶段，公链在性能、安全性等方面还有很多待解决的问题，难以支撑数十亿用户大规模的交易，同时保证效率和安全。所以Libra最初将会以联盟链的形式启动，计划在5年内过渡到公链。 Calibra虽然Libra是Facebook发起，但是Facebook并不打算作为整个链的核心机构，如果那样将会是一个中心化系统，而且由于Facebook过往在用户隐私保护方面的不良记录，导致用户对其不信任。所以Facebook成立一个子公司Calibra，负责在libra上开展业务。从Calibra的官网信息来看，非常像一个支付宝的基础功能。 参考 libra官网\白皮书\技术文档\测试网络 Calibra gighub]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言几个特殊的宏]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E5%87%A0%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AE%8F%2F</url>
    <content type="text"><![CDATA[C/C++几个预定义的调试宏 FILE 记录文件的路径加名称 FUNCTION 当前所在函数名 LINE 记录文件已经被编译的行数 DATE 记录文件的编译日期 TIME 记录文件的编译时间 C语言中，#和##用法 C语言中，引号引起来的字符串，中间以空格分开，编译器（预处理器）会自动将其生成一个字符串。 #和##都是在宏定义中处理字符串的符号。 将其后跟的宏定义变量替换并添加引号。 将其后的宏定义变量替换后与前面的东西连接。1234567891011#include &lt;stdio.h&gt;#define QPRINT(IN) printf(&quot;QQQ:%s, &quot; #IN &quot;,%s\n&quot;, __FUNCTION__, __FILE__)#define QCAT(a,b) a##bint main() &#123; int xy = 111; QPRINT(55); printf(&quot;%d\n&quot;,QCAT(x,y)); return 0;&#125; 输出：12QQQ:main, 55,main.cpp111 vim中跨文件多行拷贝1、用vim打开一个文件，例如：original.trace 2、在普通模式下，输入：”:sp”（不含引号）横向切分一个窗口，或者”:vsp”纵向切分一个窗口，敲入命令后，你将看到两个窗口打开的是同一个文件 3、在普通模式下，输入：”:e new.trace”，在其中一个窗口里打开另一个文件 4、切换到含有源文件（original.trace）的窗口，在普通模式下，把光标移到你需要复制内容的起始行，然后输入你想复制的行的数量（从光标所在行往下计算），在行数后面接着输入yy，这样就将内容复制到临时寄存器里 了（在 普通模式下ctrl+w，再按一下w，可以在两个窗口之间切换） 5、切换到目标文件（new.trace）窗口，把光标移到你接收复制内容的起始行，按一下p，就完成复制了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cpp的一些知识点]]></title>
    <url>%2FCpp%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[C++模板的偏特化与全特化引用：http://harttle.com/2015/10/03/cpp-template.html 特化就是把原始模板中的部分（偏特化）或全部（全特化）模板参数固定下来，定制特定参数的实现。注意函数模板只能全特化，要得到偏特化的效果可以通过函数重载的方式。在实例化的时候，会去匹配最接近实例参数的模板实现。std命名空间不允许添加任何内容。 简单实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;// 原始模板template&lt;typename T1,typename T2&gt;class Test &#123; T1 t1; T2 t2;public: void print() &#123; std::cout&lt;&lt;&quot;aaa&quot;&lt;&lt;std::endl; &#125; &#125;;// 偏特化template&lt;typename T2&gt;class Test&lt;int,T2&gt; &#123; int t1; T2 t2;public: void show(T2 t) &#123; std::cout&lt;&lt;t&lt;&lt;std::endl; &#125;&#125;;// 全特化template&lt;&gt;class Test&lt;char,char&gt; &#123; public: void go(char c) &#123; std::cout&lt;&lt;c&lt;&lt;std::endl; &#125;&#125;;// 原始模板template&lt;typename T1,typename T2&gt;T1 func(T1 t1,T2 t2) &#123; return t1;&#125;// 全特化template&lt;&gt;int func&lt;int,int&gt;(int t1,int t2) &#123; return t1+t2;&#125;int main()&#123; Test&lt;double,double&gt; Tdouble; Test&lt;int,int&gt; Tint; Test&lt;char,char&gt; Tchar; Tdouble.print(); Tint.show(5); Tchar.go(&apos;A&apos;); std::cout&lt;&lt;func&lt;double,char&gt;(3.14,&apos;a&apos;)&lt;&lt;std::endl; std::cout&lt;&lt;func&lt;int,int&gt;(5,10)&lt;&lt;std::endl; return 0;&#125; 输入结果： aaa5A3.1415 C++内部类内部类就是定义在一个类内部的类。C++的内部类没有外部类的this指针，所以不能访问外部类的非静态成员，只能访问外部类的静态成员和枚举。 C++ 逗号表达式逗号表达式的计算顺序是从左到右的，表达式的值为最后一个式子的值。如：12int a,b,c;int d=(a=1,b=a+2,c=b+3); 输出：d==6 do{…}while(0)在linux 内核和很多库中会看到这样的用法。其意义在于： 用于宏定义，保证这个宏定义在任何环境下的展开都能得到预期的形式。 代替goto的使用。 为跨平台定义空宏，避免警告。 定义单一代码块执行复杂操作，避免命名冲突。以上如果不理解的，参考：http://www.cnblogs.com/lanxuezaipiao/p/3535674.html vector at 和 []一个是函数一个是操作符。at提供边界检查，越界时会抛出异常，[]会向原生数组一样去访问。例如：vector vec={0,1,2,3};vec.pop_back();vec[3]; //输出3vec.at(3); // 异常 max_sizevector能拥有的最大size，考虑了重新分配，比capcity大很多。 size 与capacitycapacity只会增长，不会变小，而size会。通常用pop_back，clear等方法删除元素，首先会通过萃取判断是否要执行析构，然后改变size的大小，不清空内存。 resize 和 reserveresize改变size的大小，如果是增大，则同时看capacity是否需要增大，并调用默认构造函数，如果是减小，析构（如果需要）然后减小size。reserve改变capacity的大小，如果是增大capacity，则改变capacity的大小，如果是减小，则不变，这个过程size 不变，也没有任何元素的构造。 static数据的初始化 C里面：global和static差不多。在编译的时候确定。如果有初始值存在data段；没有初始值存在bss段，在装载时初始化为默认值。 C++里面：分为静态初始化和动态初始化。静态初始化是那些不需要调用函数的变量，在编译时就能确定的；动态初始化是那些要调用函数的，需要运行期确定。C的那一部分不变，在编译时就确定了。对象的部分，包括static和global的，还是一些需要调用函数的，由于编译期无法确定值，全都存在bss段，在运行期main函数执行前，调用构造函数初始化。同一编译模块的对象初始化顺序按照定义的顺序，不同模块之间的顺序无法确定。在链接时，各个模块的bss段整合成一个bss段，但顺序不确定，这造成了各个模块之间的顺序是不确定的，所以在模块之间引用全局对象会造成未定义行为。解决方案是把全局对象的构造放到函数里面，因为C++里的局部静态对象的初始化是在第一次调用的时候（在对象之前的一点空间标记是否初始化），这可以避免引用为初始化的对象，这一点也是C++和C对于具备静态对象的初始化区别。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker部署JavaWeb项目]]></title>
    <url>%2FDocker%E9%83%A8%E7%BD%B2JavaWeb%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[基于Spring Boot搭建的Web项目，用maven作为项目管理工具。通过docker容器部署，对外提供服务。 生成war包在项目的pom.xml文件添加打包的配置：12345678&lt;project ....... &gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt; &lt;name&gt;...&lt;/name&gt; &lt;description&gt;...&lt;/description&gt; &lt;packageing&gt;war&lt;/packaging&gt;&lt;/project&gt; 通过maven的package命令生成war包，在项目目录下的target目录下会生成一个.war文件。 编写DockerfileDockerfile文件是用于指导docker如何生成我们需要的docker image的文本。针对部署JavaWeb应用的需求，编写的Dockerfile如下：123456From tomcat:8.5.38-jre8WORKDIR /usr/local/tomcatRUN echo "Asia/Shanghai" &gt; /etc/timezoneADD *.war webapps/service-name.warEXPOSE 8080CMD ["bin/catalina.sh", "run"] 命令从上至下依次为： 基于tomcat父镜像构建当前镜像。 将构建容器时的当前目录切换到tomcat根目录。 更改容器系统的时区。 将本地的war包添加到容器系统的tomcat/webapps下。 容器对外暴露8080端口。 容器启动时运行的命令。 运用docker helpdocker的子命令挺多，可通过运行docker查看有多少子命令；通过docker –subcmd –help方式查看指定的子命令–subcmd的使用方式。 生成Docker image将dockerfile及其依赖的文件置于同一目录下，主要是ADD命令用到的文件，如上述dockerfile中的.war。运行命令1docker build -t image-name:image-version . 如果命令运行成功，docker会根据dockerfile拉取依赖的文件，添加文件，生成指定的镜像，镜像的命名就是命令中指定的image-name:image-version。 运行容器在运行容器前，可先将之前的容器关闭：1docker ps | grep image-name | awk '&#123;print $1&#125;' | xargs docker rm -f 启动容器1docker run --name container-name -p 8081:8080 -dit image-name:image-version –name contianer-name: 给将要启动的容器命名。 -p 进行端口映射。将容器的8080端口映射成宿主机的8081端口，在dockerfile中暴露了容器的8080端口，映射后，访问主机的8081就会访问到容器的8080. -dit：分别是三个参数，主要让容器在后台执行。 最后一个参数是镜像的名称，就是通过dockerfile生成的镜像名，容器是根据那个镜像启动的。 总结初次用容器，只会看别人的教程依葫芦画瓢，做了些最简单的操作。容器还有很多优秀的特性，对于开发部署也很方便，有待深入学习，进一步发掘。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux安装Redis]]></title>
    <url>%2FLinux%E5%AE%89%E8%A3%85Redis%2F</url>
    <content type="text"><![CDATA[为第一次在linux下安装redis做个记录，并说明简单的配置。 安装步骤 下载安装包，以redis4.0.10为例。 1wget http://download.redis.io/release/redis-4.0.10.targ.gz 将压缩包移动到指定目录并解压。 1mv redis-4.0.10.tar.gz /usr/local &amp;&amp; cd /usr/local &amp;&amp; tar -zxvf redis-4.0.10.tar.gz 编译。 12cd /usr/local/redis-4.0.10make 安装 123456cd ./srcmake install PREFIX=/usr/local/redismkdir /usr/local/redis/etc/cp ../redis.conf /usr/local/redis/etc/cd /usr/local/redis/bin/cp redis-benchmark redis-cli redis-server /usr/bin/ 配置文件redis.conf 1234567891011121314151617181920vim /usr/local/redis/etc/redis.conf# 修改一下配置# redis以守护进程的方式运行# no表示不以守护进程的方式运行(会占用一个终端) daemonize yes# 客户端闲置多长时间后断开连接，默认为0关闭此功能 timeout 300# 设置redis日志级别，默认级别：notice loglevel verbose# 设置日志文件的输出方式,如果以守护进程的方式运行redis 默认:&quot;&quot; # 并且日志输出设置为stdout,那么日志信息就输出到/dev/null里面去了 logfile stdout# 设置密码授权requirepass &lt;设置密码&gt;# 监听ipbind 127.0.0.1 redis.conf中都有一些注释说明各种配置的意义，还是比较好理解的。几个常用的配置： protected-mode 是否保护模式，保护模式对访问的ip和端口有限制 port 对外开放的端口 bind 限制访问的ip timeout 连接超时后断开 daemonize 是否后台进程 requirepass 登陆密码 配置启动脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/bin/bash#chkconfig: 2345 80 90# Simple Redis init.d script conceived to work on Linux systems# as it does use of the /proc filesystem.PATH=/usr/local/bin:/sbin:/usr/bin:/binREDISPORT=6379EXEC=/usr/local/redis/bin/redis-serverREDIS_CLI=/usr/local/redis/bin/redis-cli PIDFILE=/var/run/redis.pidCONF="/usr/local/redis/etc/redis.conf" case "$1" in start) if [ -f $PIDFILE ] then echo "$PIDFILE exists, process is already running or crashed" else echo "Starting Redis server..." $EXEC $CONF fi if [ "$?"="0" ] then echo "Redis is running..." fi ;; stop) if [ ! -f $PIDFILE ] then echo "$PIDFILE does not exist, process is not running" else PID=$(cat $PIDFILE) echo "Stopping ..." $REDIS_CLI -p $REDISPORT SHUTDOWN while [ -x $&#123;PIDFILE&#125; ] do echo "Waiting for Redis to shutdown ..." sleep 1 done echo "Redis stopped" fi ;; restart|force-reload) $&#123;0&#125; stop $&#123;0&#125; start ;; *) echo "Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;" &gt;&amp;2 exit 1esac 设置开机自启动 1234567891011121314# 复制脚本文件到init.d目录下cp redis /etc/init.d/# 给脚本增加运行权限chmod +x /etc/init.d/redis# 查看服务列表chkconfig --list# 添加服务chkconfig --add redis# 配置启动级别chkconfig --level 2345 redis on 启动命令 12systemctl start redis #或者 /etc/init.d/redis start systemctl stop redis #或者 /etc/init.d/redis stop 总结将第一次安装redis的过程记录下，便于今后再次用到。文中有些部分是复制其他博客的内容。]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode部分解题思路]]></title>
    <url>%2Flintcode%E9%83%A8%E5%88%86%E8%A7%A3%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. A+B problem Write a function that add two numbers A and B. You should not use + or any arithmetic operators. 加法分两部分：按位异或得到当前位的值，按位与得到当前位产生的进位。1234int aplusb(int a, int b) &#123; // write your code here, try to do it without arithmetic operators. return b == 0 ? a : aplusb(a^b, ((a&amp;b) &lt;&lt; 1));&#125; 3. Digit Counts Count the number of k’s between 0 and n. k can be 0 - 9. 把数字转换成字符串来做，想法很新，值得注意，但是感觉复杂度还是很高。 1234567891011121314int digitCounts(int k, int n) &#123; // write your code here char k_ch=k+&apos;0&apos;; int count=0; for(int i=0;i&lt;=n;++i) &#123; string n_str=to_string(i); int c=0; for(int j=0;j&lt;n_str.size();++j) &#123; if(n_str[j]==k_ch) ++c; &#125; count+=c; &#125; return count;&#125; 4. Ugly Number II Ugly number is a number that only have factors 2, 3 and 5. 这个题还是没理解。下面是别人的解法：http://www.cnblogs.com/grandyang/p/4743837.html 12345678910111213int nthUglyNumber(int n) &#123; vector&lt;int&gt; res(1, 1); int i2 = 0, i3 = 0, i5 = 0; while (res.size() &lt; n) &#123; int m2 = res[i2] * 2, m3 = res[i3] * 3, m5 = res[i5] * 5; int mn = min(m2, min(m3, m5)); if (mn == m2) ++i2; if (mn == m3) ++i3; if (mn == m5) ++i5; res.push_back(mn); &#125; return res.back();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[git笔记]]></title>
    <url>%2Fgit%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基于Spring Boot搭建的Web项目，用maven作为项目管理工具。通过docker容器部署，对外提供服务。 本文作为初学者学习git的笔记，文中通过一个简单的例子说明如何通过git管理一个项目，仅涉及一些简单的命令。 一些基本的概念 git是一个基于文件内容的版本管理系统。 git有三个区域，分别是工作目录、暂存区、提交区。工作目录是用户编辑文件所在的区域，也是很直观可以看到的区域；暂存区相当于缓存，介于工作目录和提交区之间。提交区是用户将编辑好的代码发布保存的区域，也是git跟踪状态的区域。这三个区域的内容可以相互转换。 git管理的项目文件有已跟踪和未跟踪两种状态。已跟踪就是进入git管理范围的文件，未跟踪的文件不进入git管理系统。 一个简单的例子初始化 首先新建一个空的目录，作为这个例子文件的所在目录。 在新建的这个目录下，通过 git init 命令创建一个空的仓库，此时该目录会出现一个 .git目录，该目录下是git管理项目所需的文件。![初始化][初始化.png] 新建文件新建一个文件，就用readme.md，文件内容如下。1This is git test. 这时可以通过 git status 命令查看当前git的状态。![gitstatus][gitstatus.pnd]git提示有一个新的文件没有被跟踪，也就是刚才新建的 readme.md。 跟踪文件通过命令 git add . 将文件加入跟踪的范围。这里的 . 表示当前目录下的所有文件，如果要指定特定的文件，可以写出文件名，如这里也可以写成 git add readme.md 。添加以后再看状态，就没有之前的未跟踪的提示了。![gitadd][gitadd.png]但是又出现新的提示，意思是对文件内容的改动提交到了暂存区，但是没有提交到提交区。可以通过 git commit -m ‘init commit’ 将这次改动提交到提交区。这里 -m 后面的内容相当于注释，解释这次提交的内容，便于日后查看日志的时候能有所提示。![initcommit][initcommit.png] 改动文件我们对文件进行改动，看看会有什么变化。在readme.md中在加入一行12This is git test.Hello world! 查看状态，提示文件有修改，但是没有提交。用命令 git commit -a -m ‘add a line’ ，这次加了 -a 参数，该参数的作用是直接将工作目录的修改提交到提交区，不再经过提交区。![addaline][addaline.png] 创建分支git能够让多人进行协作，共同开发一个项目。通过创建分支，能够让不同的开发者在不同的开发线上进行开发，然后再将各自的代码合并到一起。通过命令 git branch dev 创建一个新的分支dev，通过 git branch -v 可以查看分支的状态。![branchdev][branchdev.png]master是主分支，也是初始化时自动创建的分支。*表示当前所处的分支，当我们处在这个分支时，所有对文件的操作都只是影响这个分支，不会影响其他的分支。 分支切换在master分支上，再添加一行，如下123This is git test.Hello world!On master. 通过和之前一样的操作提交到提交区。然后通过命令 git checkout dev，切换到dev分支，这时候看到的文件会是这样：12This is git test.Hello world! 因为在master分支的改动不会影响其他分支，所以dev分支还是刚才的状态。在dev分支上，将文件改动如下123This is git test.Hello world!On dev. 提交之后，如果再切换回master，又会回到master的文件状态。 合并分支切换到master分支，通过命令 git merge dev 将dev分支合并到master分支。由于两个分支都对同一个文件进行了修改，会出现冲突。![merger][merger.png]这时候文件内容是这样：1234567This is a git test.Hello world!&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADOn master.=======On dev.&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev 需要我们自己解决冲突后才能提交。将文件改成如下：123This is a git test.Hello world!Merge. 然后再通过提交命令提交，就没有问题了。通过命令 git log –graph –pretty=oneline –abbrev-commit 显示合并的路径，其中log后面几个参数是为了显示的更加友好。![conflictresolv][conflictresolv] 加标签其实加标签在之前的操作中也能进行，这里单独进行说明。我们能看到在之前的每次提交中，都有一个hash值，这个hash值就相当于这次提交的唯一标识。由于hash值太长了，通常只用前几位就能和别的区分开。可以为每一次提交加上一个标签，也即加上一个更有意义的名字，而不是一串hash。如下为我们的第二次提交添加一个标签。![tag][tag.png]添加标签以后，就可以用标签来代替hash，对某次提交进行操作。 远程操作git能够让多人进行协作，可以建立一个中心的仓库，参与者将开发好的代码都推送到这个仓库，进行统一管理。用户可以自己建立远程仓库，也可以用一些网络上提供的远程仓库（如github）。在进行远程操作之前，需要对远程库进行配置。以github为例，首先在github上新建一个空的仓库，拿到仓库地址，用 git remote add origin url 命令进行配置，我们在操作的时候不希望经常处理很长的 url，所以为他起了一个别名 origin。![remote][remote.png]然后将这个仓库推送到远程。推送的时候需要输入github的账号和密码。之后github上就能看到和本地一样的仓库了。![push][push.png]由于目前处于master分支，所以我们推送的时候同样推送给远程的master。 关于远程远程仓库可以理解为一个分支（origin/master），这样操作就相当于在两个分支之间进行同步。当我们要推送本地的文件到远程时，由于可能别的开发者改动过文件，导致冲突，所以推送之前需要将远程的仓库拉取到本地（通过fetch\pull\clone等子命令），然后将其与本地的分支合并后，再推送出去。 学习资料 https://try.github.io github官方的一个学习网站 https://rogerdudler.github.io/git-guide/index.zh.html 一个5分钟简明教程，快速上手]]></content>
  </entry>
  <entry>
    <title><![CDATA[web3j学习笔记]]></title>
    <url>%2Fweb3j%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Overviewweb3j是以太坊的jsonrpc的一个java封装，实现java程序与以太坊的交互。这篇笔记并不单纯的讲web3j，甚至涉及的内容只是比较基础的一部分。主要的内容是如何用java写一个基于以太坊的应用（helloworld程度），会涉及以太坊测试链、infura、solidity。 以太坊测试链以太坊是通过以太币进行交易的，每次触发合约几乎都会产生交易，也就是要消耗一定的以太币，这在应用开发阶段是不能接受的，所以以太坊官方创造了一些测试链，测试链几乎和真正的链（称为主链）相同，只是在上面的交易不会真正花费以太。目前以太坊测试链有三个： Ropsten Kovan Rinkeby – 目前最常用的测试网络这里也基于Rinkeby实现这个应用。 infura一个完整的以太坊节点要保存所有的账本数据，通常有几十G，第一次同步的时候会花费很长时间。如果仅仅做一些测试和验证，可以用infura提供的节点，不必在本地同步所有数据。之后会详细说明infura的应用。 以太坊钱包以太坊钱包有很多，官方提供的实现有geth\aleth，都是命令行界面的，完整实现了以太坊的功能。也有一些图形界面的实现，如：MyEtherWallet、Parity、Mist等，这里选用Mist，他的后端使用的是geth。]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式在不同的工具和语言中会有差异，这里限定在POSIX标准的正则。 grepLinux上的一个工具，名字来自于 “global regular expression print”，它能在输入文件中查找所有和正则匹配的文本行。用法是这样： grep [options] regex [file …]选项有很多，用到的 时候查就行了。 元字符和文本元字符：^ $ . [ ] { } - ? + ( ) | \其他的都是原义字符注意：正则的有些元字符，对shell也有特殊含义，如 ，在命令行输入的时候要加上引号，防止shell展开。 元字符含义 任意字符（.）一个圆点，匹配任意字符。 锚点（^ ，$）^ 表示开头，$表示结尾。如 ^hello，表示匹配的字符串是以 hello 开头的；hello$，表示匹配的字符串是以 hello 结尾。 中括号（[ ]）中括号给出一个集合表示在集合中的任意一个字符。如表达式 [AB]abc，表示要匹配的字符串是4个字符，最后三个是 abc，第一个是 A B中的一个。元字符如果出现在中括号中，就会失去原来的含义，变成普通字符。不过有两个特殊的，一个是 ^，它如果出现在中括号中的第一个字符（其他位置没有这个意义），表示对括号内的字符取反，匹配任意其他字符；另一个是 -，表示范围，这个稍微复杂一点，单独说。 连字符（-）连字符表示一个范围。如表达式 [A-Z0-9a-z] ，可以将括号内的内容展开成所有大写字母，所有数字，所有小写字母，然后匹配其中任意一个。但若是 -在括号中的第一个字符，它就表示普通字符。使用连字符在某些情况下有可能会出现问题，这取决于系统中字符的顺序是字典序还是ASCII码的排序。为了能得到统一的结果，最好使用POSIX提供的字符集： 扩展的正则表达式扩展的正则表达式包括了基本的正则表达式。这里只写扩展的。在grep 后加上 -E 选项就是扩展的。 扩展的元字符 可选（|）1$ echo &quot;AAA&quot; | grep -E &apos;AAA|BBB|CCC&apos; 输出：AAA ‘^(bz|gz|zip)’ 表示以 “bz” “gz” “zip” 开头的字符串 ?匹配前面的元素一个或0个 +匹配前面的元素一个或多个 *匹配前面的元素0个或多个 {}匹配前面的元素，次数由括号内的内容定。n -&gt; 匹配 n 个n, m -&gt; 匹配 n~m 个n, -&gt; 匹配 n~无穷个,m -&gt; 匹配0～m 个 其他less 和 vim 都支持基本的正则表达式查找]]></content>
  </entry>
  <entry>
    <title><![CDATA[用idea构建一个spring项目]]></title>
    <url>%2F%E7%94%A8idea%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAspring%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[安装tomcat 到官网下载合适版本的tomcat到本地 解压 之前有配置过java环境变量，就不用再配置其他的了 运行bin目录下的startup脚本，看是否正常显示 创建项目 打开idea 创建项目: file -&gt; new -&gt;project -&gt; java enterprise 如果之前没有配置过tomcat，需要再”Application Server”配置tomcat的根目录 在“Additional libraries and frameworks”选择”Web Application” 之后就是配项目路径 生成项目后的目录结构 启动项目文件’项目根目录/web/index.jsp’就是主页面 修改index.jsp如下： 运行项目在浏览器中显示如下： 添加一个子页面 在src下新建一个类，如下 1234567891011121314151617package test.qqq.tomcat;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class FirstServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter writer = resp.getWriter(); writer.append(&quot;123456&quot;); writer.close(); &#125;&#125; 修改’web/WEB-INF-web.xml’如下 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HiServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;test.qqq.tomcat.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HiServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/sayHi&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 启动项目后，在浏览器输入’http://localhost:8080/sayHi&#39;，效果如下]]></content>
  </entry>
  <entry>
    <title><![CDATA[solidity学习笔记]]></title>
    <url>%2Fsolidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[overviewsolidity是为了以太坊智能合约而创造的语言，语言本身并不复杂，有其他编程语言基础的人应该很容易上手，但是由于其特殊的运行环境，它也有一些独有的特性。先看一段智能合约代码，这是来自官方文档的示例： 123456789101112131415161718192021222324pragma solidity ^0.4.21; //合约的第一句必须是这个形式，表明solidity版本，当前最新版本是0.4.24contract Coin &#123; //用contract申明这个合约，Coin是合约名称，这里类似于c++中的class申明 address public minter; //变量申明，address是数据类型，public是访问权限，minter是变量名 mapping (address =&gt; uint) public balances; // 变量申明，mapping相当于c++里的map, python的字典 events Sent(address from, address to, uint amount); // 事件申明 constructor public &#123; //构造函数 minter = msg.sender; &#125; function mint(address receiver, uint amount) public &#123; // 普通函数，mint是函数名 if(msg.sender != minter) return; balances[receiver] += amount; &#125; function send(address receiver, uint amount) public &#123; if(balances[msg.sender] &lt; amount) return; balances[msg.sender] -= amount; balances[receiver] += amount; emit Sent(msg.sender, receiver, amount); //向全网发送一个消息，内容是Sent中的三个参数 &#125;&#125; 这段代码展示了一个智能合约的基本结构，代码中体现了solidity的一些基本特性。一个solidity合约就相当于其他面向对象语言的一个类，同样有属性和方法。这里先对solidity写一个合约有个整体性了解，接下来再细说一些具体细节。 memory\storage 这两个关键字通常用来修饰变量 memory是存储在内存中的，storage是存储在链上的，也就是memory的变量在作用域结束后就消失，storage变量永久保存。 合约的状态变量默认是storage，函数局部变量和函数传参默认是memory。 在有写情况需要显示声明变量的存储位置，storage像是指针，而memory则是新开辟空间。 constant\view\pure关键字这三个关键字用于控制function的读写权限，类似于c++中类方法的const的位置。 关键字的位置1function func(arg1...) view public &#123; ... &#125; constant和view这两个关键字的作用是一样的，都是用于限制function对合约的内容只有只读权限，不能修改合约状态。新版本的solidity用view取代了constant。 pure表示所修饰的function对合约的状态不读不写，给我的感觉有点像c++里面的static函数或者全局函数。比如：1234function func(uint a, uint b) pure public returns(uint) &#123; uint c = a + b; return c;&#125; 为什么会有这些限制首先，在以太坊上进行任何一笔交易，都是需要消耗gas的，对应的也就是以太币，而且需要全网验证、矿工挖矿。那么用pure和view修饰的函数，只是从某个节点读取数据（甚至不读不写），不需要产生交易，所以可以省钱省时间。如果一个函数没有用view和pure修饰，默认是要产生一笔交易的，即使函数不对合约状态做任何修改。（至于EVM是如何处理的还没有深究）。此外，如果产生一笔交易，花费很长时间，并且要全网验证同步，函数中的返回值是不会直接能读出的，即使在函数中写明有返回值，在调用的时候返回的也只有交易的信息。 可见性solidity的可见性有四类：external\public\internal\private external，合约接口的一部分，只能在合约外部调用，比如别的合约、客户端。 public，合约接口的一部分，类似其他面向对象语言的public。 internal，类似于c++的protected。 private，类似于c++的private。solidity的可见性也要尽量按照函数应该有的访问权限写好，因为不同访问权限的函数对应的gas消耗不一样，这与EVM的实现有关（具体也还要继续研究） modifier翻译成中文是修饰器，类似于python的装饰器。一段简单的示例如下：12345678modifier need() &#123; require(condition == true); _;&#125;function func(arg...) modifier &#123;&#125; 以上的代码，在func中添加了一个修饰器，函数被调用时会先执行modifier定义的内容，再执行自己本身的内容。 关键字assert\require\revert这几个关键字用于代替0.4.10以前的1if(!condition) &#123; throw;&#125; 现在的写法是：123assert(condition);require(condition);if(!condition) &#123; revert();&#125; 以下是assert和require的一点区别，还有一些问题暂时没弄懂： assert会终止程序，并消耗掉剩余的gas，. require会终止程序，并返回剩余的gas. solidity自带的特殊变量和函数solidity中自带了一些内置函数和变量，如下： block.blockhash(uint blockNumber) returns (byte32)–返回指定blockNumber的哈希值（仅限最近的256个block，并且不包括当前block） blockhash(uint blockNumber)–在0.4.22后替代block.blockhash block.coinbase (address)–当前区块的矿工地址 block.difficulty (uint)–当前区块的挖矿难度 block.gaslimit (uint)–当前区块的gaslimit block.number (uint)–当前区块的高度 block.timestamp (uint)–当前区块的时间戳 gasleft() returns (uint256)–还剩下的gas msg.data (bytes)–complete calldata（不知道什么意思） msg.gas (uint)–0.4.21后被gasleft代替 msg.sender (address)–发起交易的地址 msg.sig (bytes4)–first four bytes of the calldata msg.value (uint)–number of wei sent with the message now (uint)–当前时间戳，同block.timestamp tx.gasprice (uint)–当前这笔交易的燃料价格 tx.origin (address)–当前这笔交易的发起者 其他solidity的语言细节和于EVM相关的机制内容还有很多，这里仅仅简要的记录了一小部分。另外，在学习的过程中，体会到一边看别人的代码一边写，遇到不知道的再去查文档是一个比较有效的方式。这里推荐看一下加密的源代码，代码量并不多，其中涉及的语言细节上面基本上都提到了，而且看懂加密猫的代码也就能自己写一些合约了。 增加的 fallback函数 fallback函数是合约中一个特殊的函数，没有返回值，没有参数，没有函数名，一个合约中只能有一个。在合约调用没有匹配到函数签名，或者调用没有携带任何数据时被自动调用。 solidity提供了编译期检查，所有不能调用不存在的函数，但是可以通过底层的address.call来模拟。 直接上代码分析吧： 123456789101112131415161718192021222324252627282930pragma solidity ^0.4.0;contract ExecuteFallback&#123; //回退事件，会把调用的数据打印出来 event FallbackCalled(bytes data); //fallback函数，注意是没有名字的，没有参数，没有返回值的 function()&#123; FallbackCalled(msg.data); &#125; //调用已存在函数的事件，会把调用的原始数据，请求参数打印出来 event ExistFuncCalled(bytes data, uint256 para); //一个存在的函数 function existFunc(uint256 para)&#123; ExistFuncCalled(msg.data, para); &#125; // 模拟从外部对一个存在的函数发起一个调用，将直接调用函数 function callExistFunc()&#123; bytes4 funcIdentifier = bytes4(keccak256(&quot;existFunc(uint256)&quot;)); this.call(funcIdentifier, uint256(1)); &#125; //模拟从外部对一个不存在的函数发起一个调用，由于匹配不到函数，将调用回退函数 function callNonExistFunc()&#123; bytes4 funcIdentifier = bytes4(keccak256(&quot;functionNotExist()&quot;)); this.call(funcIdentifier); &#125;&#125; solidity函数签名方式–bytes4(keccak256(“existFunc(uint256)”))，引号中间是函数名和参数 msg.data–函数签名加上参数 address.call调用方式–底层通过地址调用一个合约方法，第一个参数是函数签名，之后是参数。 send 使用address.send(ether to send)向某个合约直接转以太币，由于这个行为没有发送任何数据，所以接收合约总是会调用fallback函数。 示例代码： 123456789101112131415161718192021222324pragma solidity ^0.4.0;contract SendFallback&#123; //fallback函数及其事件 event fallbackTrigged(bytes data); function() payable&#123;fallbackTrigged(msg.data);&#125; //存入一些ether用于后面的测试 function deposit() payable&#123; &#125; //查询当前的余额 function getBalance() constant returns(uint)&#123; return this.balance; &#125; event SendEvent(address to, uint value, bool result); //使用send()发送ether，观察会触发fallback函数 function sendEther()&#123; bool result = this.send(1); SendEvent(this, 1, result); &#125;&#125; 如果我们要在合约中通过send()函数接收，就必须定义fallback函数，否则会抛异常。 fallback函数必须增加payable关键字，否则send()执行结果将会始终为false。 fallback的限制，send函数会限制gas的数量，防止恶意的操作。 payable 用于标识一个方法，在调用时可以接受以太币。 调用方式–address.call(some method).value(ether account). msg.value得到的是随调用指定的以太币数量。 call 通过底层的方式调用指定地址的方法。 addr.call(“abc”, 256)，abc是函数名称，256是对应的参数 bytes4 methodId = bytes4(keccak256(“increaseAge(string,uint256)”));addr.call(methodId,”jack”, 1);如果第一个参数刚好是四个字节，会认为这四个字节指定的是函数签名的序号值，由如果你只是想传个参数值，而不是想指定一个函数序号，应避免第一个参数刚好是四个字节 delegatecall 功能与call类似 区别在于运行环境不通，delegatecall是在调用的函数是在当前环境下运行，call调用的函数是在被调用环境运行。delegatecall相当于将目标代码放到当前环境运行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[node开发以太坊程序]]></title>
    <url>%2Fnode%E5%BC%80%E5%8F%91%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[记录用node开发以太坊程序的一些关键点，通过web3js-1.0 提示nodejs是写后端的，它提供的很多模块在前端js上不能运行（因为浏览器没有环境），可通过browserify在本地打包对应的模块成.js 文件，在浏览器页面上运行。安装：1npm install -g browserify 打包自己写的模块1browserify packagename.js -o name.js 打包系统模块1browserify packagename &gt; compiled.js 编译智能合约编译合约的方式有多种，包括用remix直接编译、终端运行solc。这里不展开，主要介绍node代码中编译合约。以下是代码：1234solc = require(&apos;solc&apos;)compiledCode = solc.compile(code)abi = JSON.parse(compiledCode.contracts[&apos;:Grades&apos;].interface) // 返回abibyteCode = compiledCode.contracts[&apos;:Grades&apos;].bytecode // 返回二进制 编译出来重要的部分也就是abi和二进制，对应用solc编译后得到的.abi和.bin。 初始化web3官方推荐的写法：123456let Web3 = require(&apos;web3&apos;);if(typeof web3 !== &apos;undefined&apos;) &#123; web3 = new Web3(web3.currentProvider);&#125; else &#123; web3 = new Web3(new Web3.providers.HttpProvider(Address)); // Address这里放以太坊节点的ip&#125; 加载已经部署好的合约1let contract = new web3.eth.Contract(abi, address); 第一个参数是abi，第二个参数是合约地址，后面的参数都可以通过myContract.options进行设置。 部署合约1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253myContract.deploy(&#123; data: &apos;0x12345...&apos;, arguments: [123, &apos;My String&apos;]&#125;).send(&#123; from: &apos;0x1234567890123456789012345678901234567891&apos;, gas: 1500000, gasPrice: &apos;30000000000000&apos;&#125;, function(error, transactionHash)&#123; ... &#125;).on(&apos;error&apos;, function(error)&#123; ... &#125;).on(&apos;transactionHash&apos;, function(transactionHash)&#123; ... &#125;).on(&apos;receipt&apos;, function(receipt)&#123; console.log(receipt.contractAddress) // contains the new contract address&#125;).on(&apos;confirmation&apos;, function(confirmationNumber, receipt)&#123; ... &#125;).then(function(newContractInstance)&#123; console.log(newContractInstance.options.address) // instance with the new contract address&#125;);// When the data is already set as an option to the contract itselfmyContract.options.data = &apos;0x12345...&apos;;myContract.deploy(&#123; arguments: [123, &apos;My String&apos;]&#125;).send(&#123; from: &apos;0x1234567890123456789012345678901234567891&apos;, gas: 1500000, gasPrice: &apos;30000000000000&apos;&#125;).then(function(newContractInstance)&#123; console.log(newContractInstance.options.address) // instance with the new contract address&#125;);// Simply encodingmyContract.deploy(&#123; data: &apos;0x12345...&apos;, arguments: [123, &apos;My String&apos;]&#125;).encodeABI();&gt; &apos;0x12345...0000012345678765432&apos;// Gas estimationmyContract.deploy(&#123; data: &apos;0x12345...&apos;, arguments: [123, &apos;My String&apos;]&#125;).estimateGas(function(err, gas)&#123; console.log(gas);&#125;); 解密钱包1234let walletJson = JSON.parse(walletBuffer); //walletBuffer是以字符串读入的钱包文件let wallets = new Array(walletJson);walletDecrypted = web3.eth.accounts.wallet.decrypt(wallets, passwordVal);let privateKey = walletDecrypted[0].privateKey; //提取私钥 调用非交易方法123456789function getUsers() &#123; contract.methods.getUsers().call(&#123;from: &apos;1062024529684b1890b2fa5964334d8db7da2512&apos;&#125;, function(err, res) &#123; if(err) &#123; alert(err); &#125; else &#123; alert(res); &#125; &#125;);&#125; 调用交易方法12345678910111213141516contract.methods.saveEvidence(digest, 4444444444).send(&#123; from: &apos;1062024529684b1890b2fa5964334d8db7da2512&apos;, gasPrice: &apos;0x3B9ACA00&apos;, gas: 4000000, &#125;)// .on(&apos;confirmation&apos;, function(confirmationNumber, receipt) &#123;// alert(confirmationNumber);// alert(JSON.stringify(receipt));// &#125;) .on(&apos;receipt&apos;, function(receipt) &#123;// alert(JSON.stringify(receipt)); let saveEvidenceOutput = document.getElementById(&apos;saveEvidenceOutput&apos;); saveEvidenceOutput.value = JSON.stringify(receipt); &#125;) .on(&apos;error&apos;, alert);&#125; js读本地文件12let reader = new FileReader();reader.readAsBinaryString(myWallet); // myWallet文件路径 读出的对象是一个object，可通过json序列化查看内容 源代码index.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ConnectToContract&lt;/title&gt; &lt;script type = &apos;text/javascript&apos; src = &apos;web3.js&apos;&gt;&lt;/script&gt; &lt;script type = &apos;text/javascript&apos; src = &apos;crypto.js&apos;&gt;&lt;/script&gt; &lt;script type = &apos;text/javascript&apos; src = &apos;main.js&apos;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&quot;test-register&quot; action=&quot;#&quot; target=&quot;_blank&quot; onsubmit=&quot;return checkRegisterForm()&quot;&gt; &lt;span style=&quot;line-height: 40px;&quot;&gt; &lt;p id=&quot;test-error&quot; style=&quot;color:red&quot;&gt;&lt;/p&gt; &lt;p&gt; choose wallet file: &lt;input type = &apos;file&apos; name = &apos;file&apos; id = &apos;walletfile&apos;/&gt;&lt;br&gt; password: &lt;input type=&apos;text&apos; id=&apos;password&apos; name=&apos;password&apos;&gt;&lt;br&gt; &lt;button type = &apos;button&apos; onclick = &apos;authentication()&apos;&gt;Authentication&lt;/button&gt; &lt;hr&gt; &lt;/p&gt; &lt;p&gt; choose evidence file: &lt;input type = &apos;file&apos; name = &apos;file&apos; id = &apos;evidencefile&apos;/&gt;&lt;br&gt; &lt;button type = &apos;button&apos; onclick = &apos;getEvidence()&apos;&gt;GetEvidence&lt;/button&gt; &lt;input type=&apos;text&apos; id=&apos;getEvidenceOutput&apos; name=&apos;getEvidenceOutput&apos; size=&apos;100&apos;&gt; &lt;br&gt; &lt;button type = &apos;button&apos; onclick = &apos;saveEvidence()&apos;&gt;SaveEvidence&lt;/button&gt; &lt;input type=&apos;text&apos; id=&apos;saveEvidenceOutput&apos; name=&apos;saveEvidenceOutput&apos; size=&apos;100&apos;&gt; &lt;hr&gt; &lt;/p&gt; &lt;p&gt; &lt;button type = &apos;button&apos; onclick = &apos;getUsers()&apos;&gt;GetAllUsers&lt;/button&gt; &lt;/p&gt; &lt;p&gt; &lt;button type = &apos;button&apos; onclick = &apos;test()&apos;&gt;test&lt;/button&gt; &lt;/p&gt; &lt;/span&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; main.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122const infuraAddress = &quot;https://rinkeby.infura.io/v3/2f85c22a29994320b52da33bec96968d&quot;;let Web3 = require(&apos;web3&apos;);if(typeof web3 !== &apos;undefined&apos;) &#123; web3 = new Web3(web3.currentProvider);&#125; else &#123; web3 = new Web3(new Web3.providers.HttpProvider(infuraAddress));&#125;let abi = [&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;getUsers&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;users&quot;,&quot;type&quot;:&quot;address[]&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;userList&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[&#123;&quot;name&quot;:&quot;fileHash&quot;,&quot;type&quot;:&quot;bytes&quot;&#125;],&quot;name&quot;:&quot;getEvidence&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;code&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;,&#123;&quot;name&quot;:&quot;fHash&quot;,&quot;type&quot;:&quot;bytes&quot;&#125;,&#123;&quot;name&quot;:&quot;fUpLoadTime&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;,&#123;&quot;name&quot;:&quot;saverAddress&quot;,&quot;type&quot;:&quot;address&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;constant&quot;:false,&quot;inputs&quot;:[&#123;&quot;name&quot;:&quot;fileHash&quot;,&quot;type&quot;:&quot;bytes&quot;&#125;,&#123;&quot;name&quot;:&quot;fileUploadTime&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;saveEvidence&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;code&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;];let address = &quot;0x5b11477f2f8b1efaf46b60044e5d51e37a6fc76c&quot;;let contract = new web3.eth.Contract(abi, address);//==============================================================================================function authentication() &#123; let password = document.getElementById(&apos;password&apos;); let passwordVal = password.value; let walletFile = document.getElementById(&apos;walletfile&apos;); let myWallet = walletFile.files[0]; let reader = new FileReader(); let walletDecrypted; reader.onload = function(e) &#123; let walletBuffer = e.target.result; let walletJson = JSON.parse(walletBuffer); let wallets = new Array(walletJson); try &#123; walletDecrypted = web3.eth.accounts.wallet.decrypt(wallets, passwordVal); alert(&apos;Authentication success&apos;); &#125; catch(e) &#123; alert(&apos;Error: please try again&apos;); &#125; let privateKey = walletDecrypted[0].privateKey; //alert(privateKey); &#125; reader.readAsBinaryString(myWallet); &#125;function getUsers() &#123; contract.methods.getUsers().call(&#123;from: &apos;1062024529684b1890b2fa5964334d8db7da2512&apos;&#125;, function(err, res) &#123; if(err) &#123; alert(err); &#125; else &#123; alert(res); &#125; &#125;);&#125;function getEvidence() &#123; let walletFile = document.getElementById(&apos;evidencefile&apos;); let myWallet = walletFile.files[0]; let reader = new FileReader(); reader.onload = function(e) &#123; let fileSource = e.target.result; let crypto = require(&apos;crypto&apos;); let md5Hash = crypto.createHash(&apos;md5&apos;); md5Hash.update(fileSource); let digest = md5Hash.digest(&apos;hex&apos;); digest = &apos;0x&apos; + digest; alert(digest); // callback funciton can not return the result contract.methods.getEvidence(digest).call(&#123;from: &apos;1062024529684b1890b2fa5964334d8db7da2512&apos;&#125;, function(err, res) &#123; if(err) &#123; alert(&apos;aaaaaa&apos;); alert(JSON.stringify(err)); &#125; else &#123; let evidenceOutput = document.getElementById(&apos;getEvidenceOutput&apos;); let retRes = &apos;&apos;; if(res.code == &apos;0&apos;)&#123; retRes = &apos;SUCCESS: &apos;; &#125; else &#123; retRes = &apos;FAIL: &apos;; &#125; evidenceOutput.value = retRes + JSON.stringify(res); &#125; &#125;); &#125; reader.readAsBinaryString(myWallet);&#125;function saveEvidence() &#123; let walletFile = document.getElementById(&apos;evidencefile&apos;); let myWallet = walletFile.files[0]; let reader = new FileReader(); reader.onload = function(e) &#123; let fileSource = e.target.result; let crypto = require(&apos;crypto&apos;); let md5Hash = crypto.createHash(&apos;md5&apos;); md5Hash.update(fileSource); let digest = md5Hash.digest(&apos;hex&apos;); digest = &apos;0x&apos; + digest; //alert(digest); // callback funciton can not return the result contract.methods.saveEvidence(digest, 4444444444).send(&#123; from: &apos;1062024529684b1890b2fa5964334d8db7da2512&apos;, gasPrice: &apos;0x3B9ACA00&apos;, gas: 4000000, &#125;)// .on(&apos;confirmation&apos;, function(confirmationNumber, receipt) &#123;// alert(confirmationNumber);// alert(JSON.stringify(receipt));// &#125;) .on(&apos;receipt&apos;, function(receipt) &#123;// alert(JSON.stringify(receipt)); let saveEvidenceOutput = document.getElementById(&apos;saveEvidenceOutput&apos;); saveEvidenceOutput.value = JSON.stringify(receipt); &#125;) .on(&apos;error&apos;, alert); &#125; reader.readAsBinaryString(myWallet); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP读书笔记]]></title>
    <url>%2FCSAPP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[计算机系统漫游 信息就是位+上下文编写的任何一个程序源代码都是文本文件，文本文件以ASCII码或Unicode编码的形式存在硬盘上。本质上来说，这些文件都是二进制 0 1 序列。这些 0 1 能够表示信息，是通过上下文关系来体现的。 程序被其他程序翻译成不同的格式C语言的源程序要变成可执行程序，要经过一系列的步骤。在linux上通过gcc提供的各种工具将其翻译：gcc -o hello hello.c这就能将hello.c源代码翻译成hello可执行程序，具体经过了 预处理 编译 汇编 链接，如下图 预处理调用预处理器。根据以字符#开头的命令，修改原始C程序。将所有的头文件展开，将所有的宏定义替换，将所有的注释删除，将所有的条件编译不成立的部分删除。 编译调用编译器。将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。-汇编将汇编程序的文本文件翻译成机器语言指令，也就是二进制文件的01序列，把这些指令打包成可重定位目标程序的格式，即hello.o。 链接分析各个目标文件之间的依赖关系，将所有用到的目标文件链接起来，重定位各个目标文件中的全局引用。 系统的硬件组成一个典型的系统硬件组成如下图：主要有总线，I/O设备，主存，处理器， 高速缓存现代计算机的运行时间很大一部分是用在数据传递上，所以在各个部分之间增加缓存很重要，缓存用于存储最近被访问的数据，由于程序的局部性原理，这大大提高的程序的速度。 操作系统管理硬件计算机系统的抽象表示： 进程进程是现代操作系统的一个抽象概念，是对一个正在运行的程序的一种抽象。它让程序看起来独占整个系统资源，包括CPU，内存，IO等。多个进程同时运行在系统上时，操作系统要对进程进行调度，当一个进程切换到另一个进程时，要进行上下文切换。 线程线程是进程中的一个执行控制流。 虚拟内存虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占的使用内存。每个进程看到的内存都是一致的，称为虚拟地址空间，下图是Linux进程的虚拟地址空间 文件在Linux系统上，所有的东西都被抽象为文件，包括普通文件，存储设备，IO，网络套件字等，对这些东西的读写都能通过统一的接口实现，即文件的读写。计算机系统中抽象的重要性所有的问题，都能通过添加一个抽象的中间层解决。 第二章 信息的表示和处理 字节顺序计算机的字节顺序体现在当一个数据需要多个字节存储的时候，这些字节以何种顺序存储。字节顺序分为大端和小端。大端是将高位放在低地址，低位放在高地址，小端相反。大部分系统采用的是小端法， 移位运算当移位的数量k大于数据自身的位数w时，则移动（k%w）位。左移，在右端补0右移，分为算术移位和逻辑移位。对于无符号数都一样，在左端补0。对于有符号数，算术移位补最高位，逻辑移位补0。 整数的表示那些数据类型的长度，都没有记忆的必要，只要记住计算机如何表示有符号数和无符号数就可以了。 无符号数表示就按照二进制的正常位级表示。 1111 -&gt; 8+4+2+1 有符号数最高位表示负的权值，其他的一样。 1111 -&gt; -8+4+2+11000 -&gt; -80101 -&gt; 4+1 有符号数和无符号数的转换相同的长度，保持在位级表示上的一致性。 扩展一个数字的位表示无符号数用 0 扩展，有符合数用符号位扩展。当不同长度的有符号数和无符号数转换时，先转成相同的长度，再进行类型转换。如： short -&gt; unsigned==short -&gt; int -&gt; unsigned 截断数字无符号数，直接截断高位有符号数，先按无符号数直接截断，然后将最高位转为符号位。 无符号数和有符号数加减法记住一条，都按照二进制表示的加法运算，超出表示范围的截断。然后表示对应的无符号数和有符号数。减法转成加法做。主要有符号数是补码表示。 补码的非和正常的数学一样，唯一例外是负数的最大值，非是其本身。 0X80 -&gt; 0X80 乘除法计算机的乘除法都尽量转成加法和移位。 IEEE浮点数表示 第三章 程序的机器级表示前言这一章主要就是讲在汇编层面看程序，介绍了最新的x86-64架构下的指令集，重点是条件，循环，分支的汇编实现，以及函数调用过程。 零碎的点 重要的寄存器 PC寄存器。在x86-64中用%rip表示，给出将要执行的下一条指令在内存中的地址。 16个整数寄存器。分别存储64位的值，这些寄存器可以存储地址或整数数据。 条件码寄存器。都是位存储的标志位，保存最近执行的算术或逻辑指令的状态信息，在条件判断的时候用到。 数据格式 汇编中以字（WORD）为单位，1，2，4，8字节分别用字节（b），字（w），双字（l），四字（q）表示。 寄存器表示 为了向后兼容，同一个寄存器都有多个名称，分别支持1, 2, 4, 8个字节操作，如%al, %ax, %eax, %rax分别表示%rax寄存器的1, 2, 4, 8字节。 指令族为了对应不同数据长度的操作，每种指令都有一个指令集，用于操作不同大小的数据，如MOV有movb, movw, movl, movq表示对1,2,4,8字节的移动。 控制C语言中的if-else, do-while, while, for, switch，本质上都是用jump跳转实现的，当然switch还涉及到跳转表，稍微复杂一点。 基础 CPU中维护着一组单个位的条件码寄存器，他们描述了最近的算术或逻辑操作的属性。常用的条件码有： CF：进位标志。最近的操作使最高位产生了进位。可用来检测无符号数的溢出。 ZF：零标志。最近的操作得出的结果为0. SF：符号标志。最近的操作得到的结果为负数。 OF：溢出标志。最近的操作导致一个补码溢出。 跳转 直接跳转jmp .L1程序会直接跳转到标记为 .L1 的代码段 间接跳转jmp %rax用寄存器%rax中的值作为跳转目标jmp (%rax)用%rax中的值作为读地址，从内存中读出跳转目标。 条件跳转指令集中有很多条件跳转指令，通过判断条件码寄存器中的值进行跳转。跳转地址通常为间接地址，也就是相对于当前PC的偏移，这样程序在链接的时候就不需要改。 if - else 实现简单的实现 1234567891011121314// C++ if (test-expr) then-statement else else-statement// 仿汇编形式 t=test-expr; if(!t) goto fasle; then-statement goto done;false: else-statementdoen: do-while 实现 12345678910111213141516171819202122232425262728293031// C++long fact_do(long n)&#123; long result=1; do &#123; result *= n; n = n -1; &#125; while (n &gt; 1); return result;// 仿汇编long fact_do_goto(long n)&#123; long result = 1;loop: result *= n; n = n - 1; if (n &gt; 1) goto loop; return result;&#125; // 汇编fact_do: movl $1, %eax.L2: imulq %rdi, %rax subq $1, %rdi cmpq $1, %rdi jg .L2 rep; ret while 实现while 的实现和 do-while类似，只不过要在loop前加一次test。 for 实现for 可以直接翻译成 while如： 12for(init-expr; test-expr; update-expr) body-statement 翻译成：12345init-expr;while(test-expr) &#123; body-statement update-expr;&#125; 翻译成伪汇编：123456789101112131415161718192021 init-expr; goto test;loop: body-statement update-expr;test: t=test-expr; if(t) goto loop;// 或者 init-expr; t=test-expr; if(!t) goto done;loop: body-statment update-expr; t=test-expr; if(t) goto loop;done: switchswitch 才是重点switch通过生成一个跳转表，存放各个代码段的入口地址。首先，条件表达式的负数会自动转为对应的无符号数，并减去所有case 的最小值，也就是这张表维护的是从索引 0 到 max-min 之间的所有地址，空的地址是 default（有） 或 switch-case（没有） 的下一句。执行的时候计算条件表达式的值，先判断是否大于索引最大值，是直接跳到最后，不是就加上跳转表的首地址，直接取出对应的代码段的地址（跳转表放在 .rodata 段，目测在目标文件中在 .text 段）。注意，由于跳转只是跳到代码的入口地址，所以代码段中没有break（goto），程序会顺序运行下去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// C 源码void switch_eg(long x, long n, long *dest)&#123; long val = x; switch(n) &#123; case 100: val *= 13; break; case 102: val += 10; case 103: val += 11; break; case 104: case 106: val *= val; break; default: val = 0; &#125; *dest = val;&#125;// C 仿汇编void switch_eg_impl(long x, long n, long *dest)&#123; // gcc 提供了引用代码段指针的功能 static void *jt[7] = &#123; &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B,&amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def, &amp;&amp;loc_D &#125;; unsigned long index = n -100; long val; if(index&gt;6) goto loc_def; goto *jt[index];loc_A: val = x * 13; goto done;loc_B: x = x+10;loc_C: val = x + 11; goto done;loc_D: val = x * x; goto done;loc_def: val = 0;done: *dest = val;&#125;// 汇编// void switch_eg(long x, long n, long *dest)x in %rdi, n in %rsi, dest in %rdxswitch_eg: subq $100, %rsi cmpq $6, %rsi ja .L8 jmp *.L4(, %rsi, 8).L3: leaq (%rdi, %rdi, 2), %rax leaq (%rdi, %rax, 4), %rdi jmp .L2.L5: addq $10, %rdi.L6: addq $11, %rdi jmp .L2.L7: imulq %rdi, %rdi jmp .L2.L8: movl $0, %edi.L2: movq %rdi, (%rdx) ret // 跳转表 .section .rodata .align 8.L4: .quad .L3 .quad .L8 .quad .L5 .quad .L6 .quad .L7 .quad .L8 .quad .L7 subq 过程 概括过程也就是函数调用。过程主要是通过栈帧来实现的。下图是一张栈帧的示意图。过程调用要实现数据的传递，控制的传递。函数传参首先使用的是寄存器，x86-64下寄存其最多可以保存6个参数，超过6个要用栈来传递。过程中使用的局部变量也会首先选择寄存器。在函数调用中，要保持调用者的上下文，包括寄存器值，PC等。 控制传递调用的时候先把调用语句的下一句的地址入栈，然后跳转到被调用者的入口，执行结束以后，将之前保存的地址出栈，赋值给PC。 数据传递传参数首先是用寄存器，最多可以传6个，多于6个的用栈来传。返回值用一个寄存器保存，如果返回值很大，那么传参的时候会多传一个指针，且在栈上多开一块空间保存这个返回值，指针指向这个空间，在被调函数里面构造这块空间，并且将指针保持在寄存器中。 栈上的局部存储局部变量必须存储在栈上的有几种情况：1 寄存器不足够存放所有的本地数据2 对一个局部变量使用地址运算符‘&amp;’，3 数组或结构在栈上分配空间也就是减少栈顶指针的值。 寄存器上的局部存储寄存器是对所有过程共享的。但是过程调用的时候要保证返回时能恢复。所以在过程调用时，寄存器的值要保存起来，一部分是调用者保存的，一部分是被调用者保存的，在过程返回时，要恢复原来的值。 数组对数组元素的引用，就是用指向数组开头的指针加上元素的长度乘以索引。如有数组 int A[N]，访问第 i 个元素，假设A 的地址存在寄存器 a，要取出元素放在寄存器 b，mov (a,i,4) b。 异质的数据结构 结构体和数组的访问类似，用结构的头指针加上各个字段的偏移。这个过程在编译期间完成，所以在汇编中就不保持任何数据结构信息了。 数据对齐在结构体中，任何字段的起始地址都是自己长度的整数倍，数组按单个元素算，且最终的结构体长度要是结构中最大长度的整数倍。 浮点运算浮点数用另外一组有别与整数寄存器的寄存器来保存，传递参数的时候也是用另外的一组寄存器，它的操作类似于整数操作，不过用别的指令。 第七章 链接 编译器驱动程序大多数编译系统提供编译器驱动程序，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。 过程：预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接相应的文件变化：源文件.c -&gt; 中间文件.i -&gt; 可重定位目标文件.o -&gt; 可执行文件 静态链接静态链接将多个目标文件组合起来，形成一个可执行文件，主要完成两个任务： 符号解析将每个符号引用正好和一个符号定义关联起来。 重定位链接其通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 可重定位目标文件典型的ELF格式： 其中几个节的内容： .text：机器代码 .rodata：只读数据，比如字面常量字符串和switch语句的跳转表。 .data：已初始化的全局和静态C变量 .bss：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，仅仅是一个占位符。 .symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。 .rel.text：一个.text节中位置的列表。 .rel.data：被模块引用或定义的所有全局变量的重定位信息。 符号和符号表每个可重定位目标模块 m 都有一个符号表，它包含了 m 定义和引用的符号信息。包括文件内的所有函数，全局变量，带有static的变量，以及引用的外部符号。符号表中的每一项都是一个结构体，表示一个符号的信息。 符号解析编译器在遇到一个不再当前模块定义的引用时，会假设在其他模块定义，会生成一个链接器符号表条目，交给链接器处理，如果链接器在各个模块中没有找到定义，就会报出一条错误，终止。 符号多重定义在编译时，编译器向汇编器输出每个全局符号，或者是强或者是弱，函数和已初始化的全局变量是强，未初始化的全局变量是弱。Linux根据下面的规则处理符号多重定义： 不允许有多个同名的强符号；如果有一个强符合和多个弱符号同名，选择强符号；如果多个弱符号同名，任意选一个。 静态库Linux的静态库是一些 .o 目标文件的集合，文件后缀 .a，在文件中有一个头部来描述每个目标文件的大小和位置。 重定位目标文件合并成可执行文件时，会把各个目标文件的相同的段合并到一起，然后重新定位符号的位置，对于符号的引用，通过编译时产生的重定位表条目来确定。 可执行那个目标文件格式： 加载当在shell中运行一个可执行程序，首先调用fork复制一个子进程，然后调用execve将虚拟内存空间中的东西删除，创建新的内存段，做好内存映射，然后将控制转移到_start地址执行。 动态链接（这部分没看懂）直接看这个吧：http://ybin.cc/compiler/position-independent-code-in-shared-library/ 动态链接库后缀为 .so ，使用了位置无关代码技术（PIC）。 PIC数据引用数据和代码的相对位置是一定的，所以可以通过代码的偏移量来确定数据的位置。 PIC函数调用延迟绑定。用一个表保持各个函数的地址，出 打桩感觉有点像windows的钩子。改变程序中调用的入口，从而改变程序应有的执行流。 异常控制流 异常异常就是控制流中的突变，用来响应处理器中的某写变化。事件就是处理器的状态发生了变化。当处理器检测到有事件发生，就会通过一张叫做异常表的跳转表，进行一个间接过程调用，到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序）。操作系统启动的时候，会产生一张异常表，里面的每个条目对应一个异常处理程序的地址。异常处理工作在内核模式下。 异常类别异常可分为：中断、陷阱、故障、终止。 中断中断是异步发生的，来自处理器外部的I/O设备的信号的结果。I/O设备向处理器芯片的一个引脚发信号，并将异常号放到系统总线上，来触发中断。其他的异常类型是同步发生的，是执行当前指令的结果。 陷阱和系统调用陷阱是有意的异常，是执行一条指令的结果，典型应用是 系统调用。比如读一个文件，首先产生系统调用，进入异常处理程序，在这个程序中再查询系统调用表，调用对应的内核函数。 故障故障由错误引起，从异常处理返回时，回到原指令继续执行（或退出），典型的就是缺页。 终止是不可恢复的致命错误造成的。 进程一个逻辑流的执行在时间上与另一个流重叠，称为并发流。 操作系统分为用户模式和内核模式。内核模式享有特权，能执行访问所有的数据和代码。模式是用一个控制寄存器保存的，只有内核态的代码能够修改。用户态可以通过系统调用、故障、中断等进入内核态。 进程控制从程序员的角度，进程总是处于三种状态：运行，停止，终止。fork函数调用一次，返回两次，在父进程中返回子进程id，在子进程中返回0。fork建立的子进程几乎但不完全与父进程相同，他们拥有相同的虚拟地址空间，除了部分内核态的东西不同。通过写时复制，直到要改变内存的时候才进行复制。 子进程由于某种原因终止时，内核并不会立即清除它，而是保持成僵死进程，必须要有父进程回收。若父进程已死，则统一变成init进程的子进程。 execve函数在当前进程的上下文中加载并运行一个新进程，execve调用一次，返回0 次。它把当前进程的环境删除，映射新的进程。 信号信号允许进程和内核中断其他进程内核会检测进程的未被阻塞的待处理信号的集合，如果是空，继续执行，非空，选择一个信号，内核强制进程接受信号。 第九章 虚拟内存 页表进程启动时，操作系统都会为进程建立一个页表，主要是虚拟内存到硬盘对应位置的映射关系。下图是页表示意图：有效位为1表示已分配，0表示未分配。地址要么表示物理页号，要么表示磁盘地址。 当CPU需要的地址不再页表中，会触发缺页异常，调用异常处理程序，通过系统的调度，把需要的页映射到内存，然后重新来一次。 这几章的内容都不是很理解，所有就简单的记一下 共享文件内核用三个相关的数据结构来表示打开的文件：描述符表、文件表、v-node表。 每个进程都有它独立的描述符表，它的表项由进程打开的文件描述符来索引，每个打开的描述符表项指向文件表中的一个表项。如标准输入、输出、错误分别是0，1，2. 打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成包括当前的文件位置、引用计数，以及一个指向v-node表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。当引用计数变为0,内核会删除这个表项。 所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息。 I/O重定向，假如将标准输出定向到一个打开的文件4，那么就是将描述符表中索引为4的内容复制到索引为1的内容。 网络编程]]></content>
  </entry>
  <entry>
    <title><![CDATA[effective_c++读书笔记]]></title>
    <url>%2Feffective_c%2B%2B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[条款1：视C++为一个语言联邦C++是一个庞大复杂的语言，它看上去更像是多个语言的联合，所以可以将它分为几个次语言： C Object-Oriented C++ Template C++ STL 每个部分都有自己的规约，用什么规则取决于用哪部分。 条款2：尽量以const, enum, inline 替换 #define#define 是在预处理阶段完成的，预处理器只是将define的部分以字符的形式替换掉代码的内容，所以在编译期间是看不到define的东西的，这对于调试很不好。enum申明常量，很有意思。 条款3：尽可能使用const声明类的时候，能用const的地方都尽量加上去。 条款4：确定对象被使用前已先被初始化这条很明显，能避免很多错误。全局对象的初始化，在主函数执行之前。尽量在初始化列表中对所有成员进行初始化。类中的const 和 reference 成员必须在初始化列表中进行初始化。类中成员的初始化顺序就是声明的顺序，和初始化列表的顺序咩有关系。C++中，存在全局区的数据（global, static）的初始化和C有点不一样。non-local（全局，类中）的对象在main函数之前初始化，但不同编译单元之间的顺序无法确定。local（函数内的）的对象在首次遇到该对象的定义式时进行初始化，之后在遇到直接跳过初始化。（通过在对象内存的前后加一个标记来表示）。所以尽量避免使用non-local的全局对象，更好的方式是包装一个函数，使其变成local的，这样能保证它的初始化时间。C中，存在全局区的数据都是在main函数之前初始化的。 条款5：了解C++默默编写并调用哪些函数对象的成员变量是在构造函数执行前完成的，也就是通过初始化列表完成的，在函数体内的只能叫赋值，不是初始化。这也是为什么如果类中存在没有默认构造函数的成员时，一定要在初始化列表中完成初始化，const 成员也是一样的道理，因为 const 成员不能修改，所有在构造函数中赋值是非法的。另外，完成基类的构造也应该在初始化列表中。 编译器生成的4个默认函数都是 public 且 inline 的，而且只有在这些函数被需要（被调用）它们才会被编译器创建出来。也就是当你没有声明他们，且某个模块又调用了她们的时候。什么叫被需要才创建呢？也就是如果没有地方调用他们，他们是不存在的，只有调用了，才在调用的地方产生一个 inline，这也是为什么是 inline 的原因。 默认的析构函数是 non-virtual 的，除非这个 class 的 base class 自身申明有 virtual 析构函数，那么它会继承 base 的虚属性。 编译器并不是什么情况下都会产生默认的函数。特别是 copy assignment ，当类中含有引用成员或const 成员时，编译器拒绝产生 copy assignment。对于构造函数，如果类中的成员或基类没有默认的构造函数，当前类也不会产生默认构造函数。还有一点，对于在基类中被限定为 private 的函数，在派生类中都不会产生默认的对应函数，因为默认函数的要调用基类对应的函数。 条款6：若不想使用编译器自动生成的函数，就该明确拒绝对于 copy constructor 和 copy assignment ，如果不想类被复制，可以将这两个函数声明为 private，且不需要实现，因为有申明就能通过编译，而找到具体的实现，是在链接阶段的事情，如果不调用，就不用去找它。当然，这种方法对于类别调用和 friend 会失效。 另外，还有一种方法，让当前类继承一个基类，这个基类是空类，只有两个private 的拷贝构造和赋值，这种方法对于内部调用和friend一样有效。因为编译器生成版的函数会调用基类对应的兄弟。 条款7：为多态基类声明virtual析构函数当需要多态时，基类的析构函数必须为 virtual，如果不是，在多态情况下，用基类指针调用析构，调用的是基类的析构，只能释放基类那一部分的数据，派生类那一部分的成员都没有处理。 另一方面，如果一个类确定不用作多态，那就不要声明 virtual，节约空间。 纯虚析构也需要实现。其他的纯虚不实现，是因为永远不可能调用到（因为类不能实例化），但是析构会被派生类的析构调用。 条款8：别让异常逃离析构函数从语法上，构造和析构都能抛异常，但析构会有问题，构造不会有问题。 创建对象分两步：分配内存和调用构造函数。若分配内存出错，默认会抛出bad_alloc异常；若在调用构造函数时抛出异常，会在 new 的过程中清理掉相应的内存。 析构抛出异常，会导致出错的地方以后的代码无法执行，也就是析构没有执行完，程序会直接跳到对应的异常处理程序的地方。解决的办法是在析构内部解决掉异常，要么终止程序，要么忽略异常。另一个办法是将可能出现异常的部分写成接口，让用户自己来处理，不要放在析构里面做。 条款9：绝不在构造和析构过程中调用 virtual 函数这个问题体现在有继承关系的多态情况下。当一个派生类构造时，是先构造基类的部分，也就是先调用基类的构造函数，此时构造了基类的部分，它是一个基类，而不是派生类，包括虚表指针，所以在构造函数里面的虚函数执行的是基类的函数，而不可能是派生类的。如果是在一般的函数中调用，那么派生类的虚表指针指向的是自己的虚表，所以执行的是自己的函数。同理，析构也是一样的，先析构子类的部分，当到基类时，对象已经变成一个基类，所以只能执行基类的函数。 条款10：令operator=返回一个reference to *this这个好理解，为了连续的赋值。（当然，这条也适用于 +=-=*=等带有赋值性质的操作符）另外，连续赋值的执行是从右向左的，赋值表达式的值等于左值。 条款11：在operator= 中处理“自我赋值”主要是担心自己赋值给自己时，先把自己删除了，导致为定义的行为。 一个比较安全的写法是这样的：1234567Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* pOrig=pb; // pb是类 Widget 的一个成员，指向Bitmap的一个指针 pb=new Bitmap(*rhs.pb); // 这个代码就是在删除前，将原来的保存起来，既 delete pOrig; // 保证了不会删除自己，也保证了 new 的异常安全 return *this;&#125; 当然，合理的写法还有很多，记住不要在赋值之前把自己给删除了。 条款12：复制对象时勿忘其每一个成分写 copy constructor 和 copy assignment 时，确保复制“对象内的所有成员变量”及“所有base class 成员”，调用基类对应的兄弟。 资源，最常用的就是内存，其他的包括文件描述符，互斥锁，数据库连接，sockets。为保证申请资源后，能合理释放，最好用对象来管理资源。现代C++不应该在代码中显式出现new, delete。 条款13：以对象管理资源 获得资源后立即放进管理对象（资源获取即初始化-RAII） 管理对象运用析构函数确保资源被释放 C++11提供了三个智能指针，unique_ptr, shared_ptr, weak_ptr。unique只能通过移动语义来转移控制，不能有多个指针指向同一个对象。shared_ptr使用引用计数，在内部通过一个计数类（代理模式）去记录有多少对象指向同一个资源，当计数为0时，删除资源。shared_ptr有一个陷阱：循环引用，自己指向自己。weak_ptr是shared_ptr的一个弱实现，不能增加和减少计数，需要转换成shared_ptr才能用。 条件14：在资源管理类中小心coping 行为 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。 普遍而常见的RAII class copying 行为是：抑制copying，施行引用计数。 条款15：在资源管理类中提供对原始资源的访问因为在某些情况下，要使用原始接口，所以只能使用原始资源。 条款16：成对使用new和delete时要采取相同形式删除数组和单一数据时要统一 条款17：以独立语句将newed对象置入智能指针以独立语句将newed对象存储于智能指针内。如果不这样做，一旦异常抛出，有可能导致难以察觉的资源泄漏。 让接口容易被正确使用，不容易被误用。 条款18：让接口容易被正确使用，不容易被误用促进正确使用的办法包括接口的一致性，以及与内置类型的行为兼容。阻止误用的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。 这部分没实际经验没办法理解。 条款19：设计Class犹如设计type无法理解 条款20：宁以pass-by-reference-to-const替换pass-by-value引用的底层实现是指针。 用传引用替代传值，可以省去复制产生的开销，以及切割问题。切割，就是传值的时候，将一个实参的派生类传给一个基类的形参，其实是用一个派生类构造了一个基类，在函数中得到的是一个基类，不会出现多态的效果（虚表指针是不在复制范围内的）。示例：错误的写法：123456789101112131415class Window &#123;public: std::string name() const; virtual void display() const;&#125;;class WindowWithScrollBars: public Window &#123;public: virtual void display() const;&#125;;void printNameAndDisplay(Window w)&#123; std::cout&lt;&lt;w.name(); w.display(); //这里调用的是基类的函数&#125; 正确的写法：12345void printNameAndDisplay(const Window&amp; w)&#123; std::cout&lt;&lt;w.name(); w.display();&#125; 对于内置类型，STL的迭代器和函数对象，传值更好。 条款21：必须返回对象时，别妄想返回其reference绝不要返回pointer或reference指向一个local stack对象（函数返回时就被析构），或返回reference指向一个heap-allocated对象（一旦没有用变量接这个引用，就会造成内存泄漏），或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象（对个对象是同一个对象）。 条款22：将成员变量声明为privateprotected和public的封装性一样差。封装性与改变一个属性需要改变的代码量成反比。 条款23：宁用non-member non-friend函数替换member函数提高封装性，使性能单一。个人认为，一个类如何设计接口，很多时候是凭一个程序员的直觉，真没有固定的定律。 条款24：若所有参数皆需类型转换，请为此采用non-member函数如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。考虑运算符重载。 条款25：考虑写出一个不抛异常的swap函数没看懂。 条款26：尽可能延后变量定义式的出现时间直到要用的时候再定义，减少不必要的构造和析构。循环内的定义尽量写在循环内。 条款27：尽量少做转型动作C++ 的四种转型： const_cast：通常被用来将对象的常量性转除。它也是唯一有此能力的C++-style转型操作符。主要用于去掉 const，volatile dynamic_cast：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。主要用于多态下的基类转向派生类，运行时进行类型检查 reinterpret_cast：意图执行低级转型，实际动作（及结果）可能取决于编译器，这也就表示它不可移植。例如将一个pointer to int 转型为一个int 。二进制层面的转换，就是将二进制重新解释。 static_cast：用来强迫隐式转换，例如将non-const对象转为const对象，或将int 转为double等等。它也可以用来执行上述多种转换的反向转换，例如将void* 指针转为typed指针，将pointer-to-base 转为pointer-to-derived。功能类似于C 风格的转换，在兼容类型直接，不进行运行检查。 类型转换的时候会产生一些额外代码。特别是多态时，有多继承的时候，子类指针转成父类的时候，会有一个偏移。 尽量避免使用dynamic，效率太低。 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放进他们自己的代码内。 条款28：避免返回handles指向对象内部成分避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const。 条款29：为“异常安全”而努力是值得的异常安全，使用对象来管理资源copy-and-swap 条款30：透彻了解inlining的里里外外inline 可能会导致代码膨胀inline不是强制命令，只是对编译器的申请将函数定义在class内，就是隐式的申请为inline，这里friend也有同样的效果inline函数通常一定要被置于头文件内，因为在编译过程要替换。template通常也被置于头文件内，因为一旦被使用，编译器为了将它具现，需要知道它张什么样子编译器会拒绝几种情况下的inline申请：函数内带有循环和递归、virtual函数（因为在运行期才能确定调用那个函数）当你对一个已经inline的函数取地址时，编译器还会生成一个非inline的函数为了C++的安全，编译器会在构造和析构里面加入很多代码，取决于具体的类，所以将构造申明为inline可能不是一个好的选择。inline的缺点：增加代码量，无法调试，修改就需要重新编译整个项目 条款31：将文件间的编译依存关系降至最低支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes尽量用声明，而不是定义。 条款32：确定你的public继承塑模出is-a关系以C++进行面向对象编程，最重要的一个规则是：public inheritance（公开继承）意味”is-a”（是一种）的关系。 “public继承”意味is-a。适用于base classes身上的每一件事情一定也适用于derived clases身上，因为每一个derived class对象也都是一个base class对象。 条款33：避免遮掩继承而来的名称 derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。 为了让被遮掩的名称再见天日，可使用using声明式或转交函数。 C++的名称查找规则是从局部一层层往外找的。如果在派生类中有和基类同名的函数，那么会遮掩基类中所有这个名字函数的重载，无关参数，无关类型，无关virtual，只在名称在查找。要想调用基类的函数，必须显式调用。 条款34：区分接口继承和实现继承pure函数也可以提供定义，在派生类中被调用。其意义在于提供接口，同时提供一个默认实现。pure virtual函数的继承只是继承了接口，在派生类中要实现，但是实现可以调用基类提供的默认实现（Base::virtualFun()）。这点不同于virtual函数，virtual函数提供了接口，也提供了默认实现，允许派生类重写实现。non-virtual的函数提供了一份强制实现，在派生类中不应该重写non-virtual函数。它表示所有派生类都支持的相同的实现。 条款35：考虑virtual函数以外的其他选择当你为解决问题而寻找某个设计方法时，不妨考虑virtual函数的替代方案： 使用non-virtual interface(NVI)手法，那是Template Method设计模式的一种特殊形式。它以public non-virutal成员函数包裹较低访问性的virtual函数。 将virutal函数替换为“函数指针成员变量”，这是Strategy设计模式的一种分解表现形式。 以std::function成员变量替换virtual函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是Strategy设计模式的某种形式。 将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Straregy设计模式的传统实现手法。 条款36：绝不重新定义继承而来的non-virtual函数如题，真理。 条款37：绝不重新定义继承而来的缺省参数值绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数–你唯一应该覆写的东西–却是动态绑定。不懂没关系，真用到的时候在回头看书。 条款38：通过复合塑模出has-a或“根据某物实现出” 复合的意义和public继承完全不同 在应用域，复合意味has-a。在实现域，复合意味is-implemented-in-terms-of。 在一个类中包含另一个类。 条款39：明智而审慎地使用private继承 private继承意味is-implemented-in-terms of。它通常比符合的级别低。但是当derived class 需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。 和复合不同，private继承可以造成empty base 最优化。这对致力于”对象尺寸最小化“的程序库开发者而言，可能很重要。 private继承，编译器不会将派生类转为基类。所有基类成员都变成private。 条款40：明智而审慎地使用多重继承 多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化（及赋值）复杂度等成本。如果virutal base classes不带任何数据，将是最具有实现价值的情况（类似Java中的接口继承）。 多重继承的确有正当用途。其中一个情节涉及”public继承某个Interface class“和”private继承某个协助实现的class“的两相组合。 条款41：了解隐式接口和编译器多态模板没有具现化以前，并不知道具体的实现是什么。直到编译的时候才能确定。所以这是一种多态。 条款42：了解typename 的双重意义有嵌套类型名称的时候用。 条款43：学习处理模板化基类的名称在derived class template内通过“this-&gt;”指涉base class template内的成员名称，或借由一个明白写出的”base class资格修饰符”完成。基类有可能特化，所以不一定提供统一的接口，所以派生类中不能直接用基类的接口。 条款44：将与参数无关的代码抽离template不懂 条款45：补充平时我们申请堆内存用的 new 和 delete 是 C++ 的操作符。 new 会被编译器翻译成两部部分：申请内存和构造对象。delete也是两部分：析构和回收内存。 申请内存的函数是 ::operator new(size_t size)，operator new 会申请 size 大小的内存，如果申请不成功，会抛出异常，异常处理程序会 调用一个 new_handler的函数来处理（反复调用），直到没法再申请了会抛出一个 bad_alloc异常。 条款49：了解new-handler的行为在 &lt;new> 中有如下声明：1234namespace std &#123; typedef void (*new_handler) (); new_handler set_new_handler (new_handler P) throw();&#125; new_handler是一个函数指针，下面的函数是设置 operator new 分配失败时要调用的函数。 一个类可以设计它自己的 new_handler。就像这样：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using namespace std;class QQQ &#123; private: class NewHandlerHolder &#123; public: explicit NewHandlerHolder(new_handler nh) : handler(nh) &#123;&#125; ~NewHandlerHolder() &#123; set_new_handler(handler); &#125; private: new_handler handler; &#125;; public: QQQ ()&#123; cout&lt;&lt;&quot;I am constructor\n&quot;; &#125; static std::new_handler set_new_handler(std::new_handler p) throw() &#123; new_handler oldHandler=currentHandler; currentHandler=p; return oldHandler; &#125; static void* operator new(size_t size) throw(std::bad_alloc) &#123; NewHandlerHolder h(std::set_new_handler(currentHandler)); cout&lt;&lt;&quot;This is my new\n&quot;; return ::operator new(size); &#125; private: static std::new_handler currentHandler;&#125;;std::new_handler QQQ::currentHandler=nullptr;void outMem() &#123; cout&lt;&lt;&quot;Memory out of limit\n&quot;;&#125;int main()&#123; QQQ::set_new_handler(outMem); QQQ* qqq=new QQQ; return 0;&#125; 书中的那个代码写得更健壮一些。从代码中可以看出，当类中有 operator new 的时候，编译器就不会去用全局的那个 operator new 了。据说 operator new 还可以重载，只要返回值和第一个参数不变就行。 书中那个模板继承的方式没看懂 条款50：了解new 和delete 的合理替换时机很多时候需要定制程序的new和delete，这里指的应该是 operator new 和 operator delete，因为C++ 规定 new 和 delete 的行为是不能改变的。定制的理由很多，编译器自带的版本因为是一个通用的版本，所以在很多方面性能不佳，具体看书上。 条款51：编写new 和 delete 时需固守常规写 operator new 和 operator delete 是有一定规定的（C++规定）operator new 是内含一个无穷循环，分配内存，如果内存不足，调用 new-handler。它也应该有能力处理 0 bytes 的申请。class专属版本的申请还要考虑有继承的情况，因为往往派生类的对象比基类的对象大。数组的情况也有一些特别的地方，比如要用一定的空间来保持数组大小。 operator delete 应该在收到null指针时不做任何事情。 条款52：写了placement new 也要写placement deletenew 分为两部分，一部分申请空间，一部分构造。在申请空间阶段抛出异常的情况之前说了，那么在构造阶段抛出异常会如何。此时，空间已经申请了，抛出异常，C++的运行环境会去调用和operator new 匹配的operator delete 释放那部分空间。 之所以对应的，是因为operator new 和 operator deete 都可以有多个版本。 正常版本（也就是编译器提供的全局版本）是这样的：123456void* operator new (std::size_t ) throw (std::bad_alloc);void* operator delete(void* rawMemory) throw();除此之外，可以自己实现其他版本，带有其他参数，这样的版本称为 placement new 和 placement delete。在new 的时候要加上其他参数。&lt;new\&gt; 中已经实现了三个: void operaotor new(std::size_t) throw(std::bad_alloc);void operator new(std::size,void) throw();void operaotr new(std::size_t, const std::nothrow_t&amp;) throw();~~~第一个是正常的；第二个是平常一般说的的placement new ，接受一个指针，在指针的地方构造；第三个是兼容老的程序的版本。 声明了一个placement new 就必须要申明一个对应参数的placement delete。因为在发生异常的时候会去找它，找不到就会内存泄漏。但是你自己显式delete的时候，调用的还是正常的那个。 在class中的声明的会覆盖全局的，只要有一个，它就只会来找累里定义的，不会去找全局的。 条款53：不要轻忽编译器的警告 严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉。 不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。 条款54：让自己熟悉包括TR1在内的标准程序库直接看c++11的文档更好。 条款55：让自己熟悉Boostboost]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode部分解题思路]]></title>
    <url>%2Fleetcode%E9%83%A8%E5%88%86%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[此文件用于保持一些算法题，都是以前做过但没有掌握的，主要来源于leetcode，但不限于此。 leetcode-3descriptionGiven a string, find the length of the longest substring withou repeating characters. idea对于子字符串的问题都有一个统一的模型，用一个256长度的数组保存出现的字符的个数，用两个指针指示子串的头和尾，移动后指针并记录出现的字符，当map 中对应的值大于1时，出现重复，比较当前长度和最大长度，这时移动前指针，重复以上过程。 codeint lengthOfLongestSubstring(string s) { int size=s.size(); if(size==0) return 0; vector&lt;int&gt; map(256,0); int front=0,back=0; int maxLen=0; int curLen=0; while(back&lt;size) { if(map[s[back]]==0) { map[s[back]]+=1; curLen+=1; back++; } else { maxLen=curLen&gt;maxLen?curLen:maxLen; while(s[front]!=s[back]) { map[s[front]]-=1; front++; } map[s[front]]-=1; front++; curLen=back-front; } } return max(maxLen,size-front); } leetcode-4描述There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 想法题目要求时间复杂度是lgN，那么只能考虑二分法。对于两个数组，比较k/2位置上的值，如果数组1中的key1大于数组2中的key2，所求的值不可能在key2之前的数中，故接下来可以在数组1和数组2key2之后的数中查找第（k - key2）大的数（因为已经去掉了key2个小的数）。同理，另外一边也一样。递归，直到k = 1或数组长度为0。要注意很多边界条件。 实现1234567891011121314151617181920212223double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1=nums1.size(); int len2=nums2.size(); if((len1+len2) &amp; 0x01) &#123; return findKth(nums1, 0, nums2, 0, (len1+len2)/2+1); &#125; else return (findKth(nums1, 0, nums2, 0, (len1+len2)/2) + findKth(nums1, 0, nums2, 0, (len1+len2)/2+1))/2.0;&#125;int findKth(vector&lt;int&gt;&amp; nums1, int start1, vector&lt;int&gt;&amp; nums2, int start2, int k) &#123; int len1=nums1.size()-start1; int len2=nums2.size()-start2; if(len1&gt;len2) return findKth(nums2, start2, nums1, start1, k); if(len1==0) return nums2[k-1]; if(k==1) return min(nums1[start1], nums2[start2]); int k1=min(len1, k/2); int k2=k-k1; if(nums1[start1+k1-1] &gt; nums2[start2+k2-1]) return findKth(nums1, start1, nums2, start2+k2, k-k2); else if(nums1[start1+k1-1] &lt; nums2[start2+k2-1]) return findKth(nums1, start1+k1, nums2, start2, k-k1); else return nums1[k1-1];&#125; 联想 - top K有大量整数，求出其中的前K个最大的数（最小的也是一样的原理）。 最大用最小堆，最小用最大堆。leetcode - 5 longest Palindromic substringdescriptionGiven a string s, find the longest palindromic substring in s. idea 最直观的想法：遍历字符串，往两边对称扩展，注意分奇数和偶数的情况。 动态规划：dp[i][j]保持区间[i,j]之间的字符是否为回文。dp[i][j] = s[i]==s[j] &amp;&amp; dp[i+1][j-1] 马拉车算法。 code12345678910111213141516171819202122232425262728string longestPalindrome(string s) &#123; string sub=""; for(int i=0;i&lt;s.size();++i) &#123; string tmp; size_t head=i-1,tail=i+1; while(head&gt;=0&amp;&amp;tail&lt;=s.size()-1&amp;&amp;s[head]==s[tail]) &#123; head--,tail++; &#125; tmp=s.substr(head+1,tail-head-1); if(tmp.size()&gt;sub.size()) sub=tmp; if(i+1&lt;s.size()&amp;&amp;s[i]==s[i+1]) &#123; tmp=s.substr(i,2); head=i,tail=i+1; &#125; while(head&gt;=0&amp;&amp;tail&lt;=s.size()-1&amp;&amp;s[head]==s[tail]) &#123; head--,tail++; &#125; tmp=s.substr(head+1,tail-head-1); if(tmp.size()&gt;sub.size()) sub=tmp; &#125; return sub; 123456789101112131415161718192021222324public static void longestPalindrome (String str) &#123; int n = str.length(),left = 0,len=0; int dp[][] = new int[n][n]; for(int i = 0;i &lt; n; i++) &#123; dp[i][i] = 1; &#125; //第一遍搜索下标：00 11 22 33 //第二遍搜索下标：01 12 23 34 //第三遍搜索下标：02 13 24 35 for(int j = 0;j &lt; n; j++) &#123;//j代表下标相隔的距离大小 for(int i = 0 ;i + j &lt; n; i++)&#123; //j索引从i开始，因为要对len进行赋值 if( str.charAt(i) == str.charAt(i+j) )&#123; if(j&lt;2 || dp[i + 1][i + j - 1] == 1 ) &#123; dp[i][i+j] = 1; &#125; &#125; if(dp[i][i+j] ==1 &amp;&amp; len &lt; j+1) &#123; len = j+1; left = i; &#125; &#125; &#125; System.out.println(str.substring(left, left + len));&#125; leetcode - 8 string to intdescription实现atoi idea没什么难度，就是很烦，一个个判断，注意int能表示的范围 code12345678910111213141516171819202122232425262728293031323334353637int myAtoi(string str) &#123; if(str==&quot;&quot;) return 0; int p=-1; int res=0; bool sign=true; while(str[++p]==&apos; &apos;); if(str[p]==&apos;+&apos;) &#123; sign=true; p++; &#125; else if(str[p]==&apos;-&apos;) &#123; sign=false; p++; &#125; while(p&lt;str.size()) &#123; if(str[p]&gt;=&apos;0&apos; &amp;&amp; str[p]&lt;=&apos;9&apos;) &#123; int tmp=str[p]-&apos;0&apos;; if(res &gt; (0x7FFFFFFF-tmp)/10) &#123; if(sign) &#123; res=0x7FFFFFFF; break; &#125; else &#123; res=0x80000000; break; &#125; &#125; else &#123; res=res*10+tmp; &#125; &#125; else &#123; break; &#125; p++; &#125; if(res==0) return 0; return sign ? res : -res;&#125; leetcode - 10 regular expression matching描述正则匹配，’.’代表任意字符，’*‘表示任意个前面的字符 idea这个题有毒，头都炸了 code123456789101112131415bool isMatch(string s, string p) &#123; if (p.empty()) return s.empty(); if (p.size() == 1) &#123; return (s.size() == 1 &amp;&amp; (s[0] == p[0] || p[0] == &apos;.&apos;)); &#125; if (p[1] != &apos;*&apos;) &#123; if (s.empty()) return false; return (s[0] == p[0] || p[0] == &apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125; while (!s.empty() &amp;&amp; (s[0] == p[0] || p[0] == &apos;.&apos;)) &#123; if (isMatch(s, p.substr(2))) return true; s = s.substr(1); &#125; return isMatch(s, p.substr(2));&#125; leetcode - 15 3SumdescriptionGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. idea直接看代码吧，写得还是很清晰的。主要跳过相同的元素。 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; ret; int size = nums.size(); sort(nums.begin(), nums.end()); for(int i = 0; i &lt; size; i ++) &#123; //skip same i while(i &gt; 0 &amp;&amp; i &lt; size &amp;&amp; nums[i] == nums[i-1]) i ++; int j = i + 1; int k = size - 1; while(j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if(sum == 0) &#123; vector&lt;int&gt; cur(3); cur[0] = nums[i]; cur[1] = nums[j]; cur[2] = nums[k]; ret.push_back(cur); j ++; k --; //skip same j while(j &lt; k &amp;&amp; nums[j] == nums[j-1]) j ++; //skip same k while(k &gt; j &amp;&amp; nums[k] == nums[k+1]) k --; &#125; else if(sum &lt; 0) &#123; j ++; //skip same j while(j &lt; k &amp;&amp; nums[j] == nums[j-1]) j ++; &#125; else &#123; k --; //skip same k while(k &gt; j &amp;&amp; nums[k] == nums[k+1]) k --; &#125; &#125; &#125; return ret;&#125; leetcode - 22 Generate ParentnesdescriptionGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. ideaThe idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n &gt;0 and add a right parenthesis if m&gt;0. Append the result and terminate recursive calls when both m and n are zero. code12345678910111213vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; addingpar(res, &quot;&quot;, n, 0); return res;&#125;void addingpar(vector&lt;string&gt; &amp;v, string str, int n, int m)&#123; if(n==0 &amp;&amp; m==0) &#123; v.push_back(str); return; &#125; if(m &gt; 0)&#123; addingpar(v, str+&quot;)&quot;, n, m-1); &#125; if(n &gt; 0)&#123; addingpar(v, str+&quot;(&quot;, n-1, m+1); &#125;&#125; leetcode - 29 Divide Two IntegersdescriptionDivide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. idea可以用移位和加减法。A除以B，就相当于是算A里面有多少个B。 code123456789101112131415161718int divide(int dividend, int divisor) &#123; if(divisor == 0 || ((dividend == 0x80000000) &amp;&amp; (divisor==-1))) return 0x7FFFFFFF; bool sign = (dividend &gt;=0) == (divisor&gt;0); long long dd = labs(dividend); long long d = labs(divisor); int res=0; while(dd &gt;= d) &#123; long long tmp=d; int count=1; while(dd&gt;=tmp) &#123; dd-=tmp; res+=count; tmp&lt;&lt;=1; count&lt;&lt;=1; &#125; &#125; return sign ? res : -res;&#125; leetcode - 30 Substring with Concatenation of All WordsdescriptionYou are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.For example, given:s: “barfoothefoobarman”words: [“foo”, “bar”]You should return the indices: [0,9].(order does not matter). idea用一张hash表保存各个word出现的次数，然后遍历字符串去匹配。算法简单直观，但是时间复杂度高，在leetcode 统计上看到还有一个复杂度更好的方法，但是没看到代码和实现。 code12345678910111213141516171819202122vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;string, int&gt; counts; for (string word : words) counts[word]++; int n = s.length(), num = words.size(), len = words[0].length(); vector&lt;int&gt; indexes; for (int i = 0; i &lt; n - num * len + 1; i++) &#123; unordered_map&lt;string, int&gt; seen; int j = 0; for (; j &lt; num; j++) &#123; string word = s.substr(i + j * len, len); if (counts.find(word) != counts.end()) &#123; seen[word]++; if (seen[word] &gt; counts[word]) break; &#125; else break; &#125; if (j == num) indexes.push_back(i); &#125; return indexes;&#125; leetcode - 31 Next PermutationDescription构造全排列 Idea字典序全排列，这个不会没什么好说的了 code123456789101112131415161718192021222324252627282930void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;int s=nums.size();int tag1=-1,tag2=-1;for(int i=s-2;i&gt;=0;i--)&#123; if(nums[i]&lt;nums[i+1]) &#123; tag1=i; break; &#125;&#125;if(tag1==-1)&#123; sort(nums.begin(),nums.end()); return;&#125;for(int i=s-1;i&gt;0;i--)&#123; if(nums[i]&gt;nums[tag1]) &#123; tag2=i; break; &#125;&#125;int tmp=nums[tag1];nums[tag1]=nums[tag2];nums[tag2]=tmp;sort(nums.begin()+tag1+1,nums.end());&#125; leetcode - 32 Longest Valid ParenthesesdescriptionGiven a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.For “(()”, the longest valid parentheses substring is “()”, which has length = 2.Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4. idea遍历一遍字符串，用一个栈保存索引，若当前字符和栈顶匹配，则出栈，这样最后栈里的元素都是不能匹配的，计算两两之间的距离，就能得到结果。 code12345678910111213141516171819202122232425int longestValidParentheses(string s) &#123; int n = s.length(), longest = 0; stack&lt;int&gt; st; for (int i = 0; i &lt; n; i++) &#123; if (s[i] == &apos;(&apos;) st.push(i); else &#123; if (!st.empty()) &#123; if (s[st.top()] == &apos;(&apos;) st.pop(); else st.push(i); &#125; else st.push(i); &#125; &#125; if (st.empty()) longest = n; else &#123; int a = n, b = 0; while (!st.empty()) &#123; b = st.top(); st.pop(); longest = max(longest, a-b-1); a = b; &#125; longest = max(longest, a); &#125; return longest;&#125; leetcode - 37 Sudoku SolverdescriptionWrite a program to solve a Sudoku puzzle by filling the empty cells.Empty cells are indicated by the character ‘.’.You may assume that there will be only one unique solution. idea典型的深搜的题，不会就别找工作了。 code12345678910111213141516171819202122232425262728293031323334353637bool isValid(vector&lt;vector&lt;char&gt; &gt; &amp;board, int x, int y) &#123; int i, j; for (i = 0; i &lt; 9; i++) if (i != x &amp;&amp; board[i][y] == board[x][y]) return false; for (j = 0; j &lt; 9; j++) if (j != y &amp;&amp; board[x][j] == board[x][y]) return false; for (i = 3 * (x / 3); i &lt; 3 * (x / 3 + 1); i++) for (j = 3 * (y / 3); j &lt; 3 * (y / 3 + 1); j++) if (i != x &amp;&amp; j != y &amp;&amp; board[i][j] == board[x][y]) return false; return true; &#125; bool solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int i=0,j=0; int size=board.size(); for(int i=0;i&lt;size;++i) &#123; for(int j=0;j&lt;size;++j) &#123; if(board[i][j]==&apos;.&apos;) &#123; for(int k=1;k&lt;=9;++k) &#123; board[i][j]=&apos;0&apos;+k; if(isValid(board,i,j) &amp;&amp; solveSudoku(board)) return true; board[i][j]=&apos;.&apos;; &#125; return false; &#125; &#125; &#125; return true;&#125; leetcode - 41 First Missing PositivedescriptionGiven an unsorted integer array, find the first missing positive integer. For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. idea一个长度为 N 的数组，存储从 1 开始的连续整数，最多就是 N 个，如果有 miss的，一定在中间某处。注意：交换的时候，前一个变量已经改变了，所以不能继续用了。 code12345678910111213141516 int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; int i=0; while(i&lt;nums.size()) &#123; if(nums[i]&gt;0 &amp;&amp; nums[i]&lt;=nums.size() &amp;&amp; nums[i]!=nums[nums[i]-1]) &#123; int tmp=nums[i]; nums[i]=nums[tmp-1]; nums[tmp-1]=tmp; &#125; else &#123; i++; &#125; &#125; for(int i=0;i&lt;nums.size();i++) &#123; if(nums[i]!=i+1) return i+1; &#125; return nums.size()+1;&#125; leetcode - 42 Trapping Rain WaterdescriptionGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. idea如果当前的高度比两边的最大高度中较小的一个低，那么就可以装水。 code12345678910111213141516 int trap(vector&lt;int&gt;&amp; height) &#123; int i=0,j=height.size()-1,maxL=0,maxR=0; int res=0; while(i&lt;=j) &#123; if(height[i]&gt;height[j]) &#123; maxR=maxR&gt;height[j]?maxR:height[j]; res+=maxR-height[j]; j--; &#125; else &#123; maxL=maxL&gt;height[i]?maxL:height[i]; res+=maxL-height[i]; i++; &#125; &#125; return res;&#125; leetcode - 44 Wildcard MatchingdescriptionImplement wildcard pattern matching with support for ‘?’ and ‘‘.‘?’ Matches any single character.‘‘ Matches any sequence of characters (including the empty sequence). idea双指针：遇到 × 的时候保留下当前p和s 的位置，先把 × 当0个匹配，遇到不匹配了再回来，把 × 当1个匹配，就这样一直遍历。 动归：遇到 × ，要么匹配0个，要么匹配多个，由于动归的特性，只要往前移一个就可以了。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 双指针 bool isMatch(string s, string p) &#123; int star=-1,sp=0,pp=0,ss=-1; while(sp&lt;s.size()) &#123; if(s[sp]==p[pp] || p[pp]==&apos;?&apos;) &#123; sp++; pp++; &#125; else if(p[pp]==&apos;*&apos;) &#123; star=pp; ss=sp; pp++; &#125; else if(star!=-1) &#123; pp=star+1; sp=++ss; &#125; else return false; &#125; while(pp&lt;p.size()) &#123; if(p[pp]!=&apos;*&apos;) break; pp++; &#125; return pp==p.size(); &#125; //动归 bool isMatch(string s, string p) &#123; int rows = s.size() + 1; int cols = p.size() + 1; vector&lt;vector&lt;bool&gt;&gt; dp(rows, vector&lt;bool&gt;(cols, false)); dp[0][0] = true; for (int i = 1; i &lt; rows; i++)&#123; dp[i][0] = false; &#125; for (int j = 1; j &lt; cols; j++)&#123; if (p[j-1] == &apos;*&apos;) dp[0][j] = dp[0][j-1]; &#125; for (int i = 1; i &lt; rows; i++)&#123; for (int j = 1; j &lt; cols; j++)&#123; if (p[j-1] == s[i-1] || p[j-1] == &apos;?&apos;)&#123; dp[i][j] = dp[i-1][j-1]; &#125; else if (p[j-1] == &apos;*&apos;)&#123; dp[i][j] = dp[i-1][j] || dp[i][j-1]; &#125; &#125; &#125; return dp[rows-1][cols-1]; &#125; leetcode - 50 Pow(x, n)descriptionImplement pow(x, n). idea尽量用移位来解决问题 code123456789101112131415161718 double myPow(double x, int n) &#123; double ans = 1; unsigned long long p; if (n &lt; 0) &#123; p = -n; x = 1 / x; &#125; else &#123; p = n; &#125; // 二进制层面的个数while (p) &#123; if (p &amp; 1) ans *= x; x *= x; p &gt;&gt;= 1;&#125;return ans; &#125; leetcode - 51 N-Queesdescription八皇后问题 idea回溯，穷举 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool isValid(const vector&lt;string&gt;&amp; solu,int r,int c) &#123; int n=solu.size(); // row col for(int i=0;i&lt;n;i++) &#123; if(i!=c &amp;&amp; solu[r][i]==&apos;Q&apos;) return false; if(i!=r &amp;&amp; solu[i][c]==&apos;Q&apos;) return false; &#125; for(int i=r+1,j=c-1;i&lt;n &amp;&amp; j&gt;=0;i++,j--) &#123; if(solu[i][j]==&apos;Q&apos;) return false; &#125; for(int i=r-1,j=c+1;i&gt;=0 &amp;&amp; j&lt;n;i--,j++) &#123; if(solu[i][j]==&apos;Q&apos;) return false; &#125; for(int i=r-1,j=c-1;i&gt;=0 &amp;&amp; j&gt;=0;i--,j--) &#123; if(solu[i][j]==&apos;Q&apos;) return false; &#125; for(int i=r+1,j=c+1;i&lt;n &amp;&amp; j&lt;n;i++,j++) &#123; if(solu[i][j]==&apos;Q&apos;) return false; &#125; return true;&#125;void help(vector&lt;vector&lt;string&gt;&gt;&amp; res,vector&lt;string&gt;&amp; solu,int count) &#123; int n=solu.size(); if(count==n) &#123; res.push_back(solu); return; &#125; for(int j=0;j&lt;n;++j) &#123; if(isValid(solu,count,j)) &#123; solu[count][j]=&apos;Q&apos;; help(res,solu,count+1); solu[count][j]=&apos;.&apos;; &#125; &#125;&#125;vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; solu(n,string(n,&apos;.&apos;)); help(res,solu,0); return res; &#125; ##leetcode - 56 Merge Intervals descriptionGiven a collection of intervals, merge all overlapping intervals.For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. idea按start排序，然后看end是否和start有交叉。 code123456789101112131415161718vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; if(intervals.size()&lt;2) return intervals; sort(intervals.begin(),intervals.end(),[](Interval a,Interval b)-&gt;bool&#123; return a.start&lt;b.start; &#125;); vector&lt;Interval&gt; res; int start=intervals[0].start; int end=intervals[0].end; for(auto in : intervals) &#123; if(in.start&lt;=end) &#123; end=max(end,in.end); &#125; else &#123; res.push_back(Interval(start,end)); start=in.start; end=in.end; &#125; &#125; res.push_back(Interval(start,end)); return res;&#125; leetcode - 71 Simplify PathdescriptionGiven an absolute path for a file (Unix-style), simplify it. For example,path = “/home/“, =&gt; “/home”path = “/a/./b/../../c/“, =&gt; “/c” ideathis code can comment itself. code123456789101112131415161718192021222324252627282930313233string split(string&amp; ori,char t) &#123; string ret(&quot;&quot;); size_t pos=-1; for(size_t i=0;i&lt;ori.size();++i) &#123; if(ori[i]==t) &#123; pos=i; break; &#125; &#125; if(-1==pos) return ret; ret=ori.substr(0,pos); ori=ori.substr(pos+1); return ret;&#125;string simplifyPath(string path) &#123; vector&lt;string&gt; stk; if(path[path.size()-1]!=&apos;/&apos;) path+=&quot;/&quot;; while(!path.empty()) &#123; string str=split(path,&apos;/&apos;); if(str==&quot;&quot; || str==&quot;.&quot;) continue; if(str==&quot;..&quot;) &#123; if(!stk.empty()) stk.pop_back(); &#125; else &#123; stk.push_back(str); &#125; &#125; if(stk.empty()) return &quot;/&quot;; string ret(&quot;&quot;); for(auto s : stk) &#123; ret=ret+&quot;/&quot;+s; &#125; return ret;&#125; leetcode - 72 Edit DistancedescriptionGiven two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: a) Insert a characterb) Delete a characterc) Replace a character idea动态规划，注意转移方程 code12345678910111213141516int minDistance(string word1, string word2) &#123; int len1=word1.size(); int len2=word2.size(); int len=max(len2,len1); int dp[len+1][len+1]; dp[0][0]=0; for(int i=1;i&lt;=len;i++) dp[i][0]=i; for(int i=1;i&lt;=len;i++) dp[0][i]=i; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; if(word1[i] == word2[j]) dp[i+1][j+1]=min(min(dp[i+1][j] + 1, dp[i][j+1] + 1), dp[i][j]); else dp[i+1][j+1]=min(min(dp[i+1][j] + 1, dp[i][j+1] + 1), dp[i][j] + 1); // insert, delete, repalce(equal) &#125; &#125; return dp[len1][len2];&#125; leetcode - 76 Minimun Window SubstringdescriptionGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). For example,S = “ADOBECODEBANC”T = “ABC”Minimum window is “BANC”. idea字符串的题，通常有两个常用伎俩：前后指针，用一个128的map来表示出现的字符的个数 code1234567891011121314151617181920string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128,0); for(auto c : t) map[c]++; int counter=t.size(),begin=0,end=0,d=INT_MAX,head=0; while(end&lt;s.size()) &#123; if(map[s[end]] &gt; 0) counter--; map[s[end]]--; end++; while(counter==0) &#123; if(end-begin &lt; d) &#123; d=end-begin; head=begin; &#125; if(map[s[begin]]==0) counter++; map[s[begin]]++; begin++; &#125; &#125; return d==INT_MAX ? &quot;&quot; : s.substr(head,d);&#125; leetcode - 79 Word SearchdescriptionGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. idea回溯，深搜 code123456789101112131415161718192021222324252627282930313233343536373839404142 bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp;board, string word, int count, int row, int col, vector&lt;vector&lt;int&gt;&gt;&amp;visited) &#123; if (count == word.size() - 1) return true; visited[row][col] = 1;//已经访问 if (row + 1 &lt; board.size() &amp;&amp;visited[row+1][col]==0&amp;&amp; board[row + 1][col] == word[count + 1] ) if (dfs(board, word, count + 1, row + 1, col, visited)) return true; if (row - 1 &gt;= 0 &amp;&amp;visited[row-1][col]==0&amp;&amp; board[row - 1][col] == word[count + 1] ) if (dfs(board, word, count + 1, row - 1, col, visited)) return true; if (col + 1 &lt; board[0].size() &amp;&amp;visited[row][col+1]==0&amp;&amp; board[row][col + 1] == word[count + 1] ) if (dfs(board, word, count + 1, row, col + 1, visited)) return true; if (col - 1 &gt;= 0 &amp;&amp;visited[row][col-1]==0&amp;&amp; board[row][col - 1] == word[count + 1] ) if (dfs(board, word, count + 1, row, col - 1, visited)) return true; visited[row][col] = 0; return false; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (word.size() == 0) return true; int row = board.size(); int col = board[0].size(); vector&lt;vector&lt;int&gt;&gt;visited(row, vector&lt;int&gt;(col)); if (row == 0 || col == 0) return false; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (board[i][j] == word[0]) &#123; if (dfs(board, word, 0, i, j, visited)) return true; &#125; &#125; &#125; return false; &#125; leetcode - 84 Largest Rectangle in Histogram####descriptionGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. idea用一个栈来维护 code12345678910111213141516171819202122232425int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int max_area = 0; heights.push_back(0); int sz = heights.size(); int stack[sz]; stack[0] = heights[0]; int stack_idx = 0; int i = 1; while (stack_idx &gt;= 0 &amp;&amp; i &lt; sz) &#123; if (heights[i] &gt;= stack[stack_idx]) &#123; stack[++stack_idx] = heights[i++]; continue; &#125; while (stack_idx &gt;= 0 &amp;&amp; stack[stack_idx] &gt; heights[i]) &#123; int area = stack[stack_idx] * (i - stack_idx); if (area &gt; max_area) &#123; max_area = area; &#125; stack_idx--; &#125; while (stack_idx &lt; i) &#123; stack[++stack_idx] = heights[i]; &#125; i++; &#125; return max_area;&#125; leetcode - 85 Maximal RectangledescriptionGiven a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. For example, given the following matrix: idea利用84题的思路来解题。 code12345678910111213141516171819202122232425262728293031323334int blues(vector&lt;int&gt; hist) &#123; stack&lt;int&gt; index; int res=0; for(int i=0;i&lt;hist.size();i++) &#123; if(index.empty() || hist[i]&gt;hist[index.top()]) &#123; index.push(i); &#125; else &#123; while(!index.empty() &amp;&amp; hist[index.top()]&gt;hist[i]) &#123; int h=hist[index.top()]; index.pop(); int w=index.empty()?i:i-(index.top()+1); int tmp=h*w; res=max(res,tmp); &#125; index.push(i); &#125; &#125; return res;&#125;int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int h=matrix.size(); if(h==0) return 0; int w=matrix[0].size(); if(w==0) return 0; int res=0; vector&lt;int&gt; hist(w+1,0); for(int i=0;i&lt;h;i++) &#123; for(int j=0;j&lt;w;j++) &#123; hist[j]=(hist[j]+1)*(matrix[i][j]-&apos;0&apos;); &#125; res=max(res,blues(hist)); &#125; return res;&#125; leetcode - 94 Binary Tree Inorder Traversaldescription二叉树的中序遍历 idea递归太简单了，用非递归，同时实现先序和后序。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 中序 vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; nodes; while(!nodes.empty() || root) &#123; while(root) &#123; nodes.push(root); root=root-&gt;left; &#125; TreeNode* x=nodes.top(); nodes.pop(); if(!x) continue; res.push_back(x-&gt;val); root=x-&gt;right; &#125; return res; &#125; // 先序vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; nodes; while(!nodes.empty() || root) &#123; while(root) &#123; res.push_back(root-&gt;val); nodes.push(root-&gt;right); root=root-&gt;left; &#125; TreeNode* x=nodes.top(); nodes.pop(); root=x; &#125;&#125;// 后序// 这段代码是抄的// 后序遍历在决定是否可以输出当前节点的值的时候，// 需要考虑其左右子树是否都完成了遍历。所以需要设置一个 lastVisit 游标。// 若 lastVisit 等于当前考查节点的右子树，表示该节点的左右子树都遍历过了，// 可以输出当前节点。并把 lastVisit 节点设置成当前节点，// 将当前游标节点 node 设置为空，下一轮就可以访问栈顶元素。// 否则，需要接着考虑右子树。// 后续和中序很接近，只是在输出当前节点的时候要判断右子树是否已经完// 成遍历。public static void postorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; treeNodeStack = new Stack&lt;TreeNode&gt;(); TreeNode node = root; TreeNode lastVisit = root; while (node != null || !treeNodeStack.isEmpty()) &#123; while (node != null) &#123; treeNodeStack.push(node); node = node.left; &#125; //查看当前栈顶元素 node = treeNodeStack.peek(); //如果其右子树也为空，或者右子树已经访问 //则可以直接输出当前节点的值 if (node.right == null || node.right == lastVisit) &#123; System.out.print(node.val + " "); treeNodeStack.pop(); lastVisit = node; node = null; &#125; else &#123; //否则，继续遍历右子树 node = node.right; &#125; &#125;&#125; leetcode - 95 Unique Binary Search Tree IIDescriptionGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n.For example,Given n = 3, your program should return all 5 unique BST’s shown below. idea递归，树的题用递归都还挺简单的。 code12345678910111213141516171819202122232425vector&lt;TreeNode*&gt; help(int start,int end) &#123; vector&lt;TreeNode*&gt; res; if(start&gt;end) &#123; res.push_back(nullptr); return res; &#125; for(int i=start;i&lt;=end;i++) &#123; vector&lt;TreeNode*&gt; result_left=help(start,i-1); vector&lt;TreeNode*&gt; result_right=help(i+1,end); for(int j=0;j&lt;result_left.size();j++) &#123; for(int k=0;k&lt;result_right.size();k++) &#123; TreeNode* root=new TreeNode(i); root-&gt;left=result_left[j]; root-&gt;right=result_right[k]; res.push_back(root); &#125; &#125; &#125; return res;&#125;vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(n&lt;=0) return vector&lt;TreeNode*&gt;(); vector&lt;TreeNode*&gt; result=help(1,n); return result;&#125; leetcode - 96 Unique Binary Search TreesDescriptionGiven n, how many structurally unique BST’s (binary search trees) that store values 1…n?For example,Given n = 3, there are a total of 5 unique BST’s. Idea和95类似的题，但是用相同的方法会超时。动归的方法比较好，因为在根节点左右两边的子树的数目只和节点有关，比如[1,2]和[3,4]的数目是一样的。对于任一个节点可以构建的树的数目就是左右子树数目相乘。 code12345678910int numTrees(int n) &#123; vector&lt;int&gt; res(n+1); res[0]=res[1]=1; for(int i=2;i&lt;=n;++i) &#123; for(int j=1;j&lt;=i;++j) &#123; res[i]+=res[j-1]*res[i-j]; &#125; &#125; return res[n];&#125; leetcode - 97 Interleaving StringdescriptionGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example,Given:s1 = “aabcc”,s2 = “dbbca”, When s3 = “aadbbcbcac”, return true.When s3 = “aadbbbaccc”, return false. idea动态规划 code1234567891011121314bool isInterleave(string s1, string s2, string s3) &#123; if(s1.size()+s2.size()!=s3.size()) return false; bool dp[s1.size()+1][s2.size()+1]=&#123;false&#125;; for(size_t i=0;i&lt;s1.size()+1;i++) &#123; for(size_t j=0;j&lt;s2.size()+1;j++) &#123; if(i==0 &amp;&amp; j==0) dp[i][j]=true; else if(i==0) dp[i][j] = (s2[j-1]==s3[i+j-1]) &amp;&amp; (dp[0][j-1]); else if(j==0) dp[i][j]=(s1[i-1]==s3[i+j-1]) &amp;&amp; (dp[i-1][0]); else dp[i][j]=(s1[i-1]==s3[i+j-1] &amp;&amp; dp[i-1][j]) || (s2[j-1]==s3[i+j-1] &amp;&amp; dp[i][j-1]); &#125; &#125; return dp[s1.size()][s2.size()];&#125; leetcode - 115 distinct subsequencesdescriptionGiven a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not). Here is an example:S = “rabbbit”, T = “rabbit” Return 3. ieda动态规划。 code1234567891011121314int numDistinct(string s, string t) &#123; int ss=s.size(); int ts=t.size(); int dp[ss+1][ts+1]; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;=ss;++i) dp[i][0]=1; for(int i=1;i&lt;=ss;++i) &#123; for(int j=1;j&lt;=ts;++j) &#123; if(s[i-1]==t[j-1]) dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; else dp[i][j]=dp[i-1][j]; &#125; &#125; return dp[ss][ts];&#125; leetcode - 123 best time to buy and sell stock IIIdescriptionSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). idea动态规划。保持到当前之前的四个状态，分别是：买了一个，卖了一个，买了两个，卖了两个。然后到当前元素，更新状态，有点像状态机。 code1234567891011121314int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy1,buy2,sell1,sell2; sell2=0; buy2=0x80000000; sell1=0; buy1=0x80000000; for(auto p : prices) &#123; sell2=max(sell2,buy2+p); buy2=max(buy2,sell1-p); sell1=max(sell1,buy1+p); buy1=max(buy1,-p); &#125; return sell2;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Jmeter简单测试]]></title>
    <url>%2FJmeter%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[利用Jmeter工具压测Java Web程序的接口。 启动Jmeter在windows平台上，进入Jmeter安装目录下的bin目录，启动jmeter.bat文件。界面如下图（Jmeter5.0）。 添加测试计划右键TestPlan（可根据具体计划修改名称）-&gt; Add -&gt; Threads(users) -&gt; Thread Group得到如下界面这里用于配置并发请求的参数。具体的参数作用： Number of Threads (users): 同时又多少个线程（模拟用户）向服务端发送请求。 Ramp-Up Period (in second): 这些请求要在多少秒内发送完毕。 Loop Count: 循环次数。将上面设置的并发请求重复多少次，可选择forever让其一直重复。初次使用，其他的配置也没用到。可根据需要修改线程组的名称。 右键线程组名（齿轮）-&gt; Add -&gt; Sampler -&gt; Http Request得到如下界面根据需要修改Name，这里改成login。需要填写的几个参数： Protocol[http]: 请求协议，一般就填http。 Server Name or IP：服务器的地址。 Port Number: 对应的端口。 Method: 请求的方法，一般是Get或Post。 Path: 后端Java接口对应的响应路径，也就是要测的那个接口对应的Servelet配置的映射路径。最下边的参数部分还有请求参数配置（如果请求带有参数）。 右键请求名称（铅笔） -&gt; Add -&gt; Listenser -&gt; View Results Tree/Summary Report这里添加的监听器用于显示测试的结果，不同的选项以不同的方式呈现。这里选View Results Tree和Summary Report。 最后点击工具栏上的运行就能启动测试，Summary Report的结果显示如下： Throughput: 吞吐量 Average: 平均响应时间 Error: 错误率 总结这里只做了最简单的测试，设置好的测试计划在启动时会生成一个.jmx脚本文件，以后可以直接导入使用。很多接口测试都需要带token和认证，文章中没有涉及。]]></content>
      <tags>
        <tag>Jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[忘记mysql密码]]></title>
    <url>%2F%E5%BF%98%E8%AE%B0mysql%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[经常忘记mysql root密码，每次都google，遂记一下。基于mysql5.6，之后版本改动太大，这里的方法不适用。 具体步骤 修改配置文件，在/etc/my.conf中[mysqld]段加入一句skip-grant-tables，使登陆mysql不需要认证。 重启mysql服务器（service mysqld restart） 用匿名用户登陆mysql，并修改root密码。 1234mysql&gt;USE mysql;mysql&gt;update user set Password=password(&apos;new-password&apos;) where user=&apos;root&apos;;mysql&gt;flush privileges;mysql&gt;quit 将my.conf中的skip-grant-tables删除，重启mysql服务器。]]></content>
  </entry>
  <entry>
    <title><![CDATA[以太坊keystore文件解析]]></title>
    <url>%2F%E4%BB%A5%E5%A4%AA%E5%9D%8Akeystore%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[通过以太坊客户端（geth或mist）生成以太坊账户，会在“~/.ethereum/keystore下产生对应于账户的文件，该文件保存了账户相关的信息，如私钥和地址。” 参考https://medium.com/@julien.maffre/what-is-an-ethereum-keystore-file-86c8c5917b97 文件名文件名形式: UTC–&lt;created_date_time&gt;–&lt;地址&gt;如：UTC–2018-07-23T02-30-23.717223803Z–1062024529684b1890b2fa5964334d8db7da2512 文件结构{ &quot;address&quot;:&quot;1062024529684b1890b2fa5964334d8db7da2512&quot; &quot;crypto&quot; : { &quot;cipher&quot; : &quot;aes-128-ctr&quot;, &quot;cipherparams&quot; : { &quot;iv&quot; : &quot;83dbcc02d8ccb40e466191a123791e0e&quot; }, &quot;ciphertext&quot; : &quot;d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c&quot;, &quot;kdf&quot; : &quot;scrypt&quot;, &quot;kdfparams&quot; : { &quot;dklen&quot; : 32, &quot;n&quot; : 262144, &quot;r&quot; : 1, &quot;p&quot; : 8, &quot;salt&quot; : &quot;ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19&quot; }, &quot;mac&quot; : &quot;2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097&quot; }, &quot;id&quot; : &quot;3198bc9c-6672-5ab3-d995-4942343ae5b6&quot;, &quot;version&quot; : 3 } 由用户输入的通行证得到派生keyKey Derivation Function，用户输入的passphrase通过key derivation function得到decryption key, 密钥生成密钥是由客户端产生的，不受用户的控制，keystore中保存的”ciphertext”字段是密钥的密文，密文由密钥通过”cipher”指定的算法和decryption key生成，其中参数是”cipherparams”。 mac的作用以上说的是生成密钥密文的过程。当用户需要得到密钥的时候，通过同样步骤得到decryption key，然后取decryption的一部分和ciphertxt连接，再hash，将结果与mac对比，相同则代表用户输入的通行证是对的。之后再用decryption与ciphertext通过cipher算法解密出私钥明文（对称加密）。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[epoll的运行机制]]></title>
    <url>%2Fepoll%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[epoll原理epoll是Linux系统下一个高效的多路复用IO机制。Linux下，一切皆文件。epoll可对大部分IO操作，以下以socket为例，对epoll机制进行简单解释。用户进程所有的IO都由操作系统统一管理，所有的IO对象（socket，通道，文件等）在内核都对应一个文件描述符，用户只能操作文件描述符，由内核去和具体的IO设备打交道。 系统调用APIlinux有三个系统调用来操作epoll，分别是epoll_create，epoll_ctl，epoll_wait。 1int epoll_create(int size); 这个函数创建一个epoll文件，返回对应的文件描述符，入参没什么用，为了向后兼容，大于0就好。通过这个函数，会在内核中开辟一段高速缓存空间，保存需要监听的socket，以及一个就绪list。 123456789101112typedef union epoll_data &#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; __uint32_t events; epoll_data_t data;&#125;;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这个函数修改fd在epoll中的状态，将这个fd插入/删除/修改到红黑树中，并向内核中断处理程序注册一个回调，当这个fd有事件发生，就向list中插入这个fd。epfd为之前创建的epoll文件描述符，op为注册的操作，fd为需要监听的文件描述符，event为需要监听的事件。op有三个选择： EPOLL_CTL_ADD 添加fd为监听的文件 EPOLL_CTL_MOD 修改fd的监听事件 EPOLL_CTL_DEL 不在监听fd event-&gt;events有7种选择，可通过位或选择多个选项： EPOLLIN fd可读 EPOLLOUT fd可写 EPOLLPRI 有紧急数据可读 EPOLLERR fd发生错误 EPOLLHUP fd被挂断 EPOLLET 将EPOLL 设为ET模式 EPOLLONESHOT 这个fd只监听一次，一次之后将它从监听中删除 event-&gt;data 联合体。设置fd为要监听的对象或设置ptr为要写的数据，其他用法不清楚。 1int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout); 这个函数会启动epoll监听，线程会在这阻塞，直到有被监听的事件发生，函数会检查list中是否有元素，如有，就将所有元素copy到events,并清空list。epfd为epoll的fd, events为为存储返回的所有发生的事件，maxevents为events的大小，timeout为超时限制。返回值为返回的event的个数。timeout为-1表示永久等待，0表示立即返回。 一个服务端监听socket的例子1234567891011121314151617181920212223242526272829for( ; ; )&#123; nfds = epoll_wait(epfd,events,20,500); for(i=0;i&lt;nfds;++i)&#123; if(events[i].data.fd==listenfd)&#123; //如果是主socket的事件，则表示有新的连接 connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); //accept这个连接 ev.data.fd=connfd; ev.events=EPOLLIN|EPOLLET; epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); //将新的fd添加到epoll的监听队列中 &#125; else if( events[i].events&amp;EPOLLIN )&#123; //接收到数据，读socket if ( (sockfd = events[i].data.fd) &lt; 0) continue; n = read(sockfd, line, MAXLINE)) &lt; 0 //读 ev.data.ptr = md; //md为自定义类型，添加数据 ev.events=EPOLLOUT|EPOLLET; epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);//修改标识符，等待下一个循环时发送数据，异步处理的精髓 &#125; else if(events[i].events&amp;EPOLLOUT)&#123; //有数据待发送，写socket struct myepoll_data* md = (myepoll_data*)events[i].data.ptr; //取数据 sockfd = md-&gt;fd; send( sockfd, md-&gt;ptr, strlen((char*)md-&gt;ptr), 0 ); //发送数据 ev.data.fd=sockfd; ev.events=EPOLLIN|EPOLLET; epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); //修改标识符，等待下一个循环时接收数据 &#125; else&#123; //其他情况的处理 &#125; &#125;&#125; 一个监听管道的例子读管道端：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int fifo_fd1, fifo_fd2; int ep_fd; struct epoll_event event; struct epoll_event *ret_events = NULL; int cnt; int i; char c; mkfifo("./fifo1", 0666); mkfifo("./fifo2", 0666); fifo_fd1 = open("./fifo1", O_RDONLY); fifo_fd2 = open("./fifo2", O_RDONLY); /* 需要有进程以只写的方式打开fifo1、fifo2后才能执行于此 */ printf("监测fifo1和fifo2中...\n"); /* 创建epoll池 */ ep_fd = epoll_create1(0); /* 将检测事件加入epoll池中 */ event.events = EPOLLIN | EPOLLET; /* 监测fifo1可读，且以边沿方式触发 */ event.data.fd = fifo_fd1; epoll_ctl(ep_fd, EPOLL_CTL_ADD, fifo_fd1, &amp;event); event.events = EPOLLIN | EPOLLET; /* 监测fifo2可读，且以边沿方式触发 */ event.data.fd = fifo_fd2; epoll_ctl(ep_fd, EPOLL_CTL_ADD, fifo_fd2, &amp;event); /* ret_events用于存放被触发的事件 */ ret_events = malloc(sizeof(struct epoll_event) * 100); /* 阻塞等待监测事件触发 */ cnt = epoll_wait(ep_fd, ret_events, 100, -1); printf("cnt = %d\n", cnt); /* 判断监测事件 */ for (i = 0; i &lt; cnt; i++) &#123; if (ret_events[i].events &amp; EPOLLIN) &#123; read(ret_events[i].data.fd, &amp;c, 1); printf("fd = %d, recv data = %c\n", ret_events[i].data.fd, c); &#125; &#125; free(ret_events); close(ep_fd); /* 注意关闭epoll池的描述符 */ close(fifo_fd2); close(fifo_fd1); return 0;&#125; 写管道1：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int fd; char c; fd = open("./fifo1", O_WRONLY); printf("w1: pls input char: \n"); scanf("%c", &amp;c); write(fd, &amp;c, 1); close(fd); return 0;&#125; 写管道2：1234567891011121314int main(void)&#123; int fd; char c; fd = open("./fifo2", O_WRONLY); printf("w2: pls input char: \n"); scanf("%c", &amp;c); write(fd, &amp;c, 1); close(fd); return 0;&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式简单例子]]></title>
    <url>%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[最近在看《重构》，第一章的例子就用到了State模式来重构一段代码。State模式的结构还笔记好理解，所以就试着写一个简单的例子。 State模式的思想首先有一个抽象的基类State，在其中定义了一些接口。State的派生类实现了这些接口，每个派生类的操作各不同。另外，还有一个类Context，类中有一个成员State，通过这个成员来表示Context所处的状态。Context可以改变不同的状态，从而对外展示出不同的特性。（这里的类名随意取的） 代码State类：1234567891011121314#ifndef TSTATEMODE_STATE_H_#define TSTATEMODE_STATE_H_namespace tstatemode &#123;class State &#123;public: virtual ~State() &#123;&#125;; virtual void Handle() = 0;&#125;;&#125; // namespace tstatemode#endif // TSTATEMODE_STATE_H_ State类中就定义了一个Handle接口。 子类ConcreteState1头文件:12345678910111213141516#ifndef TSTATEMODE_CONCRETE_STATE1_H_#define TSTATEMODE_CONCRETE_STATE1_H_#include &quot;state.h&quot;namespace tstatemode &#123;class ConcreteState1: public State &#123;public: virtual ~ConcreteState1(); virtual void Handle();&#125;;&#125; // namespace tstatemode#endif // TSTATEMODE_CONCRETE_STATE1_H_ 子类ConcreteState1源文件:12345678910111213#include &quot;concrete_state1.h&quot;#include &lt;stdio.h&gt;namespace tstatemode &#123;ConcreteState1::~ConcreteState1() &#123; &#125;void ConcreteState1::Handle() &#123; printf(&quot;ConcreteState1 %s\n&quot;, __FUNCTION__);&#125;&#125; // namespace tstatemode 子类ConcreteState2头文件:12345678910111213141516#ifndef TSTATEMODE_CONCRETE_STATE2_H_#define TSTATEMODE_CONCRETE_STATE2_H_#include &quot;state.h&quot;namespace tstatemode &#123;class ConcreteState2: public State &#123;public: virtual ~ConcreteState2(); virtual void Handle();&#125;;&#125; // namespace tstatemode#endif // TSTATEMODE_CONCRETE_STATE2_H_ 子类ConcreteState2源文件:12345678910111213#include &quot;concrete_state2.h&quot;#include &lt;stdio.h&gt;namespace tstatemode &#123;ConcreteState2::~ConcreteState2() &#123; &#125;void ConcreteState2::Handle() &#123; printf(&quot;ConcreteState2 %s\n&quot;, __FUNCTION__);&#125;&#125; // namespace tstatemode Context类头文件：12345678910111213141516171819#ifndef TSTATEMODE_CONTEXT_H_#define TSTATEMODE_CONTEXT_H_#include &quot;state.h&quot;namespace tstatemode &#123;class Context &#123;public: Context(State* state): state_(state) &#123;&#125; bool ChangeState(State* state); void Display();private: State* state_;&#125;;&#125; // namespace tstatemode#endif // TSTATEMODE_CONTEXT_H_ Context类源文件：123456789101112131415#include &quot;context.h&quot;namespace tstatemode &#123;bool Context::ChangeState(State* state) &#123; if(nullptr != state) state_ = state; return true;&#125;void Context::Display() &#123; if(nullptr != state_) state_-&gt;Handle();&#125;&#125; // namespace tstatemode 主函数：12345678910111213141516171819202122232425#include &quot;context.h&quot;#include &quot;concrete_state1.h&quot;#include &quot;concrete_state2.h&quot;#include &quot;state.h&quot;int main() &#123; namespace tsm = tstatemode; tsm::State* state1 = new tsm::ConcreteState1(); tsm::State* state2 = new tsm::ConcreteState2(); tsm::Context context(state1); context.Display(); context.ChangeState(state2); context.Display(); context.ChangeState(state1); context.Display(); delete state1; delete state2; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称加密]]></title>
    <url>%2F%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[对称加密，就是对同一个文件进行加密和解密用的都是同一个密钥。 CA如何保证合法性非对称加密在网络信息传播中主要有两方面应用：信息加密和数字签名。信息加密的过程主要是： A生成公私钥对，将公钥公开。 B将要发送给A的信息用公钥加密。 A收到密文，用私钥进行解密。这过程中，因为只有A拥有对应的私钥，所以用A的公钥加密的信息，只有A能解密。 数字签名的过程可看成信息加密的逆过程，简单抽象如下： A生成自己的公私钥对，将公钥公开。 A要发送消息时，对消息进行哈希，用私钥对哈希加密，生成签名，将信息和签名一起发出。 收到A发送的信息和签名的接收方，用A的公钥对签名解密，验证信息的哈希和解密出来的哈希，即证明消息的发送方是否是A。 这里存在的问题是，如何保证收到者得到的A的公钥就是A发出来的。解决方法是通过CA（认证机构）来保证。 消息的发送方A将公钥交给CA。 CA生成自己的公私钥，用CA的私钥对A的公钥进行签名，将A的公钥和签名打包成证书。 消息接收方B如果要接受A的消息，就从CA获取A的证书，并用CA的公钥对证书验签，获得A的公钥。 A用私钥进行签名，B用CA证书中的公钥验签。这个过程又存在一个问题，怎么保证CA的公钥就是可信的。这里基于的假设就是CA一定是可信的，不然这会是一个无限递归的问题。 参考：http://www.cnblogs.com/songwenlong/p/6517165.html。文章中简明的概述了加密算法、哈希、数字签名、公钥证书在消息传输中的作用和解决的问题。 DES对称加密算法参考：https://www.cnblogs.com/songwenlong/p/5944139.html。比较详细的介绍。DES是分块加密的，每块数据大小64位，密码也是64位。 IP置换。将64位数据按照设计好的规则换位，再分位左右32位的两部分L0，R0. 密钥置换。密钥每字节取前7位，最后一位作为校验位，总共56位，这56位也按照设定的规则换位，再分成28位的两部分，按照设定的规则向左移位，之后再从这里选择48位。 R0做成4X8的矩阵，分别在两侧补相邻的8位，形成48位。 S盒替代。48位分别通过8个S盒进行坐标映射替换，得到32位。 P盒置换。对S盒输出的32位进行置换，按照预先设定的规则。 IP-1末置换。左右两部分合成，进行置换。 移位、置换、扩展、压缩、异或、迭代]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hyperchain开放入门]]></title>
    <url>%2Fhyperchain%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[hpc.properties配置基于Hyperchain的应用程序需要运行在至少4个节点上，hpc.properties主要用于配置节点信息。hpc.properties主要内容如下： 123456789101112131415161718192021222324252627282930313233343536373839#Hyperchain Nodes IP Ports#node = &#123;&quot;nodes&quot;:[&quot;ino2&quot;,&quot;ino2&quot;,&quot;ino2&quot;,&quot;ino2&quot;]&#125;#node = &#123;&quot;nodes&quot;:[&quot;123.206.232.138:8081&quot;,&quot;123.206.232.138:8082&quot;,&quot;123.206.232.138:8083&quot;,&quot;123.206.232.138:8084&quot;]&#125;#node = &#123;&quot;nodes&quot;:[&quot;122.152.218.100:8081&quot;,&quot;111.231.106.89:8081&quot;,&quot;111.231.118.14:8081&quot;,&quot;111.231.106.41:8081&quot;]&#125;node = &#123;&quot;nodes&quot;:[&quot;192.168.130.141&quot;,&quot;192.168.130.142&quot;,&quot;192.168.130.143&quot;,&quot;192.168.130.65&quot;]&#125;# JsonRpc connect port#jsonRpcPort = [9041, 9042, 9043, 9044]jsonRpcPort = [8047, 8047, 8047, 8047]# webSocket connect portwebSocketPort = [10001, 10001, 10001, 10001]#Namespacenamespace = global#重发次数resendTime = 10#第一次轮训时间间隔 unit /msfirstPollingInterval = 100#发送一次,第一次轮训的次数firstPollingTimes = 10#第二次轮训时间间隔 unit /mssecondPollingInterval = 1000#发送一次,第二次轮训的次数secondPollingTimes = 10#Send Tcert during the request or notSendTcert = false#if sendTcert is true , you should add follow path.#ecertPath = certs/sdkcert.cert#ecertPriPath = certs/sdkcert.priv#uniquePrivPath = certs/unique.priv#uniquePubPath = certs/unique.pub#发送重新连接请求间隔(/ms)reConnectTime = 10000&#125; 其中，主要注意node, jsonRpcPort, webSocketProt的配置，分别对应各个节点的IP和开放的端口。 日志的配置log4j.propertieshyperchain采用log4j作为日志输出，配置文件如下:12345678### 设置##### 如果设置为DEBUG将输出调用信息log4j.rootLogger=INFO,stdout### 输出信息到控制抬 ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n 合约编译hyperchain平台支持solidity和java两种语言的合约，由于solidity是Ehtereum推出的语言，相关支撑的工具更多。Solidity合约可以在remix中编辑、编译、调试，并能获取对应的abi，bin。可以在hyperchain应用代码中编译合约，但是更推荐通过别的工具编译好以后在代码中直接用。 合约代码一个简单的合约：12345678pragma solidity ^0.4.24;contract Echo &#123; function echo(uint32 a) public pure returns(uint32 _a) &#123; return a; &#125;&#125; 应用程序代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.qqq.test;import cn.hyperchain.sdk.rpc.HyperchainAPI;import cn.hyperchain.sdk.rpc.Transaction.Transaction;import cn.hyperchain.sdk.rpc.account.Account;import cn.hyperchain.sdk.rpc.base.VMType;import cn.hyperchain.sdk.rpc.function.FuncParamReal;import cn.hyperchain.sdk.rpc.function.FunctionDecode;import cn.hyperchain.sdk.rpc.function.FunctionEncode;import cn.hyperchain.sdk.rpc.returns.ReceiptReturn;import cn.hyperchain.sdk.rpc.utils.Utils;import java.math.BigInteger;public class Main &#123; private static String hpcPath = &quot;D:\\mycode\\java\\echo\\src\\resources\\hpc.properties&quot;; private static String accountJsonPath = &quot;D:\\mycode\\java\\echo\\info\\accountJson.txt&quot;; private static String contractAddressPath = &quot;D:\\mycode\\java\\echo\\info\\contractAddress.txt&quot;; private static String contractBinPath = &quot;D:\\mycode\\java\\echo\\src\\contract\\echo.bin&quot;; private static String contractAbiPath = &quot;D:\\mycode\\java\\echo\\src\\contract\\echo.abi&quot;; public static void main(String[] args) throws Exception&#123; System.out.println(&quot;qqq&quot;); //deployContract(); echo(); &#125; public static void deployContract() throws Exception&#123; HyperchainAPI hyperchain = new HyperchainAPI(hpcPath); String accountJson = hyperchain.newAccountSM2(&quot;123456&quot;); Utils.writeFile(accountJsonPath,accountJson); Account account = new Account(accountJson); /** * 在线编译合约 */ //String contractPath = &quot;D:\\mycode\\java\\echo\\src\\contract\\echo.sol&quot;; //String contract = Utils.readFile(contractPath); //CompileReturn compileReturn = hyperchain.compileContract(contract); //List&lt;String&gt; contractAbi = compileReturn.getAbi(); //List&lt;String&gt; contractBin = compileReturn.getBin(); //System.out.println(&quot;=== Abi Bin&quot;); //System.out.println(contractBin.get(0)); //System.out.println(contractAbi.get(0)); //System.out.println(&quot;===&quot;); String bin = Utils.readFile(contractBinPath); Transaction transaction = new Transaction(account.getAddress(), bin, true, VMType.EVM); transaction.signWithSM2(accountJson,&quot;123456&quot;); ReceiptReturn receiptReturn = hyperchain.deployContract(transaction); String txHash = receiptReturn.getTxHash(); int code = receiptReturn.getCode(); String contractAddress = receiptReturn.getContractAddress(); Utils.writeFile(contractAddressPath,contractAddress); System.out.println(txHash); System.out.println(code); System.out.println(contractAddress); &#125; public static void echo() throws Exception &#123; String accountJson = Utils.readFile(accountJsonPath); Account account = new Account(accountJson); HyperchainAPI hyperchain = new HyperchainAPI(hpcPath); FuncParamReal param1 = new FuncParamReal(&quot;uint32&quot;,new BigInteger(&quot;11111&quot;)); String contractAddress = Utils.readFile(contractAddressPath); String payload = FunctionEncode.encodeFunction(&quot;insert&quot;,param1); Transaction transaction = new Transaction(account.getAddress(),contractAddress, payload,false, VMType.EVM); transaction.signWithSM2(accountJson,&quot;123456&quot;); ReceiptReturn receipt = hyperchain.invokeContract(transaction); if(!receipt.isSuccess()) &#123; System.out.println(&quot;echo error!&quot;); &#125; String abi = Utils.readFile(contractAbiPath); int code = receipt.getCode(); String rawReturn = receipt.getRet(); String decodeRet = FunctionDecode.resultDecode(&quot;echo&quot;,abi,rawReturn); System.out.println(code); System.out.println(decodeRet); &#125;&#125; 合约部署参照程序代码，部署合约分成3步： 通过hpc.properties生成HyperchainAPI对象。这是调用hyperchain平台的主要类。 生成账户，可以将accountJson保存成文本，今后再使用同一账户时，可以直接read改文本，再生成Account。 编译合约。可以在线编译，更推荐将编译好的合约直接使用。直接read合约的bin文件。。 生成交易。部署合约对于区块链也是一笔交易。交易都需要使用账户信息进行签名。 解析交易的返回信息。 触发合约参照程序代码，分成3步： 读取accountJson，生成Account。 生成HyperchainAPI. 规范化调用参数，由于solidity与java直接有一个数据类型映射关系。 获取合约地址。 生成交易信息。 生成交易。 对交易进行签名，触发。 解析交易回执。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>hyperchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile笔记]]></title>
    <url>%2Fmakefile%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[make概述make的基本模型如下：12targets: objects commands 简单的说就是我们要有一个目标 target（也可以是多个），生成这个目标需要依赖于多个对象 object，生成这个目标的方法就是 command。这里的object也可以有自己的依赖，这样层层递归，直到最底层，make会根据这个递归关系层层查找，然后从最底层的目标开始生成，然后层层往上生成最上层的目标（终极目标）。make会检测这些目标所依赖的对象是否被改动过，如果被改动，就运行命令command重新生成target。make其他的操作都是在这样的模式下进行的。make不限于做代码编译，凡是符合上面的模式的工作都可以做。 Tips @: makefile中可以添加shell命名，如果在shell命令之前加上 @ ，会让make不输出这条命令，只输出命令执行的结果。 cut: shell 命令 cut，通过参数设置，能够显示文本的指定列/字符。显示文件 aaa.txt 的第二列，以空格为分隔符： 1cut -f2 -d' ' aaa.txt 参数的用法：-f-4表示显示1到4列；如果显示指定字符： 1cut -c2 aaa.txt 表示显示每行的第二个字符，-c参数的运用和-f一样。 wildcard: makefile中的命令，用于获取当前目录下所有文件的文件路径（包括文件名）。用法： 1SOURCES = $(wildcard *.c) notdir: makefile中的命令。用于删除路径，保留文件名。（也就是把最后一个/之前的内容删除）。用法： 1FILES =$(notdir $(SOURCES)) patsubst: makefile中的命令。用于替换操作。例如： 1OBJS = $(patsubst %.c，%.o，$(SOURCES)) 表示将SOURCES中所有文件名的 .c 换成 .o。还有另一种写法： 1OBJS = $($(SOURCES): %.c = %.o) g++ -MP: g++ 的编译选项 -MP。以下是 g++ 文档的说明：This option instructs CPP to add a phony target for each dependency other than the main file, causing each to depend on nothing. These dummy rules work around errors make gives if you remove header files without updating the Makefile to match. This is typical output: 12test.o: test.c test.h test.h: 这就是为了当删除了头文件 test.h 能够触发 test.o 重新编译。 g++ -MMD: g++ 的编译选项。 首先是 -MM, 它会在编译阶段打印出编译对象的依赖（除了系统文件）；-MMD, 将产生的依赖关系写入 *.d 文件。通过 g++ 的这种机制，能够自动发现文件之间的依赖关系，某个编译对象依赖的文件发生变化时，触发重新编译。 在makefile中，如果存在两个相同的目标，会将其合并，并选择较新的命令执行。 在make执行过程中，如果include的文件发生变化，会让make重新读取整个makefile。这也是make能够根据 g++ 生成的依赖自动编译的原因。 一些特殊变量$^所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。 $@表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合 $?所有比目标新的依赖目标的集合。以空格分隔。 $&lt;依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将是符合模式的一系列的文件集。注意，其是一个一个取出来的。 make中的赋值 ?= 变量如果没有被赋值过，就赋予右边的值 := 覆盖之前的值 = 最基本的赋值 += 添加等号后面的值 =和:=的区别：=是将makefile最终展开后才确定值，:=是立即能确定值 很好的解释了自动生成依赖的文章http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch22s04.html 一个makefile的例子本例是别人放在github上的一个项目，通过解释makefile文件了解其工作原理。假设我们有如下工作目录：+– inclue| +– qvector.h+– src| +– main.cpp| +– qvector.cpp+– makefile 其中makefile是这样写的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980################################################################## 这部分都是定义一些变量，便于后续的操作#################################################################CXX ?= g++ SRC_PATH = src BUILD_PATH = build BIN_PATH = $(BUILD_PATH)/bin BIN_NAME = runner SRC_EXT = cpp ################################################################## 进行一些路径准备# SOURCEs保存了当前目录下所有以 cpp 结尾的文件的路径# OBJECTS通过模式匹配生成了每个源文件对应的目标文件路径# DEPS是依赖文件的路径#################################################################SOURCES = $(shell find $(SRC_PATH) -name '*.$(SRC_EXT)' | sort -k 1nr | cut -f2-) OBJECTS = $(SOURCES:$(SRC_PATH)/%.$(SRC_EXT)=$(BUILD_PATH)/%.o) DEPS = $(OBJECTS:.o=.d) ################################################################## 编译选项的配置#################################################################COMPILE_FLAGS = -std=c++11 -Wall -Wextra -g # -Wall-&gt; display warning, -Wextra-&gt;display other warningINCLUDES = -I include/ -I /usr/local/include LIBS = ################################################################## 定义了几个伪目标# 这里的伪命令是层层递归调用的：# default_target -&gt; release -&gt; dirs -&gt; dirs -&gt; all -&gt; $(BIN_PATH)/$(BIN_NAME)# -&gt; (BUILD_PATH)/%.o################################################################## 在makefile中，如果make没有指定目标，第一个出现的目标就是终极目标，所以这里是default_target。# default_target依赖于release，然后去检测release.PHONY: default_target default_target: release # release依赖于dirs，当依赖执行完成后，会执行它的命令 make all.PHONY: releaserelease: export CXXFLAGS := $(CXXFLAGS) $(COMPILE_FLAGS)release: dirs @$(MAKE) all # dirs用于创建两个目录.PHONY: dirsdirs: @echo "Creating directories" @mkdir -p $(dir $(OBJECTS)) @mkdir -p $(BIN_PATH)# 用于清理文件的伪命令.PHONY: cleanclean: @echo "Deleting $(BIN_NAME) symlink" @$(RM) $(BIN_NAME) @echo "Deleting directories" @$(RM) -r $(BUILD_PATH) @$(RM) -r $(BIN_PATH)# all目标依赖于$(BIN_PATH)/$(BIN_NAME)，当依赖解决后，执行命令，产生一个软链接.PHONY: all all: $(BIN_PATH)/$(BIN_NAME) @echo "Making symlink: $(BIN_NAME) -&gt; $&lt;" @$(RM) $(BIN_NAME) @ln -s $(BIN_PATH)/$(BIN_NAME) $(BIN_NAME)# $(BIN_PATH)/$(BIN_NAME)依赖于$(OBJECTS)，当所有的对象都更新完成后，执行命令，链接生成# 可执行文件。$(BIN_PATH)/$(BIN_NAME): $(OBJECTS) @echo "Linking: $@" $(CXX) $(OBJECTS) -o $@# 加载依赖文件，第一次不存在。-include $(DEPS) # 每个目标对象对应一个源文件，且会生成对应的依赖文件，这里的规则会和include的规则进行合并$(BUILD_PATH)/%.o: $(SRC_PATH)/%.$(SRC_EXT) @echo "Compiling: $&lt; -&gt; $@" $(CXX) $(CXXFLAGS) $(INCLUDES) -MP -MMD -c $&lt; -o $@ 自己的通用模板1234567891011121314151617181920212223242526272829303132333435363738394041424344EXE_NAME:=mainSRC_PATH:=.BUILD_PATH:=./buildBIN_PATH:=$(BUILD_PATH)/binEXE:=$(BIN_PATH)/$(EXE_NAME)SOURCES:=$(shell find $(SRC_PATH) -name '*.cpp')OBJS:=$(addprefix $(BUILD_PATH)/,$(SOURCES:%.cpp=%.o))DEPS:=$(addprefix $(BUILD_PATH)/,$(SOURCES:%.cpp=%.d))OBJS_DIR:=$(addprefix $(BUILD_PATH)/,$(shell dirname $(SOURCES) | sort | uniq))LIBS:=CPPFLAGS+= -g -Wall -std=c++11 -I ./includeCC:=g++all:$(EXE)$(shell mkdir -p $(OBJS_DIR))$(shell mkdir -p $(BIN_PATH))-include $(DEPS)$(EXE): $(OBJS) $(CC) $(CPPFLAGS) -o $@ $^ $(LIBS)$(OBJS): $(BUILD_PATH)/%.o: $(SRC_PATH)/%.cpp $(CC) -o $@ $(CPPFLAGS) -c $&lt;$(DEPS): $(BUILD_PATH)/%.d: $(SRC_PATH)/%.cpp @set -e; rm -f $@; \ $(CC) -MM $(CPPFLAGS) $&lt; &gt; $@.$$$$; \ sed 's,.*\.o[ :]*,$(patsubst %.d,%.o,$@) $@ : ,g' &lt; $@.$$$$ &gt; $@; \ rm -f $@.$$$$.PHONY: cleanclean: rm -rf ./build.PHONY: testtest: @echo $(DEPS) @echo $(OBJS) @echo $(SOURCES) @echo $(SRC_PATH) @echo $(BUILD_PATH) @echo $(OBJS_DIR)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Googletest入门文档翻译]]></title>
    <url>%2FGoogletest%E5%85%A5%E9%97%A8%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[Googletest入门 介绍：为什么选googletest? googletest帮助你写出更好的C++测试程序 googletest是google的测试技术团队开发的一个测试框架，开发这个框架是出于google特定的需求和约束考虑。无论使用Linux，Windows，还是Mac，只要你写C++代码，googletest都能帮助你。并且它不仅支持单元测试，还支持其他类型的测试。那么，什么样的测试是好的测试，googletest又是怎么做的？我们认为： 不同测试之间应该是独立的且可重复的。如果一个测试的成功与否依赖于其他的测试结果，这将是一件痛苦的事。googletest将各个测试运行在不同的对象中，以此独立不同的测试。如果一个测试挂了，googletest能让你在孤立的环境中运行它，实现快速调试。 测试集应该组织良好，并且能反映被测代码的结构。googletest将相关的tests分组到test cases中，使之能够共享数据和子程序。这种普通的模式很清晰，也让tests容易维护。对于切换了项目和开始基于一段新代码工作的人，这样的一致性非常有帮助。 Tests应该具有可移植性和可重用性。Google有很多平台独立的代码，它们的测试也应该是平台独立的。googletest可以在不同的操作系统运行，这些系统有不同的编译器（gcc，icc，和MSVC），有的支持异常有的不支持，所以googletest能够轻松的在各种配置下工作。 一旦tests失败，测试框架应该尽可能多的提供错误信息。googletest不会在第一个test失败后停下来，而是仅仅终止当前的test，然后继续下一个test。你也可以设置tests报告非致命错误，以此让当前test继续执行。因此，你能在一个run-edit-compile周期里，检测并修复多个bug。 测试框架应该把程序员从繁杂的琐事中解放出来，让他们专注于test内容。googletest自动跟踪所有已定义的tests，不需要用户为了运行而去枚举它们。 Tests应该是快速的。使用googletest，你能够重用在tests中共享的资源，并且只需要调用一次set-up/taer-down，tests之间没有依赖关系。 googletest基于流行的xUint架构，所以如果你在此之前使用过JUnit或者PyUnit，你会感觉很熟悉。否则，你需要花10分钟学习这些基础，然后再开始应用。开始吧！ 命名法须知注意：由于对术语Test, Test Case和Test Suite的不同定义，可能会造成一些困惑，所以留意这些可能的误解。以往，googletest开始用术语Test Case表示具有相关性的tests，然而，当前公开的一些框架是用Test Suite，包括International Software Testing Qualifications Board (ISTQB)和various textbooks on Software Quality。在googletest中使用的术语Test，与ISTQB和其他框架使用的术语Test Case意义一样。术语Test通常具有足够广泛的意义，也包括ISTQB定义的Test Case，所以这没有太多问题。但是在Google Test中使用的术语Test Case有一定的矛盾性，所以会让人迷惑。googletest最近开始用术语Test Suite替换Test Case，更好的API是TestSuite。旧的TestCase API逐渐被弃用和重构。所以，请留意这两个术语的不同定义： 意义 googletest术语 ISTQB术语 使用特定的输入值检验特定的程序执行路径并验证结果 TEST() Test Case 基本概念 使用googletest从写assertions开始，这是用于检查条件是否为真的表达式。一个assertion的结果可以是success，nonfatal failure，或者fatal failure。如果一个fatal failure发生，当前的函数会被终止；否则程序会正常继续执行。Tests用assertions去验证被测代码的行为。如果一个test挂了或者得到一个失败的assertion，这个test就是失败的；否则就是成功。一个test case包含一个或多个tests。你应该将tests分组到不同的test cases中，以反映被测代码的结构。当一个test case中的多个tests要共享通用的对象和子程序时，你可以将它们放入test fixture类中。一个test program能包含多个test cases。我们现在解释如何写一个测试程序，从单个assertion级别开始，直到建立tests和test cases。 Assertions googletest assertions是类似于函数调用的宏。通过对类或函数的行为设置assertions，来进行测试。当assertion失败，googletes打印assertion的源文件和它所在的行号，以及错误信息。你也可以提供定制的错误信息，这会添加在googletest信息后面。测试同样的功能assertions有两个版本，在测试函数中它们会表现出不同的效果。当断言失败，==ASSERT_==版本会产生致命错误并终止当前函数。==EXPECT_==产生非致命错误，不会终止当前函数。==EXPEXCT_==总是被推荐的，因为它们允许多个错误在一个test里面被报告。然而，当断言处发生错误后继续执行程序没有意义，你就应该使用==ASSERT_==。一个失败的==ASSERT_*==会立即从当前函数返回，所以可能会跳过在这之后的清理代码，这是否值得修复依赖于泄露的特性，所以记住这一点，如果你在断言错误后得到一个堆检测错误。为了提供定制的失败信息，可以通过操作符==&lt;&lt;==简单的将信息输入宏，或者一系列这样的操作。一个例子：12345ASSERT_EQ(x.size(), y.size()) &lt;&lt; "Vectors x and y are of unequal length";for (int i = 0; i &lt; x.size(); ++i) &#123; EXPECT_EQ(x[i], y[i]) &lt;&lt; "Vectors x and y differ at index " &lt;&lt; i;&#125; 任何能输入==ostream==的对象都能被输入断言宏–特殊的，C字符串和==string==对象。如果宽字符串（Windows的==wchar_t==, ==TCHAR==in==UNICODE==模式，或者==std::wstring==）被输入断言宏，会在打印时转换程UTF-8。 基本的Assertions这些assertions进行基本的true/false条件测试：| Fatal assertion | Nonfatal assertion | Verifies || —————————| —————————–| ———————–|| ASSERT_TRUE(condition); | EXPECT_TRUE(condition); | condition is true || ASSERT_FALSE(condition); | EXPECT_FALSE(condition); | condition is false | 记住，如果条件为false，==ASSERT_ ==产生一个致命错误并从当前函数返回，而==EXPECT_ ==产生一个非致命错误，函数会继续执行。无论哪种情况，一个断言失败意味着它包含测试失败。 可用性：Linux, Windows, Mac。 二元比较 这部分描述比较两个值的断言。| Fatal assertion | Nonfatal assertion | Verifies || ———————- | ———————- | ————-|| ASSERT_EQ(val1, val2); | EXPECT_EQ(val1, val2); | val1 == val2 || ASSERT_NE(val1, val2); | EXPECT_NE(val1, val2); | val1 != val2 || ASSERT_LT(val1, val2); | EXPECT_LT(val1, val2); | val1 &lt; val2 || ASSERT_LE(val1, val2); | EXPECT_LE(val1, val2); | val1 &lt;= val2 || ASSERT_GT(val1, val2); | EXPECT_GT(val1, val2); | val1 &gt; val2 || ASSERT_GE(val1, val2); | EXPECT_GE(val1, val2); | val1 &gt;= val2 | Value参数必须是能通过断言比较操作符比较的，否则会得到一个编译错误。我们过去要求参数支持能输入到==ostream==的==&lt;&lt;==操作符，但是现在不是必要的。如果支持==&lt;&lt;==，一旦断言失败，它会被调用来输出参数；否则googletest会尽可能用最合理的方式来打印它。更多细节以及如何定制化打印参数，参考gMock recipe。断言能用户定义的类型也有效，但必须要定义相关的比较运算符（比如 == == ==, == &lt; ==，等）。Google C++风格指南不鼓励运算符重载，所以你可能要使用== ASSERT_TRUE() == 或者 == EXPECT_TRUE() == 去断言自定义的两个对象是否相等。然而，如果可能，==ASSERT_EQ(actual, expected)==要优于==ASSERT_TRUE(actual == expected)==，因为前者会在失败时报告==actual==和==expected==的值。参数总是精确的计算一次。因此，参数产生的副作用是正常的。但是，就像任何正常的C/C++函数一样，参数的计算顺序是未定义的（即这个顺序是编译器相关的），并且你的代码不应该有任何特殊的参数计算顺序依赖。==ASSERT_EQ==进行指针的相等判断。如果在两个C字符串上使用，这会测试它们是否有相同的内存位置，而不是是否有一样的值。因此，如果你要比较C字符串（比如==const char==)的值就用==ASSERT_STREQ()==，稍后会有介绍。特殊的，断言一个C字符串是==NULL==，使用==ASSERT_STREQ(c_string, NULL)==。如果支持C++11，考虑用ASSERT_EQ(c_string, nullptr)。用==ASSERT_EQ==比较两个==string==对象。做指针比较时，用==_EQ(ptr, nullptr)==和==NE(ptr, nullptr)==代替==_EQ(ptr, NULL)==和==_NE(ptr, NULL)==。因为==nullptr是类型而==NULL==不是。如果你处理浮点数，你需要使用这些宏针对浮点的变化形式，以避免取整导致的问题。这节的宏支持宽字符对象和窄字符对象（==string==和==wstring==）。可用性：Linux, Windows, Mac。历史改动：2016年二月以前，==_EQ==有一个调用惯例==ASSERT_EQ(expected, actual)==，很多现有代码就使用这种顺序。现在==*_EQ==以相同的方式对待两个参数。 字符串比较 这部分的断言比较两个C字符串。如果要比较两个==string==对象，使用==EXPECT_EQ==，==EXPECT_NE==，和其他代替。| Fatal assertion | Nonfatal assertion | Verifies || — | — | — || ASSERT_STREQ(str1, str2); | EXPECT_STREQ(str1, str2); | the two C strings have the same content || ASSERT_STRNE(str1, str2); | EXPECT_STRNE(str1, str2); | the two C strings have different contents || ASSERT_STRCASEEQ(str1, str2); | EXPECT_STRCASEEQ(str1, str2); | the two C strings have the same content, ignoring case || ASSERT_STRCASENE(str1, str2); | EXPECT_STRCASENE(str1, str2); | the two C strings have different contents, ignoring case | 注意断言名字种的“CASE”意味着忽略了case，==NULL==指针和一个空的字符串是不同的。== STREQ ==和== STRNE ==也接收宽的C字符串（== wchar_t* ==）。如果两个宽字符串比较失败，它们的值会被UTF-8的字符串替换打印。可用性：Linux, Windows, Mac。其他：更多的字符串比较技巧（例如，子串，前缀，后缀和正则匹配），参考高级googletest指南的这部分。 简单的测试 建立一个测试： 用==TEST()==宏定义并命名一个测试函数，这就是通常的没有返回值的C++函数。 在这个函数种，可以包含你想要的各种有效的C++表达式，并用各种googletest断言去验证这些值。 测试的结果决定于这些断言；测试中的任何的断言失败（无论是致命的还是非致命的），或者测试挂了，整个测试都是失败的，否则，测试成功。123TEST(TestSuiteName, TestName) &#123; ... test body ...&#125; ==TEST()==参数从一般到具体。第一个参数是test case的名字，第二个参数是这个test case 中 test 的名字。两个名字都必须是有效的C++命名符，并且不能包含下划线（==_==）。一个测试的全名由它的test case和test名字组成。不同的test case中的test可以由相同的test名字。例如，我们写一个简单的整型函数：1int Factorial(int n); // Returns the factorial of n 这个函数的test case可能会是这样：123456789101112// Tests factorial of 0.Test(FactorialTest, HandlesZeroInput) &#123; EXPECT_EQ(Factorial(0), 1);&#125;// Tests factorial of positive numbers.TEST(FactorialTest, HandlesPositiveInput) &#123; EXPECT_EQ(Factorial(1), 1); EXPECT_EQ(Factorial(2), 2); EXPECT_EQ(Factorial(3), 6); EXPECT_EQ(Factorial(8), 40320);&#125; googletest以test cases为单位对测试结果分组，所以逻辑相关的tests应该被放在一个test case里；换言之，==TEST()==的第一个参数应该一样。在上面的例子中，由两个tests，==HandlesZeroInput==和==HandlesPositiveInput==，它们都属于==FactorialTest==。命名test cases 和 tests时，应该遵循与函数命名和类命名同样的惯例。可用性：Linux, Windows, Mac。 测试装置：多个测试使用相同的数据配置 如果你发现你写的两个或多个tests操作相似的数据，你可以使用 test fixture。它能让你在不同的tests中重用相同的对象配置。建立一个配置： 继承==::testing::Test==。从==protected:==开始写内容，也就是你想要从子类访问的配置成员。 在类中申明任意你想要使用的对象。 如果必要，写一个默认的构造函数或者==SetUp()==函数，用来给每个测试初始化对象。一个常见的错误是将==SetUp()==拼写成==Setup()==，小写了==u==，可以在C++11中使用==override==确保拼写正确。 如果必要，写一个析构函数或者==TearDown()==函数去释放在==SetUp()==中分配的资源。阅读这里的FAQ，学习什么时候用构造和析构，什么时候用==SetUp()/TearDown()==。 如果需要，给你的tests定义共享的子程序。 当使用fixture，用==TEST_F()==代替==TEST()==，前者能让你访问这个test fixture中的对象和子程序：123TEST_F(TestSuiteName, TestName) &#123; ... test body ...&#125; 如同==TEST()==，第一个参数是test case的名字，但是对于==TEST_F()，必须是这个test fixture类的类名。你可能已经猜到：==_F==代表fixture。遗憾的是，C++宏不允许我们创建一个宏来处理两种类型的测试。使用错误的宏会导致编译器错误。你必须在==TEST_F()==使用test fixture之前定义它，否则会得到编译错误“virtual outside class declaration”。对于每个用==TEST_F()==定义的test，googletest会在运行时创造一个新的test fixture，通过==SetUp()==立即初始化，运行test，通过==TearDown()==进行清理，然后删除test fixture。注意：同一个test case 中的不同tests拥有不同的test fixture对象，并且googletest总是在创造下一个test fixture之前删除上一个。googletest不会对多个tests用相同test fixture。任何一个test对test fixture的改变不会影响到其他的。 作为一个例子，我们写一个tests，用于测试命名==Queue==的FIFO队列，接口如下：123456789template &lt;typename E&gt; // E is the element type.class Queue &#123; public: Queue(); void Enqueue(const E&amp; element); E* Dequeue(); // Returns NULL if the queue is empty. size_t size() const; ...&#125;; 首先，定义一个fixture类。按照惯例，对于名为==Foo==的被测类型，它的test fixture名应该是==FooTest==。1234567891011121314class QueueTest : public ::testing::Test &#123; protected: void SetUp() override &#123; q1_.Enqueue(1); q2_.Enqueue(2); q2_.Enqueue(3); &#125; // void TearDown() override &#123;&#125; Queue&lt;int&gt; q0_; Queue&lt;int&gt; q1_; Queue&lt;int&gt; q2_;&#125;; 本例中，不需要==TearDown()==，因为不必在每个test后进行清理，析构函数已经做了这些工作。现在，用==TEST_F()==写tests以及fixture。1234567891011121314151617181920TEST_F(QueueTest, IsEmptyInitially) &#123; EXPECT_EQ(q0_.size(), 0);&#125;TEST_F(QueueTest, DequeueWorks) &#123; int* n = q0_.Dequeue(); EXPECT_EQ(n, nullptr); n = q1_.Dequeue(); ASSERT_NE(n, nullptr); EXPECT_EQ(*n, 1); EXPECT_EQ(q1_.size(), 0); delete n; n = q2_.Dequeue(); ASSERT_NE(n, nullptr); EXPECT_EQ(*n, 2); EXPECT_EQ(q2_.size(), 1); delete n;&#125; 上面的程序用了==ASSERT_==和==EXPECT_==断言。使用的原则是：如果你想在断言失败后继续收到错误信息，就用==EXPECT_==；如果断言失败后继续执行已经没有意义，就用==ASSERT_==。例如，==Dequeue== test中的第二个断言是 =ASSERT_NE(nullptr, n)=, 我们之后应该废弃这个指针 ==n==，因为 ==n== 是 ==NULL== 会导致段错误。当这些tests运行，以下的事情会发生： googletest构造一个 ==QueueTest== 对象（我们叫它 ==t1== ）。 ==t1.SetUp()== 初始化 ==t1==。 第一个test（ ==IsEmptyInitially== ）在 ==t1== 上运行。 test结束后 ==t1.TearDown()== 清理垃圾。 ==t1== 析构。 在另外一个 ==QueueTest== 对象上重复以上过程，这次运行 ==DequeueWorks== test。 可用性：Linux, Windows, Mac。 触发Tests ==TEST()==和==TEST_F()==通过googletest隐式的注册它们的tests。所以，与很多其他的c++测试框架不同，你不必为了运行tests而去再列明这些已定义的tests。tests定义后，你可以通过 ==RUN_ALL_TESTS()== 运行它们，所有的tests都成功会返回 ==0==，否则是 ==1== 。注意 ==RUN_ALL_TESTS()== 运行所有在你的链接单元中的tests–它们可以来自不同的test cases，甚至不同的源文件。 一旦被触发， ==RUN_ALL_TESTS()== 宏： 保存所有googletest flags 的状态。 为第一个test创造一个test fixture。 通过 ==SetUp()== 初始化。 在fixture对象上运行test。 通过 ==TearDown()== 清理fixture。 删除fixture。 重新保存googletest flags的状态。 为下一个test重复以上过程，直到所有tests运行完。 如果致命失败发生，后续的步骤将被跳过。 重要：你不能忽略 ==RUN_ALL_TEST()== 的返回值，否则会得到一个编译错误。这样涉及的原则是：自动化测试服务决定一个test是否通过是基于它的退出码，而不是他的 stdout/stderr 输出；因此， ==main()== 函数必须返回 ==RUN_ALL_TESTS()== 的值。同时，你只能调用 ==RUN_ALL_TESTS()== 一次。多此调用会引发一个高级的googletest特性冲突（例如，线程安全death tests），所以这是不支持的。 可用性：Linux, Windows, Mac。 写主函数 写你的main()函数，它应该返回 ==RUN_ALL_TESTS()== 的值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include "this/package/foo.h"#include "gtest/gtest.h"namespace &#123;// The fixture for testing class Foo.class FooTest : public ::testing::Test &#123; protected: // You can remove any or all of the following functions if its body // is empty. FooTest() &#123; // You can do set-up work for each test here. &#125; ~FooTest() override &#123; // You can do clean-up work that doesn't throw exceptions here. &#125; // If the constructor and destructor are not enough for setting up // and cleaning up each test, you can define the following methods: void SetUp() override &#123; // Code here will be called immediately after the constructor (right // before each test). &#125; void TearDown() override &#123; // Code here will be called immediately after each test (right // before the destructor). &#125; // Objects declared here can be used by all tests in the test case for Foo.&#125;;// Tests that the Foo::Bar() method does Abc.TEST_F(FooTest, MethodBarDoesAbc) &#123; const std::string input_filepath = "this/package/testdata/myinputfile.dat"; const std::string output_filepath = "this/package/testdata/myoutputfile.dat"; Foo f; EXPECT_EQ(f.Bar(input_filepath, output_filepath), 0);&#125;// Tests that Foo does Xyz.TEST_F(FooTest, DoesXyz) &#123; // Exercises the Xyz feature of Foo.&#125;&#125; // namespaceint main(int argc, char **argv) &#123; ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS();&#125; ==::testing::InitGoogleTest()== 函数为googletest flags解析命令行参数，并且移除所有可识别的flags。这能让用户通过各种flags来控制test程序的行为，在AdvancedGuide中有详细介绍。调用 ==RUN_ALL_TESTS()== 之前必须调用它，否则flags不会被正确初始化。在Windows上， ==InitGoogleTest()== 也支持宽字符串，所以它也能在 ==UNICODE==模式下编译。也许你觉得编写所有这些主函数工作量太大了？我们完全同意，那也是为什么googletest提供了一个基本的main()实现。如果这符合你的需求，把你的test和gtest_main链接，你很适合这样去做。注意：==ParseGUnitFlags()== 已被弃用，更推荐用 ==InitGoogleTest()==。 需要知道的限制 Google Test被设计成线程安全的。在 ==pthreads==库可用的系统上，实现是线程安全的。当前在其他系统（比如 Windows）上在两个线程中并发使用Google Test断言是线程不安全的。在大部分tests中这不是问题，因为assertions总是在主线程中执行。如果你需要帮助，你可以针对你的平台，在 ==gtest-port.h== 中自愿实现这些必要的同步原语。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ 测试框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim常用命令]]></title>
    <url>%2FVim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vim的命令有很多，而且各种插件还有自己的命令，要都记下来显然不现实，也没有这个必要。但是记住一些常用的命令，可以极大的提高编辑的效率。这篇文章介绍一些常用命令，不涉及其他的插件。文中的内容参考了一些其他博客的内容，这里主要做下整理归类。 移动光标在Normal模式下，可以通过多种快捷键快速的移动光标。下面是四个最基本的移动命令： h，向左移动一个字符； l，向右移动一个字符； k，向上移动一个字符； j，向下移动一个字符； 以上四个命令可以配合数字使用，比如 5j 就是向下移动5行，5h 就是向左移动 5 个字符；（vim中很多命令都可以配合数字使用） 以下是一些快速的定位方式： H，跳转到当前可见区域的顶部第一个非空字符； M，跳转到当前可见区域的中间第一个非空字符； L，跳转到当前可见区域的最后第一个非空字符； w，向后移动一个单词(光标停在单词首部)，如果已在行尾，则转至下一行行首； e，向后移动一个单词(光标停在单词尾部)，如果已在行尾，则转至下一行行首； b，向前移动一个单词(光标停在单词首部)； ge，同b，光标停在单词尾部； number + gg，快速跳转到number行的开头； gg，跳转到文档的开头； G，跳转到文档的最后一行的开头； $，跳转到行尾；3$，跳转到下面3行的行尾； 0，跳转到行首(跳转到一行开始的第一个非空字符)； ^，跳转到一行的最开始，包括前面的空格； :number，跳转至第number行； %，按括号匹配移动光标。 以下是一些滚动页的命令： zz，让当前行居屏幕中间显示； zt，让当前行居屏幕顶部显示； zb，让当前行居屏幕低部显示； ctrl+e, 向下滚动一行 crtl+y, 向上滚动一行 ctrl+d, 向下滚动半屏 ctrl+u, 向上滚动半屏 ctrl+f, 向下滚动一屏 ctrl+b, 向上滚动一屏 插入从Normal 模式进入Insert 模式的几个命令： i，在当前位置前插入； I，在当前行首插入； a，在当前位置后插入； A，在当前行尾插入； o，在当前行之后插入一行； O，在当前行之前插入一行； 这些命令也可以和数字配合，如 2i 然后输入 aa ，再按 esc 回到Normal 模式，就能在当前位置插入4个 a。 查找在Normal模式下进行查找。 /text，查找text，按n向下查找下一个，按N向上查找上一个； ?text，查找text，反向查找，按n向下查找下一个，按N向上查找上一个； 也可以将光标定位到某个词上，然后按 # ，*** 进行查找。另外，vim也支持正则表达式的查找。 以下是一些关于显示结果的设置，可以在配置文件中默认配置，也可以在命令模式下临时配置。 :set ignorecase，忽略大小写的查找； :set noignorecase，不忽略大小写的查找； :set hlsearch，高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配； :set nohlsearch，关闭高亮搜索显示； :nohlsearch，关闭当前的高亮显示，如果再次搜索或按下 n 或 N 键，则会再次高亮； :set incsearch，逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成； :set wrapscan，重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启； 替换替换命令，同样在命令模式下进行。 r，用新输入的一个字符替换当前一个字符； R，从当前字符开始往后一个一个字符替换为新输入的字符； ddp, 交换光标所在行和其下紧邻的一行 :s/old/new/，在当前行中用 old 替换 new，替换第一个匹配到的；没提示 :s/old/new/c，在当前行中用 old 替换 new，替换第一个匹配到的；有提示 :s/old/new/g，在当前行中用 old 替换 new，替换当前行的所有匹配；没提示 :s/old/new/gc，在当前行中用 old 替换 new，替换当前行的所有匹配；有提示 :%s/old/new/g，全文将 old 替换为 new，不提示； :%s/old/new/c，全文将 old 替换为 new，提示是否替换； 删除删除主要用字母 x 和 c，配合光标移动和数字能组合出很多快捷的操作。 x，向后删除光标所在的一个字符； X，向前删除光标所在的一个字符； cc，删除当前一整行，并进入编辑模式； C，删除至行尾，并进入编辑模式； c0，删除至行首，回到一行的第一个字符，包括最前面的空白字符； c^，删除至行首，不会删除行首的空白字符； 拷贝、剪切与粘贴剪贴对应的字母 d ，拷贝对应字母 y，粘贴对应字母 p。这里的剪贴是把内容移动到了vim的缓存中，所以可以通过粘贴 p 对应的命令把它复制出来。 dd，剪贴当前行；5dd，删除当前行开始向下的5行； dj，剪贴当前行和下一行； dk，剪贴当前行和上一行； number + dd，向下剪贴number行； D，剪贴至行尾；等同于d$； d0，剪贴至行首；等同于d^； dw，剪贴光标所在处一个单词的后部分； dG，剪贴光标之后至文档结束； dgg，剪贴光标之前至文档开头； yy，拷贝当前行；nyy，拷贝当前后开始的n行；等同于Y； y^，复制到行首，不包括当前位置； y$，复制到行尾，包括当前位置； yG，复制到文档尾；ygg，复制到文档头； p，在当前光标后粘贴； P，在当前光标前粘贴；等同于shift + p； :n1,n2 co n3，将n1至n2行拷贝并粘贴到n3行之后； :1,$ co $，将整个文档拷贝一份并添加至文档尾部； 另外，在命令模式下，可以按下 v （逐字），V（逐行）以及 ctrl+v（块）进入不同的可视模式，然后用移动光标的命令选择区域，再进行复制。 其他 注释 ctrl + v 进入 visual block 模式； 接着按 j 或 k 选中要注释的行； 然后按 I， 输入注释符 (//)； 最后再按 esc 就会把刚才选中的行都注释掉了；去掉注释也是一样的，只是把输入变成删除就行了。 undo和redo分别是 u 和 r。 退出:w，保存；:wq, 保存并退出ZZ, 保存并退出:q!, 强制退出并忽略所有更改:e!, 放弃所有修改，并打开原来文件 缩进>&gt;，当前行增加缩进一个TAB；n&gt;&gt;，当前行开始的n行增加缩进一个TAB&lt;&lt;，当前行减少一个TAB；n&lt;&lt;，当前行开始的n行减少一个TAB]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法]]></title>
    <url>%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序在算法中的地位不言而喻，而且也是在面试中经常被问到的点。本文主要分析和比较几种常见的基于比较的排序算法。通常，分析排序算法会从比较次数、交换次数、时间负责度、空间复杂度、最坏情况下的复杂度以及适用场景几个方面去考虑，所以本文也基于这样分析，并用Java进行了简单的实现，且仅考虑了升序的情况，代码只测试了几个简单的用例，如有不对的地方，还请指正。 选择排序很直观的一种排序，扫描一次数组，确定一个最小值，让它与未排序部分的第一个值交换，然后从刚才交换的值的下一个位置扫描。当扫描了N次以后数组也就有序了。 由于想法和实现都很简单，它的性能也只能是N^2的： 比较次数：N^2/2 交换次数：N 时间复杂度：N*N 空间复杂度：原地的，不需额外空间 最坏情况下时间复杂度：和输入无关 稳定性：不稳定 选择排序每次确定了一个元素的位置，但是每次循环得到的比较结果都没有被下一次利用，所以效率比较低，在实际中应该应用不多。 1234567891011121314public static void selectionSort(Comparable[] arr) &#123; for(int i=0;i&lt;arr.length;i++) &#123; int min=i; for(int j=i;j&lt;arr.length;j++) &#123; if(arr[j].compareTo(arr[min])&lt;0) &#123; min=j; &#125; &#125; Comparable tmp=arr[i]; arr[i]=arr[min]; arr[min]=tmp; &#125; return;&#125; 插入排序插入排序的想法也很简单，假设当前元素之前的所有元素都已经有序（一个元素的时候就是有序的），那么用当前元素去和之前的元素一一比较，当当前元素比前一个元素小，就交换它们的位置。 插入排序理论上的复杂度和选择排序是一样的，但是它与输入是有关系的，当输入是部分有序的时候，它能达到线性级别的效率。它的性能： 比较次数：平均 N×N/4，最坏 N×N/2，最好 N-1 交换次数：平均 N×N/4，最坏 N×N/2，最好 0 时间复杂度：N*N 空间复杂度：原地的，不需额外空间 最坏情况下时间复杂度：N*N 稳定性：稳定 插入排序在应对小数组和部分有序的数组时，能得到很好的性能，优于其他的算法，所以它适用于非随机的小数组，并且很多高级的排序算法在递归到小数组时通常用它来替换，能有效提高算法性能。 123456789101112public static void insertionSort(Comparable[] arr) &#123; for(int i=1;i&lt;arr.length;i++) &#123; Comparable key=arr[i]; int j=i-1; while(j&gt;=0 &amp;&amp; arr[j].compareTo(key)&gt;0) &#123; arr[j+1]=arr[j]; j--; &#125; arr[j+1]=key; &#125; return;&#125; 希尔排序希尔排序是对插入排序的优化，考虑到插入排序在部分有序和小数组情况下的优秀性能，将数组分成H组，每组的元素都是数组中间隔为H的元素，分别对每组元素进行插入排序，然后再将H减小，再进行插入排序，直到H等于1。 希尔排序的复杂度没有具体的证明，在平方级与线性对数级之间。希尔排序简单高效，一个小小的改动让算法脱离了平方级别，效率远高于插入排序，而且数组越大优势越大。算法的效率与选择的H递增序列有关。性能： 比较次数： 交换次数： 时间复杂度：N e(3/2) 空间复杂度：原地的，不需额外空间 最坏情况下时间复杂度： 稳定性：不稳定 希尔排序在应对中等大小的数值时很有效。 123456789101112131415public static void shellSort(Comparable[] arr) &#123; int len=arr.length; for(int h=len/2;h&gt;=1;h/=2) &#123; for(int i=h;i&lt;len;i++) &#123; Comparable key=arr[i]; int j=i-h; while(j&gt;=0 &amp;&amp; arr[j].compareTo(key)&gt;0) &#123; arr[j+h]=arr[j]; j-=h; &#125; arr[j+h]=key; &#125; &#125; return;&#125; 归并排序归并排序是分治思想的体现，将数组划分成两部分，分别排序，然后再合并两个有序数组（当一个元素时，自然是有序的），递归的进行，就能然整个数组有序。归并排序能让算法的复杂度稳定在 NlgN。 归并排序通过二分的方式，能在算法时间复杂度达到 NlgN，而且它与输入没有关系，但是归并需要利用额外的空间，所以空间复杂度是 N。 比较次数：1/2NlgN ~ NlgN 交换次数： 时间复杂度：NlgN 空间复杂度：N 最坏情况下时间复杂度： 稳定性：稳定 在空间不紧张，而且要求稳定的情况下，归并排序是一个好的选择。 归并排序通常的写法是递归的，但是也可以用非递归的方式来写。 12345678910111213141516171819202122232425262728293031public static void mergeSort(Comparable[] arr) &#123; mergeSortHelper(arr, 0, arr.length);&#125;private static void merge(Comparable[] arr, int l, int mid, int r) &#123; Comparable[] tmp = new Comparable[arr.length]; for(int k=l;k=r;k++) &#123; tmp[k]=arr[k]; &#125; int i=l,j=mid+1; for(int k=l;k&lt;=r;k++) &#123; if(i&gt;mid) arr[k]=tmp[j++]; else if(j&gt;r) arr[k]=tmp[i++]; else if(tmp[i].compareTo(tmp[j])&lt;0) arr[k]=tmp[i++]; else arr[k]=tmp[j++]; &#125;&#125;private static void mergeSortHelper(Comparable[] arr, int l, int r) &#123; if(l==r) return; int mid=(l+r)/2; mergeSortHelper(arr, l, mid); mergeSortHelper(arr, mid+1, r); merge(arr, l, mid, r);&#125;public static void mergeSort2(Comparable[] arr) &#123; int len=arr.length; for(int sz=1;sz&lt;len;sz*=2) &#123; for(int j=0;j&lt;len-sz;j+=sz*2) &#123; merge(arr, j, j+sz-1,Math.min(j+sz+sz-1, len-1)); &#125; &#125;&#125; 快速排序快速排序每次递归选择一个元素作为key，然后将数组中小于key的元素放左边，大于key的元素放右边。以key为分界点将数组分成两部分，再分别对两个子数组进行同样的操作。 快速排序在大多数应用下是最快的排序算法，它的负责度是NlgN，但是常数因子比别的同级别的算法小，因为他的内循环很简单，只是访问一遍数组，而且是顺序的访问数组，能有效利用缓存。但是在最坏的情况下，也就是每次的Key选择都是最大或最小的元素，快排就会变成冒泡排序，每次只能确定一个值。性能： 比较次数： 交换次数： 时间复杂度：NlgN 空间复杂度：lgN 最坏情况下时间复杂度：N^2 稳定性：不稳定 快排的应用很广泛，由于它在大多数情况下都比别的算法快，内循环简单，比较次数少。快排的性能取决于切分元素的选择，最好的情况是每次都把数组均分成两半，最坏情况是每次都选到了最大或最小的元素，此时退化成冒泡排序，每次只能确定一个值的位置。快拍的时间复杂度是 nlgn 且常数比其他同级别的算法小，空间复杂度 lgn （调用函数栈的开销），最坏情况下也就是冒泡排序的复杂度，分别是 n^2, n。通常会在排序前打乱所有数据，使待排序数据随机分布。 1234567891011121314151617private static void quickSort(Comparable[] arr, int start, int end) &#123; if(start&gt;=end) return; int i=start,j=end+1; Comparable key=arr[i]; while(true) &#123; while(j&gt;i &amp;&amp; arr[--j].compareTo(key)&gt;=0); if(i&gt;=j) break; arr[i]=arr[j]; while(i&lt;j &amp;&amp; arr[++i].compareTo(key)&lt;0); if(i&gt;=j) break; arr[j]=arr[i]; &#125; arr[i]=key; quickSort(arr, start, i-1); quickSort(arr, i+1, end);&#125; 当数组中有大量重复元素时，可以对快排进行优化，避免对相同元素的排序，从而将时间复杂度降到线性级别，该算法称为三向切分快速排序。 123456789101112131415161718192021222324public static void quickSort_3way(Comparable[] arr, int left, int right) &#123; if(left&gt;=right) return; int l=left, r=right, i=left+1; Comparable key=arr[left]; while(i&lt;r) &#123; int com=arr[i].compareTo(key); if(com&lt;0) &#123; Comparable tmp=arr[l]; arr[l]=arr[i]; arr[i]=tmp; i++; l++; &#125; else if(com&gt;0) &#123; Comparable tmp=arr[r]; arr[r]=arr[i]; arr[i]=tmp; r--; &#125; else &#123; i++; &#125; &#125; quickSort_3way(arr, left, l-1); quickSort_3way(arr, r+1, right);&#125; 堆排序堆通常指二叉堆，有大堆和小堆。用数组表示，数组元素之间的关系可以按照顺序排成一棵完全二叉树。在大堆中，以任意节点为根节点的子树，它的根节点是最大的节点；小堆相反。若索引从0开始表示，那么 k 的两个子节点分别是 2×k+1 和 2×k+2 ，k 的父节点是 (k-1)/2。大堆的最大元素在堆顶，用堆顶元素与最末元素交换，前移一位最末元素的指针，同时使堆重新有序，直到末元素指针指到堆顶。注意建堆的时候是从第一个非叶节点开始对节点下沉。 利用了堆的性质，使算法的复杂度达到了 NlgN ，同时空间复杂度是 1。 比较次数：少于（2NlgN+2N） 交换次数：NlgN+N 时间复杂度：NlgN 空间复杂度：1 最坏情况下时间复杂度：2NlgN 稳定性：不稳定 堆排序不能利用缓存，速度也不如快排，所以很少使用。但是在对内存要求很高的环境，如嵌入式系统中，堆排序是一个好的选择。虽然堆排序的应用不多，但是用堆实现的优先队列很重要，它能在对数级别实现插入和删除。 1234567891011121314151617181920212223242526272829303132public static void heapSort(Comparable[] arr) &#123; heap_build(arr); int k=arr.length-1; while(k&gt;0) &#123; Comparable tmp=arr[k]; arr[k]=arr[0]; arr[0]=tmp; k--; heap_sink(arr, 0, k); &#125;&#125;private static void heap_build(Comparable[] arr) &#123; int k = arr.length-1; for(int i=(k-1)/2;i&gt;=0;i--) &#123; if(arr[i].compareTo(arr[2*i+1]) &gt; 0 || (2*i+1&lt;=k &amp;&amp; arr[i].compareTo(arr[2*i+2])&gt;0)) heap_sink(arr, i, arr.length-1); &#125;&#125;private static void heap_sink(Comparable[] arr, int k, int len) &#123; if(k&gt;len/2-1 || k&lt;0) return ; while(k&lt;=len/2-1) &#123; int c=2*k+1; if(c+1 &lt; len &amp;&amp; arr[c].compareTo(arr[c+1])&lt;0) c++; if(arr[c].compareTo(arr[k])&gt;0) &#123; Comparable tmp=arr[c]; arr[c]=arr[k]; arr[k]=tmp; k=c; &#125; else &#123; break; &#125; &#125;&#125; 总结几种常见的排序算法都介绍完了，这里简单的总结一下： 在所有排序算法中，应用最广泛的是快速排序。 快排，归并、堆排都是 NlgN 级别的，但是快排的内循环最简单，只是顺序的访问数组，且比较次数和交换次数都少。在大部分应用场景下，快排都是最快的，但是他的性能和选择的分隔元素有关。归并排序和输入无关，总能保证nlgn的效率，但是它的空间复杂度是 O（N），同时，它是稳定的排序。堆排序应用的不多，除非是在对内存要求很高的环境下，因为它的空间复杂度是1。 在数组比较小的情况下，优先选择插入排序或选择排序。因为算法简单，不需要递归调用，在小数组时比nlng的算法快。插入排序和输入有关，在小数组，部分有序的情况下，能达到线性级别，所以很多大数组排序的优化都是递归到小数组以后用插入排序。 希尔排序是插入排序的改进。通过将数组分成k组，每组的元素间间隔是k，对k组元素分别进行插入排序，然后减小间隔直到1。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些优秀的博客链接]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E4%BC%98%E7%A7%80%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[说明这篇文章主要是放一些自己觉得写得比较好的博客链接，整理在这里，方便自己需要或是有空的时候来阅读。文中的内容会不断更新。 链接CoolShell CoolShell 作者是一位行业大牛，博客的内容没有过多关注具体的某方面技术或是一些技术细节，更多的是从比较高的层次写一些行业内的动态和发展以及新技术，内容涉及的面很广。 罗道文的私房菜 罗道文的私房菜 看得出博主的技术也很强，关注的方向主要是后端开发、存储系统，主要使用的语言是C++，而且博主的内容更新得很快。 始终 始终 博主的文章有技术方向的，也有一些英语学习的。 Jey Zhang Jey Zhang 博主的文章主要是机器学习方向 ZeeCoder ZeeCoder 博主的文章主要是计算机方面的基础比较多。 Jark’s Blog Jark’s Blog 博主的文章关注于分布式系统以及一些计算机基础。 文中对各个博客简单的描述只是为了方便整理和阅读，如有说得不对的地方，还请海涵。]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[站点的搭建过程用两天时间完成了这个blog的搭建，现在勉强能看得过去了，当然还有一些问题，以后有时间再慢慢丰富完善。在用Hexo搭建自己的blog的过程中，参考了许多别人写的教程和博客，主要有博客（博主的文章也很不错），Next的文档，Hexo的文档。其实文档官方的文档写得挺好的，照着文档的步骤基本上就能把blog搭起来，问题主要在应用一些第三方插件来丰富站点比较麻烦。网上已经有很多利用Hexo搭建blog的教程了，没必要过多重复赘述，这里主要叙述一下我遇到的问题。完成blog的基本功能后，在本地测试通过，然后在github上建立一个对应的仓库存放站点。在阿里云上买了一个域名，将其解析到自己的github下的blog，这里主要是要做一个实名验证，并且要把域名和对应的ip绑定，可以通过ping自己的github站点看到ip。添加搜索功能。官方文档推荐用swiftype，但是我在注册的时候出现了一些问题，就选择了最简单的local search，感觉也还不错。添加评论区。这个我选择了disqus，按照文档和别人博客的步骤设置。看到disqus网页上的内容还是很多的，有时间可以研究一下。统计访问量。阅读次数统计使用的是LeanCloud，这个好像是给web应用和app提供服务的，功能很多，这里只用到了统计访问量。提供搜索引擎检索。按照文档中的步骤添加了百度和谷歌的检索，但是好像没有奏效，目前不知道问题出在哪，过段时间好好看一下。 初识Markdown博客的书写建议采用markdown，在此之前在下也没有接触过markdown，算是一个小白。markdonw的语法还有比较简单的，看这文档和一些入门教程多写几次应该就可以应付一般的博客排版了。这里有一些还错的资源： 文档：http://wowubuntu.com/markdown/ 博客：http://www.jianshu.com/p/1e402922ee32/ 博客：http://www.jianshu.com/p/q81RER 有道云笔记文档：http://note.youdao.com/iyoudao/?p=2411 写博客的动机很久以前就想过要写博客，因为平时自己也会看一些技术博客。但由于自己水平很差，同时看到很多博客页面让我感觉不是很好，就一直没写。直到发现了用Hexo来搭建博客，被页面简洁清爽无广告的视觉体验吸引，而且站点可以放在github上，拥有自己的域名，不依赖于其他的平台，就想用它来搭建自己的博客。由于自己平时也看一些大牛的博客，而且遇到问题经常google到一些很好的博客，受益很大，所以也决定开始写博客。一方面能总结自己在学习过程中遇到的问题与收获，作为一个记录;另一方面，自己踩过的坑和笔记若能对需要的人有一些帮助，那也算一份功德。而且写博客的过程中，也能促进自己去思考和总结，何乐而不为。博主非计算机专业，但对这方面比较感兴趣，可惜水平不高。博客的内容可能大都是与技术相关，可能也会也其他的一些。写博客也是为了督促自己不断学习和进步，同时提高自己的书面表达能力。曾经有老师对我说过：一样东西，你能把别人讲懂了，你自己才是真的懂了。所以博主会力求认真写好每一篇博客，为了让自己懂，也为别人懂。 这是在下的第一个博客站点，也是第一篇博客，所以有些激动，以后还要多多学习，写出好的博客，也希望看到的朋友不吝指点。]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
</search>
